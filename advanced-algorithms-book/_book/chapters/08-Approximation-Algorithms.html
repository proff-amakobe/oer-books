<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>9&nbsp; Chapter 8: Approximation Algorithms - When “Good Enough” is Perfect – Advanced Computational Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/07-Computational-Complexity.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-9b98f18118eee809be1c051eb5cc78e4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/01-introduction.html">Core Concepts</a></li><li class="breadcrumb-item"><a href="../chapters/08-Approximation-Algorithms.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Chapter 8: Approximation Algorithms - When “Good Enough” is Perfect</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Advanced Computational Algorithms</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Preface</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Advanced Computational Algorithms</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Core Concepts</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/01-introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Advanced Algorithms: A Journey Through Computational Problem Solving</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/02-Divide-and-Conquer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Advanced Algorithms: A Journey Through Computational Problem Solving</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/03-Data-Structures-for-Efficiency.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Chapter 3: Data Structures for Efficiency</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/04-Greedy-Algorithms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Chapter 4: Greedy Algorithms - When Local Optimality Leads to Global Solutions</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/05-Dynamic-Programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Advanced Algorithms: A Journey Through Computational Problem Solving</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/06-Randomized-Algorithms.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Chapter 6: Randomized Algorithms - The Power of Controlled Chaos</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/07-Computational-Complexity.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Chapter 7: Computational Complexity &amp; NP-Completeness - The Limits of Computing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/08-Approximation-Algorithms.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Chapter 8: Approximation Algorithms - When “Good Enough” is Perfect</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#the-art-of-strategic-compromise" id="toc-the-art-of-strategic-compromise" class="nav-link active" data-scroll-target="#the-art-of-strategic-compromise"><span class="header-section-number">9.1</span> The Art of Strategic Compromise</a></li>
  <li><a href="#introduction-the-99-solution" id="toc-introduction-the-99-solution" class="nav-link" data-scroll-target="#introduction-the-99-solution"><span class="header-section-number">9.2</span> Introduction: The 99% Solution</a>
  <ul class="collapse">
  <li><a href="#a-real-world-success-story" id="toc-a-real-world-success-story" class="nav-link" data-scroll-target="#a-real-world-success-story"><span class="header-section-number">9.2.1</span> A Real-World Success Story</a></li>
  <li><a href="#why-approximation-algorithms-matter" id="toc-why-approximation-algorithms-matter" class="nav-link" data-scroll-target="#why-approximation-algorithms-matter"><span class="header-section-number">9.2.2</span> Why Approximation Algorithms Matter</a></li>
  <li><a href="#the-approximation-guarantee" id="toc-the-approximation-guarantee" class="nav-link" data-scroll-target="#the-approximation-guarantee"><span class="header-section-number">9.2.3</span> The Approximation Guarantee</a></li>
  <li><a href="#what-youll-learn" id="toc-what-youll-learn" class="nav-link" data-scroll-target="#what-youll-learn"><span class="header-section-number">9.2.4</span> What You’ll Learn</a></li>
  </ul></li>
  <li><a href="#section-8.1-the-fundamentals-of-approximation" id="toc-section-8.1-the-fundamentals-of-approximation" class="nav-link" data-scroll-target="#section-8.1-the-fundamentals-of-approximation"><span class="header-section-number">9.3</span> Section 8.1: The Fundamentals of Approximation</a>
  <ul class="collapse">
  <li><a href="#understanding-approximation-ratios" id="toc-understanding-approximation-ratios" class="nav-link" data-scroll-target="#understanding-approximation-ratios"><span class="header-section-number">9.3.1</span> Understanding Approximation Ratios</a></li>
  <li><a href="#types-of-approximation-guarantees" id="toc-types-of-approximation-guarantees" class="nav-link" data-scroll-target="#types-of-approximation-guarantees"><span class="header-section-number">9.3.2</span> Types of Approximation Guarantees</a></li>
  <li><a href="#when-approximation-is-impossible" id="toc-when-approximation-is-impossible" class="nav-link" data-scroll-target="#when-approximation-is-impossible"><span class="header-section-number">9.3.3</span> When Approximation is Impossible</a></li>
  <li><a href="#the-approximation-algorithm-design-process" id="toc-the-approximation-algorithm-design-process" class="nav-link" data-scroll-target="#the-approximation-algorithm-design-process"><span class="header-section-number">9.3.4</span> The Approximation Algorithm Design Process</a></li>
  </ul></li>
  <li><a href="#section-8.2-vertex-cover---a-classic-2-approximation" id="toc-section-8.2-vertex-cover---a-classic-2-approximation" class="nav-link" data-scroll-target="#section-8.2-vertex-cover---a-classic-2-approximation"><span class="header-section-number">9.4</span> Section 8.2: Vertex Cover - A Classic 2-Approximation</a>
  <ul class="collapse">
  <li><a href="#the-vertex-cover-problem" id="toc-the-vertex-cover-problem" class="nav-link" data-scroll-target="#the-vertex-cover-problem"><span class="header-section-number">9.4.1</span> The Vertex Cover Problem</a></li>
  <li><a href="#the-naive-approach" id="toc-the-naive-approach" class="nav-link" data-scroll-target="#the-naive-approach"><span class="header-section-number">9.4.2</span> The Naive Approach</a></li>
  <li><a href="#the-greedy-2-approximation" id="toc-the-greedy-2-approximation" class="nav-link" data-scroll-target="#the-greedy-2-approximation"><span class="header-section-number">9.4.3</span> The Greedy 2-Approximation</a></li>
  <li><a href="#why-this-is-a-2-approximation" id="toc-why-this-is-a-2-approximation" class="nav-link" data-scroll-target="#why-this-is-a-2-approximation"><span class="header-section-number">9.4.4</span> Why This is a 2-Approximation</a></li>
  <li><a href="#an-improved-algorithm-maximum-matching" id="toc-an-improved-algorithm-maximum-matching" class="nav-link" data-scroll-target="#an-improved-algorithm-maximum-matching"><span class="header-section-number">9.4.5</span> An Improved Algorithm: Maximum Matching</a></li>
  <li><a href="#can-we-do-better-than-2" id="toc-can-we-do-better-than-2" class="nav-link" data-scroll-target="#can-we-do-better-than-2"><span class="header-section-number">9.4.6</span> Can We Do Better Than 2?</a></li>
  </ul></li>
  <li><a href="#section-8.3-the-traveling-salesman-problem" id="toc-section-8.3-the-traveling-salesman-problem" class="nav-link" data-scroll-target="#section-8.3-the-traveling-salesman-problem"><span class="header-section-number">9.5</span> Section 8.3: The Traveling Salesman Problem</a>
  <ul class="collapse">
  <li><a href="#tsp-with-triangle-inequality" id="toc-tsp-with-triangle-inequality" class="nav-link" data-scroll-target="#tsp-with-triangle-inequality"><span class="header-section-number">9.5.1</span> TSP with Triangle Inequality</a></li>
  <li><a href="#the-2-approximation-algorithm" id="toc-the-2-approximation-algorithm" class="nav-link" data-scroll-target="#the-2-approximation-algorithm"><span class="header-section-number">9.5.2</span> The 2-Approximation Algorithm</a></li>
  <li><a href="#why-this-is-a-2-approximation-1" id="toc-why-this-is-a-2-approximation-1" class="nav-link" data-scroll-target="#why-this-is-a-2-approximation-1"><span class="header-section-number">9.5.3</span> Why This is a 2-Approximation</a></li>
  <li><a href="#christofides-algorithm-1.5-approximation" id="toc-christofides-algorithm-1.5-approximation" class="nav-link" data-scroll-target="#christofides-algorithm-1.5-approximation"><span class="header-section-number">9.5.4</span> Christofides Algorithm: 1.5-Approximation</a></li>
  </ul></li>
  <li><a href="#section-8.4-set-cover-and-greedy-algorithms" id="toc-section-8.4-set-cover-and-greedy-algorithms" class="nav-link" data-scroll-target="#section-8.4-set-cover-and-greedy-algorithms"><span class="header-section-number">9.6</span> Section 8.4: Set Cover and Greedy Algorithms</a>
  <ul class="collapse">
  <li><a href="#the-set-cover-problem" id="toc-the-set-cover-problem" class="nav-link" data-scroll-target="#the-set-cover-problem"><span class="header-section-number">9.6.1</span> The Set Cover Problem</a></li>
  <li><a href="#the-greedy-algorithm" id="toc-the-greedy-algorithm" class="nav-link" data-scroll-target="#the-greedy-algorithm"><span class="header-section-number">9.6.2</span> The Greedy Algorithm</a></li>
  <li><a href="#why-lnn-approximation" id="toc-why-lnn-approximation" class="nav-link" data-scroll-target="#why-lnn-approximation"><span class="header-section-number">9.6.3</span> Why ln(n) Approximation?</a></li>
  <li><a href="#the-weighted-version" id="toc-the-weighted-version" class="nav-link" data-scroll-target="#the-weighted-version"><span class="header-section-number">9.6.4</span> The Weighted Version</a></li>
  <li><a href="#when-greedy-is-optimal-matroids" id="toc-when-greedy-is-optimal-matroids" class="nav-link" data-scroll-target="#when-greedy-is-optimal-matroids"><span class="header-section-number">9.6.5</span> When Greedy is Optimal: Matroids</a></li>
  </ul></li>
  <li><a href="#section-8.5-randomized-approximation" id="toc-section-8.5-randomized-approximation" class="nav-link" data-scroll-target="#section-8.5-randomized-approximation"><span class="header-section-number">9.7</span> Section 8.5: Randomized Approximation</a>
  <ul class="collapse">
  <li><a href="#the-power-of-random-choices" id="toc-the-power-of-random-choices" class="nav-link" data-scroll-target="#the-power-of-random-choices"><span class="header-section-number">9.7.1</span> The Power of Random Choices</a></li>
  <li><a href="#max-cut-a-simple-randomized-algorithm" id="toc-max-cut-a-simple-randomized-algorithm" class="nav-link" data-scroll-target="#max-cut-a-simple-randomized-algorithm"><span class="header-section-number">9.7.2</span> MAX-CUT: A Simple Randomized Algorithm</a></li>
  <li><a href="#max-sat-randomized-rounding" id="toc-max-sat-randomized-rounding" class="nav-link" data-scroll-target="#max-sat-randomized-rounding"><span class="header-section-number">9.7.3</span> MAX-SAT: Randomized Rounding</a></li>
  <li><a href="#the-method-of-conditional-expectations" id="toc-the-method-of-conditional-expectations" class="nav-link" data-scroll-target="#the-method-of-conditional-expectations"><span class="header-section-number">9.7.4</span> The Method of Conditional Expectations</a></li>
  </ul></li>
  <li><a href="#section-8.6-linear-programming-relaxation" id="toc-section-8.6-linear-programming-relaxation" class="nav-link" data-scroll-target="#section-8.6-linear-programming-relaxation"><span class="header-section-number">9.8</span> Section 8.6: Linear Programming Relaxation</a>
  <ul class="collapse">
  <li><a href="#the-power-of-relaxation" id="toc-the-power-of-relaxation" class="nav-link" data-scroll-target="#the-power-of-relaxation"><span class="header-section-number">9.8.1</span> The Power of Relaxation</a></li>
  <li><a href="#vertex-cover-via-lp-relaxation" id="toc-vertex-cover-via-lp-relaxation" class="nav-link" data-scroll-target="#vertex-cover-via-lp-relaxation"><span class="header-section-number">9.8.2</span> Vertex Cover via LP Relaxation</a></li>
  <li><a href="#set-cover-via-lp-relaxation" id="toc-set-cover-via-lp-relaxation" class="nav-link" data-scroll-target="#set-cover-via-lp-relaxation"><span class="header-section-number">9.8.3</span> Set Cover via LP Relaxation</a></li>
  <li><a href="#the-integrality-gap" id="toc-the-integrality-gap" class="nav-link" data-scroll-target="#the-integrality-gap"><span class="header-section-number">9.8.4</span> The Integrality Gap</a></li>
  </ul></li>
  <li><a href="#section-8.7-approximation-schemes" id="toc-section-8.7-approximation-schemes" class="nav-link" data-scroll-target="#section-8.7-approximation-schemes"><span class="header-section-number">9.9</span> Section 8.7: Approximation Schemes</a>
  <ul class="collapse">
  <li><a href="#ptas-polynomial-time-approximation-scheme" id="toc-ptas-polynomial-time-approximation-scheme" class="nav-link" data-scroll-target="#ptas-polynomial-time-approximation-scheme"><span class="header-section-number">9.9.1</span> PTAS: Polynomial Time Approximation Scheme</a></li>
  <li><a href="#knapsack-a-classic-fptas" id="toc-knapsack-a-classic-fptas" class="nav-link" data-scroll-target="#knapsack-a-classic-fptas"><span class="header-section-number">9.9.2</span> Knapsack: A Classic FPTAS</a></li>
  <li><a href="#euclidean-tsp-a-ptas" id="toc-euclidean-tsp-a-ptas" class="nav-link" data-scroll-target="#euclidean-tsp-a-ptas"><span class="header-section-number">9.9.3</span> Euclidean TSP: A PTAS</a></li>
  <li><a href="#when-ptas-exists" id="toc-when-ptas-exists" class="nav-link" data-scroll-target="#when-ptas-exists"><span class="header-section-number">9.9.4</span> When PTAS Exists</a></li>
  </ul></li>
  <li><a href="#section-8.8-hardness-of-approximation" id="toc-section-8.8-hardness-of-approximation" class="nav-link" data-scroll-target="#section-8.8-hardness-of-approximation"><span class="header-section-number">9.10</span> Section 8.8: Hardness of Approximation</a>
  <ul class="collapse">
  <li><a href="#some-problems-resist-approximation" id="toc-some-problems-resist-approximation" class="nav-link" data-scroll-target="#some-problems-resist-approximation"><span class="header-section-number">9.10.1</span> Some Problems Resist Approximation</a></li>
  <li><a href="#inapproximability-results" id="toc-inapproximability-results" class="nav-link" data-scroll-target="#inapproximability-results"><span class="header-section-number">9.10.2</span> Inapproximability Results</a></li>
  <li><a href="#the-pcp-theorem" id="toc-the-pcp-theorem" class="nav-link" data-scroll-target="#the-pcp-theorem"><span class="header-section-number">9.10.3</span> The PCP Theorem</a></li>
  <li><a href="#apx-completeness" id="toc-apx-completeness" class="nav-link" data-scroll-target="#apx-completeness"><span class="header-section-number">9.10.4</span> APX-Completeness</a></li>
  </ul></li>
  <li><a href="#chapter-8-practical-implementation-guide" id="toc-chapter-8-practical-implementation-guide" class="nav-link" data-scroll-target="#chapter-8-practical-implementation-guide"><span class="header-section-number">9.11</span> Chapter 8: Practical Implementation Guide</a>
  <ul class="collapse">
  <li><a href="#a-complete-approximation-algorithm-toolkit" id="toc-a-complete-approximation-algorithm-toolkit" class="nav-link" data-scroll-target="#a-complete-approximation-algorithm-toolkit"><span class="header-section-number">9.11.1</span> A Complete Approximation Algorithm Toolkit</a></li>
  </ul></li>
  <li><a href="#chapter-8-exercises" id="toc-chapter-8-exercises" class="nav-link" data-scroll-target="#chapter-8-exercises"><span class="header-section-number">9.12</span> Chapter 8 Exercises</a>
  <ul class="collapse">
  <li><a href="#conceptual-understanding" id="toc-conceptual-understanding" class="nav-link" data-scroll-target="#conceptual-understanding"><span class="header-section-number">9.12.1</span> Conceptual Understanding</a></li>
  <li><a href="#implementation-problems" id="toc-implementation-problems" class="nav-link" data-scroll-target="#implementation-problems"><span class="header-section-number">9.12.2</span> Implementation Problems</a></li>
  <li><a href="#analysis-problems" id="toc-analysis-problems" class="nav-link" data-scroll-target="#analysis-problems"><span class="header-section-number">9.12.3</span> Analysis Problems</a></li>
  </ul></li>
  <li><a href="#chapter-8-summary" id="toc-chapter-8-summary" class="nav-link" data-scroll-target="#chapter-8-summary"><span class="header-section-number">9.13</span> Chapter 8 Summary</a>
  <ul class="collapse">
  <li><a href="#key-takeaways" id="toc-key-takeaways" class="nav-link" data-scroll-target="#key-takeaways"><span class="header-section-number">9.13.1</span> Key Takeaways</a></li>
  <li><a href="#decision-framework" id="toc-decision-framework" class="nav-link" data-scroll-target="#decision-framework"><span class="header-section-number">9.13.2</span> Decision Framework</a></li>
  <li><a href="#the-art-of-approximation" id="toc-the-art-of-approximation" class="nav-link" data-scroll-target="#the-art-of-approximation"><span class="header-section-number">9.13.3</span> The Art of Approximation</a></li>
  <li><a href="#looking-forward" id="toc-looking-forward" class="nav-link" data-scroll-target="#looking-forward"><span class="header-section-number">9.13.4</span> Looking Forward</a></li>
  <li><a href="#next-chapter-preview" id="toc-next-chapter-preview" class="nav-link" data-scroll-target="#next-chapter-preview"><span class="header-section-number">9.13.5</span> Next Chapter Preview</a></li>
  <li><a href="#final-thought" id="toc-final-thought" class="nav-link" data-scroll-target="#final-thought"><span class="header-section-number">9.13.6</span> Final Thought</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/01-introduction.html">Core Concepts</a></li><li class="breadcrumb-item"><a href="../chapters/08-Approximation-Algorithms.html"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Chapter 8: Approximation Algorithms - When “Good Enough” is Perfect</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Chapter 8: Approximation Algorithms - When “Good Enough” is Perfect</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="the-art-of-strategic-compromise" class="level2" data-number="9.1">
<h2 data-number="9.1" class="anchored" data-anchor-id="the-art-of-strategic-compromise"><span class="header-section-number">9.1</span> The Art of Strategic Compromise</h2>
<p><em>“The perfect is the enemy of the good.” - Voltaire</em> <em>“But in computer science, we can prove exactly how good ‘good’ is.” - Modern CS</em></p>
<hr>
</section>
<section id="introduction-the-99-solution" class="level2" data-number="9.2">
<h2 data-number="9.2" class="anchored" data-anchor-id="introduction-the-99-solution"><span class="header-section-number">9.2</span> Introduction: The 99% Solution</h2>
<p>Imagine you’re planning a road trip to visit 50 tourist attractions across the country. Finding the absolute shortest route would take longer than the age of the universe (it’s NP-complete!). But what if I told you that in just a few seconds, we could find a route that’s guaranteed to be at most 50% longer than the shortest possible route? Would you take it?</p>
<p>Of course you would! An extra few hours of driving is infinitely better than waiting billions of years for the perfect route.</p>
<p>This is the essence of approximation algorithms: <strong>trading perfection for practicality while maintaining mathematical guarantees about solution quality</strong>.</p>
<section id="a-real-world-success-story" class="level3" data-number="9.2.1">
<h3 data-number="9.2.1" class="anchored" data-anchor-id="a-real-world-success-story"><span class="header-section-number">9.2.1</span> A Real-World Success Story</h3>
<p>In 1999, UPS implemented an approximation algorithm for their delivery routing (a variant of the Vehicle Routing Problem, which is NP-hard). The results were staggering:</p>
<ul>
<li><strong>Before:</strong> Human dispatchers planning routes by intuition</li>
<li><strong>After:</strong> Approximation algorithm guaranteeing routes within 10% of optimal</li>
<li><strong>Impact:</strong> Saved 10 million gallons of fuel per year, $300+ million annually</li>
<li><strong>Computation time:</strong> Seconds instead of centuries</li>
</ul>
<p>The routes weren’t perfect, but they were provably good and computationally achievable. That’s the power of approximation!</p>
</section>
<section id="why-approximation-algorithms-matter" class="level3" data-number="9.2.2">
<h3 data-number="9.2.2" class="anchored" data-anchor-id="why-approximation-algorithms-matter"><span class="header-section-number">9.2.2</span> Why Approximation Algorithms Matter</h3>
<p>When faced with an NP-hard problem, you have several options:</p>
<ol type="1">
<li><strong>Exponential exact algorithms</strong> - Perfect but impossibly slow</li>
<li><strong>Heuristics</strong> - Fast but no quality guarantee</li>
<li><strong>Approximation algorithms</strong> - Fast WITH quality guarantees ✨</li>
</ol>
<p>Approximation algorithms give you the best of both worlds: speed and confidence.</p>
</section>
<section id="the-approximation-guarantee" class="level3" data-number="9.2.3">
<h3 data-number="9.2.3" class="anchored" data-anchor-id="the-approximation-guarantee"><span class="header-section-number">9.2.3</span> The Approximation Guarantee</h3>
<p>The key concept is the <strong>approximation ratio</strong>:</p>
<p>For a minimization problem: - Algorithm solution ≤ α × optimal solution</p>
<p>For a maximization problem: - Algorithm solution ≥ (1/α) × optimal solution</p>
<p>Where α is the approximation ratio (α ≥ 1).</p>
<p><strong>Example:</strong> - 2-approximation for TSP means: your route ≤ 2 × shortest route - 0.5-approximation for Max-Cut means: your cut ≥ 0.5 × maximum cut</p>
</section>
<section id="what-youll-learn" class="level3" data-number="9.2.4">
<h3 data-number="9.2.4" class="anchored" data-anchor-id="what-youll-learn"><span class="header-section-number">9.2.4</span> What You’ll Learn</h3>
<p>This chapter will teach you to:</p>
<ol type="1">
<li><strong>Design</strong> approximation algorithms with provable guarantees</li>
<li><strong>Analyze</strong> approximation ratios rigorously</li>
<li><strong>Apply</strong> standard techniques (greedy, LP relaxation, randomization)</li>
<li><strong>Recognize</strong> when approximation is possible (and when it’s not)</li>
<li><strong>Implement</strong> practical approximation algorithms</li>
</ol>
<p>By the end, you’ll have a powerful toolkit for tackling NP-hard problems in the real world!</p>
<hr>
</section>
</section>
<section id="section-8.1-the-fundamentals-of-approximation" class="level2" data-number="9.3">
<h2 data-number="9.3" class="anchored" data-anchor-id="section-8.1-the-fundamentals-of-approximation"><span class="header-section-number">9.3</span> Section 8.1: The Fundamentals of Approximation</h2>
<section id="understanding-approximation-ratios" class="level3" data-number="9.3.1">
<h3 data-number="9.3.1" class="anchored" data-anchor-id="understanding-approximation-ratios"><span class="header-section-number">9.3.1</span> Understanding Approximation Ratios</h3>
<p>Let’s start with a simple example to build intuition.</p>
<section id="the-lemonade-stand-location-problem" class="level4" data-number="9.3.1.1">
<h4 data-number="9.3.1.1" class="anchored" data-anchor-id="the-lemonade-stand-location-problem"><span class="header-section-number">9.3.1.1</span> The Lemonade Stand Location Problem</h4>
<p>You want to place lemonade stands to serve houses along a street. Each stand can serve houses within 1 block. What’s the minimum number of stands needed?</p>
<p><strong>Optimal Solution:</strong> NP-hard to find!</p>
<p><strong>Greedy Approximation:</strong> 1. Start from the leftmost uncovered house 2. Place a stand 1 block to its right 3. Repeat until all houses covered</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lemonade_stands_greedy(houses):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Place minimum number of lemonade stands to cover all houses.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Each stand covers houses within distance 1.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    This is a 2-approximation algorithm!</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    houses <span class="op">=</span> <span class="bu">sorted</span>(houses)  <span class="co"># Sort by position</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    stands <span class="op">=</span> []</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(houses):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Place stand 1 unit to the right of current house</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        stand_position <span class="op">=</span> houses[i] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        stands.append(stand_position)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Skip all houses covered by this stand</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(houses) <span class="kw">and</span> houses[i] <span class="op">&lt;=</span> stand_position <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> stands</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>houses <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">10</span>, <span class="dv">11</span>]</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>stands <span class="op">=</span> lemonade_stands_greedy(houses)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Houses: </span><span class="sc">{</span>houses<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Stands at: </span><span class="sc">{</span>stands<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of stands: </span><span class="sc">{</span><span class="bu">len</span>(stands)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Output: Stands at: [2, 7, 11], Number of stands: 3</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why is this a 2-approximation?</strong></p>
<p><strong>Proof intuition:</strong> - Our greedy algorithm places stands at positions based on leftmost uncovered house - The optimal solution must also cover these houses - In the worst case, optimal places stands perfectly between our stands - But that means optimal needs at least half as many stands as we use - Therefore: our solution ≤ 2 × optimal</p>
</section>
</section>
<section id="types-of-approximation-guarantees" class="level3" data-number="9.3.2">
<h3 data-number="9.3.2" class="anchored" data-anchor-id="types-of-approximation-guarantees"><span class="header-section-number">9.3.2</span> Types of Approximation Guarantees</h3>
<section id="constant-factor-approximation" class="level4" data-number="9.3.2.1">
<h4 data-number="9.3.2.1" class="anchored" data-anchor-id="constant-factor-approximation"><span class="header-section-number">9.3.2.1</span> Constant Factor Approximation</h4>
<p><strong>Definition:</strong> Algorithm always within constant factor of optimal.</p>
<p><strong>Example:</strong> 2-approximation for Vertex Cover - Your solution ≤ 2 × optimal - Works for ANY input - The “2” doesn’t grow with input size</p>
</section>
<section id="logarithmic-approximation" class="level4" data-number="9.3.2.2">
<h4 data-number="9.3.2.2" class="anchored" data-anchor-id="logarithmic-approximation"><span class="header-section-number">9.3.2.2</span> Logarithmic Approximation</h4>
<p><strong>Definition:</strong> Factor grows logarithmically with input size.</p>
<p><strong>Example:</strong> O(log n)-approximation for Set Cover - Your solution ≤ (ln n) × optimal - Factor grows, but slowly - Still practical for large inputs</p>
</section>
<section id="polynomial-approximation-schemes-ptas" class="level4" data-number="9.3.2.3">
<h4 data-number="9.3.2.3" class="anchored" data-anchor-id="polynomial-approximation-schemes-ptas"><span class="header-section-number">9.3.2.3</span> Polynomial Approximation Schemes (PTAS)</h4>
<p><strong>Definition:</strong> Get arbitrarily close to optimal, but time grows with accuracy.</p>
<p><strong>Example:</strong> (1 + ε)-approximation for Knapsack - Choose any ε &gt; 0 - Get solution within (1 + ε) factor - Runtime like O(n^(1/ε)) - polynomial for fixed ε</p>
</section>
</section>
<section id="when-approximation-is-impossible" class="level3" data-number="9.3.3">
<h3 data-number="9.3.3" class="anchored" data-anchor-id="when-approximation-is-impossible"><span class="header-section-number">9.3.3</span> When Approximation is Impossible</h3>
<p>Some problems resist approximation!</p>
<section id="the-traveling-salesman-problem-general" class="level4" data-number="9.3.3.1">
<h4 data-number="9.3.3.1" class="anchored" data-anchor-id="the-traveling-salesman-problem-general"><span class="header-section-number">9.3.3.1</span> The Traveling Salesman Problem (General)</h4>
<p><strong>Without triangle inequality:</strong> - Cannot approximate within ANY constant factor (unless P = NP) - Even getting within 1000000 × optimal is NP-hard!</p>
<p><strong>Why?</strong> If we could approximate general TSP, we could solve Hamiltonian Cycle (NP-complete).</p>
</section>
<section id="clique-problem" class="level4" data-number="9.3.3.2">
<h4 data-number="9.3.3.2" class="anchored" data-anchor-id="clique-problem"><span class="header-section-number">9.3.3.2</span> Clique Problem</h4>
<p><strong>Cannot approximate within n^(1-ε) for any ε &gt; 0</strong> (unless P = NP)</p>
<p>This means for a graph with 1000 nodes: - Can’t even guarantee finding a clique of size 10 when optimal is 100!</p>
</section>
</section>
<section id="the-approximation-algorithm-design-process" class="level3" data-number="9.3.4">
<h3 data-number="9.3.4" class="anchored" data-anchor-id="the-approximation-algorithm-design-process"><span class="header-section-number">9.3.4</span> The Approximation Algorithm Design Process</h3>
<ol type="1">
<li><strong>Understand the problem structure</strong>
<ul>
<li>What makes it hard?</li>
<li>Are there special cases?</li>
</ul></li>
<li><strong>Design a simple algorithm</strong>
<ul>
<li>Often greedy or based on relaxation</li>
<li>Must run in polynomial time</li>
</ul></li>
<li><strong>Prove the approximation ratio</strong>
<ul>
<li>Compare to optimal (without finding it!)</li>
<li>Use bounds and problem structure</li>
</ul></li>
<li><strong>Optimize if possible</strong>
<ul>
<li>Can you improve the constant?</li>
<li>Can you make it faster?</li>
</ul></li>
</ol>
<hr>
</section>
</section>
<section id="section-8.2-vertex-cover---a-classic-2-approximation" class="level2" data-number="9.4">
<h2 data-number="9.4" class="anchored" data-anchor-id="section-8.2-vertex-cover---a-classic-2-approximation"><span class="header-section-number">9.4</span> Section 8.2: Vertex Cover - A Classic 2-Approximation</h2>
<section id="the-vertex-cover-problem" class="level3" data-number="9.4.1">
<h3 data-number="9.4.1" class="anchored" data-anchor-id="the-vertex-cover-problem"><span class="header-section-number">9.4.1</span> The Vertex Cover Problem</h3>
<p><strong>Problem:</strong> Find the smallest set of vertices that “covers” all edges (every edge has at least one endpoint in the set).</p>
<p><strong>Applications:</strong> - Security camera placement (cover all corridors) - Network monitoring (monitor all connections) - Facility location (serve all demands)</p>
</section>
<section id="the-naive-approach" class="level3" data-number="9.4.2">
<h3 data-number="9.4.2" class="anchored" data-anchor-id="the-naive-approach"><span class="header-section-number">9.4.2</span> The Naive Approach</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vertex_cover_naive(graph):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Try all possible vertex subsets - exponential time!</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Only feasible for tiny graphs.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(graph.vertices)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    min_cover <span class="op">=</span> <span class="bu">set</span>(graph.vertices)  <span class="co"># Worst case: all vertices</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Try all 2^n subsets</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> mask <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> n):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        subset <span class="op">=</span> {v <span class="cf">for</span> i, v <span class="kw">in</span> <span class="bu">enumerate</span>(graph.vertices) <span class="cf">if</span> mask <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> i)}</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if it's a valid cover</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">all</span>(u <span class="kw">in</span> subset <span class="kw">or</span> v <span class="kw">in</span> subset <span class="cf">for</span> u, v <span class="kw">in</span> graph.edges):</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(subset) <span class="op">&lt;</span> <span class="bu">len</span>(min_cover):</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                min_cover <span class="op">=</span> subset</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_cover</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Time:</strong> O(2^n × m) - Impossibly slow for n &gt; 20!</p>
</section>
<section id="the-greedy-2-approximation" class="level3" data-number="9.4.3">
<h3 data-number="9.4.3" class="anchored" data-anchor-id="the-greedy-2-approximation"><span class="header-section-number">9.4.3</span> The Greedy 2-Approximation</h3>
<p>Here’s a beautifully simple algorithm:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vertex_cover_approx(graph):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    2-approximation for Vertex Cover.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Algorithm: Repeatedly pick an edge and add BOTH endpoints.</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Time: O(V + E)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Approximation ratio: 2</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    cover <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> <span class="bu">list</span>(graph.edges)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> edges:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Pick any uncovered edge</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        u, v <span class="op">=</span> edges[<span class="dv">0</span>]</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add both endpoints to cover</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        cover.add(u)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        cover.add(v)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Remove all edges incident to u or v</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        edges <span class="op">=</span> [(a, b) <span class="cf">for</span> (a, b) <span class="kw">in</span> edges </span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> a <span class="op">!=</span> u <span class="kw">and</span> a <span class="op">!=</span> v <span class="kw">and</span> b <span class="op">!=</span> u <span class="kw">and</span> b <span class="op">!=</span> v]</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cover</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Graph:</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.edges <span class="op">=</span> [</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'A'</span>, <span class="st">'B'</span>), (<span class="st">'B'</span>, <span class="st">'C'</span>), (<span class="st">'C'</span>, <span class="st">'D'</span>),</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>            (<span class="st">'D'</span>, <span class="st">'E'</span>), (<span class="st">'E'</span>, <span class="st">'A'</span>), (<span class="st">'B'</span>, <span class="st">'D'</span>)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.vertices <span class="op">=</span> [<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>, <span class="st">'D'</span>, <span class="st">'E'</span>]</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> Graph()</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>cover <span class="op">=</span> vertex_cover_approx(g)</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Vertex cover: </span><span class="sc">{</span>cover<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Size: </span><span class="sc">{</span><span class="bu">len</span>(cover)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Might output: {'B', 'D', 'A', 'E'}, Size: 4</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="co"># Optimal might be: {'B', 'E'}, Size: 2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="why-this-is-a-2-approximation" class="level3" data-number="9.4.4">
<h3 data-number="9.4.4" class="anchored" data-anchor-id="why-this-is-a-2-approximation"><span class="header-section-number">9.4.4</span> Why This is a 2-Approximation</h3>
<p><strong>The Brilliant Proof:</strong></p>
<ol type="1">
<li><strong>Let M = edges selected by our algorithm</strong>
<ul>
<li>These edges are disjoint (no common vertices)</li>
<li>Our cover has size 2|M|</li>
</ul></li>
<li><strong>Any vertex cover must cover all edges in M</strong>
<ul>
<li>Since edges in M are disjoint</li>
<li>Optimal cover needs at least |M| vertices</li>
<li>Therefore: OPT ≥ |M|</li>
</ul></li>
<li><strong>Our approximation ratio:</strong>
<ul>
<li>Our size / OPT ≤ 2|M| / |M| = 2 ✓</li>
</ul></li>
</ol>
<p><strong>Visual Proof:</strong></p>
<pre><code>Selected edges (M):  A---B     C---D     E---F
Our cover:           A,B       C,D       E,F    (6 vertices)
Optimal must pick:   A or B    C or D    E or F (≥3 vertices)
Ratio:               6/3 = 2</code></pre>
</section>
<section id="an-improved-algorithm-maximum-matching" class="level3" data-number="9.4.5">
<h3 data-number="9.4.5" class="anchored" data-anchor-id="an-improved-algorithm-maximum-matching"><span class="header-section-number">9.4.5</span> An Improved Algorithm: Maximum Matching</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vertex_cover_matching(graph):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Better 2-approximation using maximal matching.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Often produces smaller covers in practice.</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    cover <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> <span class="bu">list</span>(graph.edges)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    covered_vertices <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> edges:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Only add edge if neither endpoint is covered</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> covered_vertices <span class="kw">and</span> v <span class="kw">not</span> <span class="kw">in</span> covered_vertices:</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            cover.add(u)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            cover.add(v)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            covered_vertices.add(u)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            covered_vertices.add(v)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cover</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="can-we-do-better-than-2" class="level3" data-number="9.4.6">
<h3 data-number="9.4.6" class="anchored" data-anchor-id="can-we-do-better-than-2"><span class="header-section-number">9.4.6</span> Can We Do Better Than 2?</h3>
<p><strong>The Unique Games Conjecture</strong> suggests we cannot approximate Vertex Cover better than 2 - ε for any ε &gt; 0.</p>
<p>But we can do better for special cases:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vertex_cover_tree(tree):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Exact algorithm for Vertex Cover on trees.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Uses dynamic programming - polynomial time!</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(node, parent, must_include):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns minimum cover size for subtree rooted at node.</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">        must_include: whether node must be in cover</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> tree[node]:  <span class="co"># Leaf</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span> <span class="cf">if</span> must_include <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> must_include:</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Node is in cover, children can be anything</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child <span class="kw">in</span> tree[node]:</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> child <span class="op">!=</span> parent:</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>                    size <span class="op">+=</span> <span class="bu">min</span>(dp(child, node, <span class="va">True</span>), </span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>                              dp(child, node, <span class="va">False</span>))</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Node not in cover, all children must be</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>            size <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> child <span class="kw">in</span> tree[node]:</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> child <span class="op">!=</span> parent:</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>                    size <span class="op">+=</span> dp(child, node, <span class="va">True</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> size</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    root <span class="op">=</span> tree.get_root()</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(dp(root, <span class="va">None</span>, <span class="va">True</span>), dp(root, <span class="va">None</span>, <span class="va">False</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
</section>
</section>
<section id="section-8.3-the-traveling-salesman-problem" class="level2" data-number="9.5">
<h2 data-number="9.5" class="anchored" data-anchor-id="section-8.3-the-traveling-salesman-problem"><span class="header-section-number">9.5</span> Section 8.3: The Traveling Salesman Problem</h2>
<section id="tsp-with-triangle-inequality" class="level3" data-number="9.5.1">
<h3 data-number="9.5.1" class="anchored" data-anchor-id="tsp-with-triangle-inequality"><span class="header-section-number">9.5.1</span> TSP with Triangle Inequality</h3>
<p>When distances satisfy the triangle inequality (direct routes are shortest), we can approximate!</p>
<p><strong>Triangle Inequality:</strong> dist(A,C) ≤ dist(A,B) + dist(B,C)</p>
<p>This is true for: - Euclidean distances (straight-line) - Road networks (usually) - Manhattan distances</p>
</section>
<section id="the-2-approximation-algorithm" class="level3" data-number="9.5.2">
<h3 data-number="9.5.2" class="anchored" data-anchor-id="the-2-approximation-algorithm"><span class="header-section-number">9.5.2</span> The 2-Approximation Algorithm</h3>
<p><strong>Key Insight:</strong> Use Minimum Spanning Tree (MST)!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> heapq</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tsp_2_approximation(graph):</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">    2-approximation for metric TSP using MST.</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Algorithm:</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">    1. Find MST</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">    2. Do DFS traversal</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">    3. Create tour using traversal order</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Time: O(V² log V) for complete graph</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Approximation ratio: 2</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_mst(graph):</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Find MST using Prim's algorithm."""</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="bu">len</span>(graph)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        mst <span class="op">=</span> [[] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        min_heap <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)]  <span class="co"># (weight, node, parent)</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> min_heap:</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>            weight, u, parent <span class="op">=</span> heapq.heappop(min_heap)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> visited[u]:</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>            visited[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> parent <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>                mst[parent].append(u)</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>                mst[u].append(parent)</span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> visited[v]:</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>                    heapq.heappush(min_heap, (graph[u][v], v, u))</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> mst</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs_traversal(mst, start<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""DFS traversal of MST."""</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>        visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> <span class="bu">len</span>(mst)</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>        tour <span class="op">=</span> []</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> dfs(u):</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>            visited[u] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>            tour.append(u)</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v <span class="kw">in</span> mst[u]:</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> visited[v]:</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>                    dfs(v)</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>        dfs(start)</span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>        tour.append(start)  <span class="co"># Return to start</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tour</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Find MST</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>    mst <span class="op">=</span> find_mst(graph)</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: DFS traversal</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>    tour <span class="op">=</span> dfs_traversal(mst)</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tour</span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a><span class="co"># Example with cities</span></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_distance_matrix(cities):</span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create distance matrix from city coordinates."""</span></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(cities)</span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>            dx <span class="op">=</span> cities[i][<span class="dv">0</span>] <span class="op">-</span> cities[j][<span class="dv">0</span>]</span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>            dy <span class="op">=</span> cities[i][<span class="dv">1</span>] <span class="op">-</span> cities[j][<span class="dv">1</span>]</span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>            dist[i][j] <span class="op">=</span> (dx<span class="op">*</span>dx <span class="op">+</span> dy<span class="op">*</span>dy) <span class="op">**</span> <span class="fl">0.5</span></span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dist</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a>cities <span class="op">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">0</span>), (<span class="dv">1</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">1</span>)]  <span class="co"># Square</span></span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>distances <span class="op">=</span> create_distance_matrix(cities)</span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>tour <span class="op">=</span> tsp_2_approximation(distances)</span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"TSP tour: </span><span class="sc">{</span>tour<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a><span class="co"># Output: [0, 1, 2, 3, 0] or similar</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="why-this-is-a-2-approximation-1" class="level3" data-number="9.5.3">
<h3 data-number="9.5.3" class="anchored" data-anchor-id="why-this-is-a-2-approximation-1"><span class="header-section-number">9.5.3</span> Why This is a 2-Approximation</h3>
<p><strong>The Proof:</strong></p>
<ol type="1">
<li><strong>MST weight ≤ OPT</strong>
<ul>
<li>Optimal TSP tour minus one edge is a spanning tree</li>
<li>MST is the minimum spanning tree</li>
<li>So: weight(MST) ≤ weight(OPT)</li>
</ul></li>
<li><strong>DFS traversal = 2 × MST</strong>
<ul>
<li>DFS visits each edge twice (down and up)</li>
<li>Total: 2 × weight(MST)</li>
</ul></li>
<li><strong>Triangle inequality saves us</strong>
<ul>
<li>Shortcuts never increase distance</li>
<li>Final tour ≤ DFS traversal</li>
</ul></li>
<li><strong>Therefore:</strong>
<ul>
<li>Tour ≤ 2 × MST ≤ 2 × OPT ✓</li>
</ul></li>
</ol>
</section>
<section id="christofides-algorithm-1.5-approximation" class="level3" data-number="9.5.4">
<h3 data-number="9.5.4" class="anchored" data-anchor-id="christofides-algorithm-1.5-approximation"><span class="header-section-number">9.5.4</span> Christofides Algorithm: 1.5-Approximation</h3>
<p>We can do better with a clever trick!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> christofides_tsp(graph):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">    1.5-approximation for metric TSP.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Algorithm:</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">    1. Find MST</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">    2. Find odd-degree vertices in MST</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co">    3. Find minimum weight perfect matching on odd vertices</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="co">    4. Combine MST + matching to get Eulerian graph</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="co">    5. Find Eulerian tour</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co">    6. Convert to Hamiltonian tour</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Time: O(V³)</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Approximation ratio: 1.5</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_odd_degree_vertices(mst):</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Find vertices with odd degree in MST."""</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        degree <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(mst)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(mst)):</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>            degree[u] <span class="op">=</span> <span class="bu">len</span>(mst[u])</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [v <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(mst)) <span class="cf">if</span> degree[v] <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span>]</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> min_weight_matching(graph, vertices):</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a><span class="co">        Find minimum weight perfect matching.</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="co">        Simplified version - in practice use Blossom algorithm.</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> vertices:</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> []</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Greedy matching (not optimal but demonstrates idea)</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>        matching <span class="op">=</span> []</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>        used <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>        vertices_copy <span class="op">=</span> vertices.copy()</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="bu">len</span>(vertices_copy) <span class="op">&gt;</span> <span class="dv">1</span>:</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>            min_weight <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>            min_pair <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(vertices_copy)):</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i<span class="op">+</span><span class="dv">1</span>, <span class="bu">len</span>(vertices_copy)):</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>                    u, v <span class="op">=</span> vertices_copy[i], vertices_copy[j]</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> graph[u][v] <span class="op">&lt;</span> min_weight:</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>                        min_weight <span class="op">=</span> graph[u][v]</span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>                        min_pair <span class="op">=</span> (i, j)</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>            i, j <span class="op">=</span> min_pair</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>            u, v <span class="op">=</span> vertices_copy[i], vertices_copy[j]</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>            matching.append((u, v))</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Remove matched vertices</span></span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>            vertices_copy <span class="op">=</span> [vertices_copy[k] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(vertices_copy)) </span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">if</span> k <span class="op">!=</span> i <span class="kw">and</span> k <span class="op">!=</span> j]</span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> matching</span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> find_eulerian_tour(graph):</span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Find Eulerian tour in graph with all even degrees."""</span></span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Hierholzer's algorithm</span></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>        tour <span class="op">=</span> []</span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>        stack <span class="op">=</span> [<span class="dv">0</span>]</span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>        graph_copy <span class="op">=</span> [edges.copy() <span class="cf">for</span> edges <span class="kw">in</span> graph]</span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> stack:</span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a>            v <span class="op">=</span> stack[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> graph_copy[v]:</span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>                u <span class="op">=</span> graph_copy[v].pop()</span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>                graph_copy[u].remove(v)</span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>                stack.append(u)</span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a>                tour.append(stack.pop())</span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> tour[::<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Find MST</span></span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a>    mst <span class="op">=</span> find_mst(graph)</span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Find odd degree vertices</span></span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>    odd_vertices <span class="op">=</span> find_odd_degree_vertices(mst)</span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Find minimum matching on odd vertices</span></span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>    matching <span class="op">=</span> min_weight_matching(graph, odd_vertices)</span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-86"><a href="#cb8-86" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 4: Combine MST and matching</span></span>
<span id="cb8-87"><a href="#cb8-87" aria-hidden="true" tabindex="-1"></a>    multigraph <span class="op">=</span> [edges.copy() <span class="cf">for</span> edges <span class="kw">in</span> mst]</span>
<span id="cb8-88"><a href="#cb8-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> matching:</span>
<span id="cb8-89"><a href="#cb8-89" aria-hidden="true" tabindex="-1"></a>        multigraph[u].append(v)</span>
<span id="cb8-90"><a href="#cb8-90" aria-hidden="true" tabindex="-1"></a>        multigraph[v].append(u)</span>
<span id="cb8-91"><a href="#cb8-91" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-92"><a href="#cb8-92" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 5: Find Eulerian tour</span></span>
<span id="cb8-93"><a href="#cb8-93" aria-hidden="true" tabindex="-1"></a>    eulerian <span class="op">=</span> find_eulerian_tour(multigraph)</span>
<span id="cb8-94"><a href="#cb8-94" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-95"><a href="#cb8-95" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 6: Convert to Hamiltonian (skip repeated vertices)</span></span>
<span id="cb8-96"><a href="#cb8-96" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb8-97"><a href="#cb8-97" aria-hidden="true" tabindex="-1"></a>    tour <span class="op">=</span> []</span>
<span id="cb8-98"><a href="#cb8-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> eulerian:</span>
<span id="cb8-99"><a href="#cb8-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> visited:</span>
<span id="cb8-100"><a href="#cb8-100" aria-hidden="true" tabindex="-1"></a>            tour.append(v)</span>
<span id="cb8-101"><a href="#cb8-101" aria-hidden="true" tabindex="-1"></a>            visited.add(v)</span>
<span id="cb8-102"><a href="#cb8-102" aria-hidden="true" tabindex="-1"></a>    tour.append(tour[<span class="dv">0</span>])  <span class="co"># Return to start</span></span>
<span id="cb8-103"><a href="#cb8-103" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-104"><a href="#cb8-104" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tour</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why 1.5-Approximation?</strong></p>
<ol type="1">
<li>MST weight ≤ OPT (as before)</li>
<li>Matching weight ≤ OPT/2 (clever argument using optimal tour on odd vertices)</li>
<li>Eulerian tour = MST + matching ≤ 1.5 × OPT</li>
<li>Shortcuts only improve, so final tour ≤ 1.5 × OPT ✓</li>
</ol>
<hr>
</section>
</section>
<section id="section-8.4-set-cover-and-greedy-algorithms" class="level2" data-number="9.6">
<h2 data-number="9.6" class="anchored" data-anchor-id="section-8.4-set-cover-and-greedy-algorithms"><span class="header-section-number">9.6</span> Section 8.4: Set Cover and Greedy Algorithms</h2>
<section id="the-set-cover-problem" class="level3" data-number="9.6.1">
<h3 data-number="9.6.1" class="anchored" data-anchor-id="the-set-cover-problem"><span class="header-section-number">9.6.1</span> The Set Cover Problem</h3>
<p><strong>Problem:</strong> Given a universe of elements and collection of sets, find minimum number of sets that cover all elements.</p>
<p><strong>Real-World Applications:</strong> - Sensor placement (cover all areas) - Feature selection in ML (cover all data characteristics) - Committee formation (cover all skills)</p>
</section>
<section id="the-greedy-algorithm" class="level3" data-number="9.6.2">
<h3 data-number="9.6.2" class="anchored" data-anchor-id="the-greedy-algorithm"><span class="header-section-number">9.6.2</span> The Greedy Algorithm</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> set_cover_greedy(universe, sets):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Greedy approximation for Set Cover.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Algorithm: Repeatedly pick set covering most uncovered elements.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Time: O(|universe| × |sets| × |largest set|)</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Approximation ratio: ln(|universe|) + 1</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    covered <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    cover <span class="op">=</span> []</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    sets_copy <span class="op">=</span> [<span class="bu">set</span>(s) <span class="cf">for</span> s <span class="kw">in</span> sets]  <span class="co"># Copy to avoid modifying</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> covered <span class="op">!=</span> universe:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find set covering most uncovered elements</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        best_set_idx <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        best_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, s <span class="kw">in</span> <span class="bu">enumerate</span>(sets_copy):</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            uncovered_count <span class="op">=</span> <span class="bu">len</span>(s <span class="op">-</span> covered)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> uncovered_count <span class="op">&gt;</span> best_count:</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>                best_count <span class="op">=</span> uncovered_count</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>                best_set_idx <span class="op">=</span> i</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> best_set_idx <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span>  <span class="co"># Cannot cover universe</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add best set to cover</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>        cover.append(best_set_idx)</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>        covered.update(sets_copy[best_set_idx])</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cover</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: Skill coverage for team formation</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>universe <span class="op">=</span> <span class="bu">set</span>(<span class="bu">range</span>(<span class="dv">10</span>))  <span class="co"># Skills 0-9</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>sets <span class="op">=</span> [</span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    {<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>},      <span class="co"># Person A's skills</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    {<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>},   <span class="co"># Person B's skills</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>    {<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>},   <span class="co"># Person C's skills</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    {<span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">9</span>},   <span class="co"># Person D's skills</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    {<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>} <span class="co"># Person E's skills</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>cover <span class="op">=</span> set_cover_greedy(universe, sets)</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Selected sets: </span><span class="sc">{</span>cover<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of sets: </span><span class="sc">{</span><span class="bu">len</span>(cover)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Might output: [1, 4, 3] (persons B, E, D)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="why-lnn-approximation" class="level3" data-number="9.6.3">
<h3 data-number="9.6.3" class="anchored" data-anchor-id="why-lnn-approximation"><span class="header-section-number">9.6.3</span> Why ln(n) Approximation?</h3>
<p><strong>The Analysis (Intuitive):</strong></p>
<ol type="1">
<li><strong>Each iteration covers significant fraction</strong>
<ul>
<li>If k sets remain in optimal solution</li>
<li>Some set must cover ≥ |uncovered|/k elements</li>
<li>Greedy picks set covering at least this many</li>
</ul></li>
<li><strong>Uncovered elements decrease geometrically</strong>
<ul>
<li>After t iterations, uncovered ≤ n × (1 - 1/OPT)^t</li>
<li>This shrinks like e^(-t/OPT)</li>
</ul></li>
<li><strong>Total iterations needed</strong>
<ul>
<li>About OPT × ln(n) iterations</li>
<li>Each iteration adds one set</li>
<li>Total: O(OPT × ln(n)) sets</li>
</ul></li>
</ol>
</section>
<section id="the-weighted-version" class="level3" data-number="9.6.4">
<h3 data-number="9.6.4" class="anchored" data-anchor-id="the-weighted-version"><span class="header-section-number">9.6.4</span> The Weighted Version</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> weighted_set_cover_greedy(universe, sets, weights):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Greedy approximation for Weighted Set Cover.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Algorithm: Pick set with best cost/benefit ratio.</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Approximation ratio: ln(|universe|) + 1</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    covered <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    cover <span class="op">=</span> []</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    total_cost <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> covered <span class="op">!=</span> universe:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        best_ratio <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        best_idx <span class="op">=</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, s <span class="kw">in</span> <span class="bu">enumerate</span>(sets):</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            uncovered <span class="op">=</span> s <span class="op">-</span> covered</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> uncovered:</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                ratio <span class="op">=</span> weights[i] <span class="op">/</span> <span class="bu">len</span>(uncovered)</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> ratio <span class="op">&lt;</span> best_ratio:</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>                    best_ratio <span class="op">=</span> ratio</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>                    best_idx <span class="op">=</span> i</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> best_idx <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span>, <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        cover.append(best_idx)</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        covered.update(sets[best_idx])</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>        total_cost <span class="op">+=</span> weights[best_idx]</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cover, total_cost</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Example: Minimize cost of skill coverage</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">150</span>, <span class="dv">200</span>, <span class="dv">180</span>, <span class="dv">160</span>]  <span class="co"># Salaries</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>cover, cost <span class="op">=</span> weighted_set_cover_greedy(universe, sets, weights)</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Selected people: </span><span class="sc">{</span>cover<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Total cost: $</span><span class="sc">{</span>cost<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="when-greedy-is-optimal-matroids" class="level3" data-number="9.6.5">
<h3 data-number="9.6.5" class="anchored" data-anchor-id="when-greedy-is-optimal-matroids"><span class="header-section-number">9.6.5</span> When Greedy is Optimal: Matroids</h3>
<p>For some problems, greedy gives OPTIMAL solutions!</p>
<p><strong>Matroid Property:</strong> 1. Hereditary: Subsets of independent sets are independent 2. Exchange: Can always extend smaller independent set</p>
<p><strong>Examples where greedy is optimal:</strong> - Maximum weight spanning tree (Kruskal’s) - Finding maximum weight independent set in matroid - Task scheduling with deadlines</p>
<hr>
</section>
</section>
<section id="section-8.5-randomized-approximation" class="level2" data-number="9.7">
<h2 data-number="9.7" class="anchored" data-anchor-id="section-8.5-randomized-approximation"><span class="header-section-number">9.7</span> Section 8.5: Randomized Approximation</h2>
<section id="the-power-of-random-choices" class="level3" data-number="9.7.1">
<h3 data-number="9.7.1" class="anchored" data-anchor-id="the-power-of-random-choices"><span class="header-section-number">9.7.1</span> The Power of Random Choices</h3>
<p>Sometimes flipping coins gives great approximations!</p>
</section>
<section id="max-cut-a-simple-randomized-algorithm" class="level3" data-number="9.7.2">
<h3 data-number="9.7.2" class="anchored" data-anchor-id="max-cut-a-simple-randomized-algorithm"><span class="header-section-number">9.7.2</span> MAX-CUT: A Simple Randomized Algorithm</h3>
<p><strong>Problem:</strong> Partition vertices to maximize edges between partitions.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_cut_random(graph):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Randomized 0.5-approximation for MAX-CUT.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Algorithm: Randomly assign each vertex to partition A or B.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Expected approximation: 0.5</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Amazing fact: This trivial algorithm is hard to beat!</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    vertices <span class="op">=</span> <span class="bu">list</span>(graph.vertices)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    partition_A <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    partition_B <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Randomly partition vertices</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> vertices:</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> random.random() <span class="op">&lt;</span> <span class="fl">0.5</span>:</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            partition_A.add(v)</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>            partition_B.add(v)</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Count edges in cut</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    cut_size <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> graph.edges:</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (u <span class="kw">in</span> partition_A <span class="kw">and</span> v <span class="kw">in</span> partition_B) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>           (u <span class="kw">in</span> partition_B <span class="kw">and</span> v <span class="kw">in</span> partition_A):</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>            cut_size <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> partition_A, partition_B, cut_size</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_cut_derandomized(graph):</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span class="co">    Derandomized version using conditional expectation.</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="co">    Guaranteed 0.5-approximation (not just expected).</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>    vertices <span class="op">=</span> <span class="bu">list</span>(graph.vertices)</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>    partition_A <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    partition_B <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> vertices:</span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate expected cut size for each choice</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>        cut_if_A <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>        cut_if_B <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u, w <span class="kw">in</span> graph.edges:</span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v <span class="kw">in</span> [u, w]:</span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>                other <span class="op">=</span> w <span class="cf">if</span> u <span class="op">==</span> v <span class="cf">else</span> u</span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> other <span class="kw">in</span> partition_B:</span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>                    cut_if_A <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> other <span class="kw">in</span> partition_A:</span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>                    cut_if_B <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Other vertex not yet assigned</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a>                    cut_if_A <span class="op">+=</span> <span class="fl">0.5</span>  <span class="co"># Expected value</span></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>                    cut_if_B <span class="op">+=</span> <span class="fl">0.5</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Choose partition giving larger expected cut</span></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> cut_if_A <span class="op">&gt;=</span> cut_if_B:</span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>            partition_A.add(v)</span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>            partition_B.add(v)</span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Count actual cut size</span></span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>    cut_size <span class="op">=</span> <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> u, v <span class="kw">in</span> graph.edges </span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>                   <span class="cf">if</span> (u <span class="kw">in</span> partition_A) <span class="op">!=</span> (v <span class="kw">in</span> partition_A))</span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> partition_A, partition_B, cut_size</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why 0.5-Approximation?</strong></p>
<p>For each edge (u,v): - Probability u and v in different partitions = 0.5 - Expected edges in cut = 0.5 × |E| - Maximum possible cut ≤ |E| - Therefore: expected cut ≥ 0.5 × MAX-CUT ✓</p>
</section>
<section id="max-sat-randomized-rounding" class="level3" data-number="9.7.3">
<h3 data-number="9.7.3" class="anchored" data-anchor-id="max-sat-randomized-rounding"><span class="header-section-number">9.7.3</span> MAX-SAT: Randomized Rounding</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sat_random(clauses, num_vars):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Randomized approximation for MAX-SAT.</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">    For k-SAT (clauses of size k):</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Expected approximation: 1 - 1/2^k</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">    For 3-SAT: 7/8-approximation (87.5% of optimal!)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Random assignment</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    assignment <span class="op">=</span> [random.choice([<span class="va">True</span>, <span class="va">False</span>]) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_vars)]</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Count satisfied clauses</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    satisfied <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> clause <span class="kw">in</span> clauses:</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if at least one literal is true</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> var, is_positive <span class="kw">in</span> clause:</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> is_positive <span class="kw">and</span> assignment[var]:</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                satisfied <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> <span class="kw">not</span> is_positive <span class="kw">and</span> <span class="kw">not</span> assignment[var]:</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>                satisfied <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> assignment, satisfied</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sat_lp_rounding(clauses, num_vars):</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a><span class="co">    Better approximation using LP relaxation and randomized rounding.</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a><span class="co">    1. Solve LP relaxation (fractional assignment)</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a><span class="co">    2. Round probabilistically based on LP solution</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a><span class="co">    Approximation: 1 - 1/e ≈ 0.632 for general SAT</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For demonstration, using simple randomized rounding</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># In practice, solve actual LP</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pretend we solved LP and got fractional values</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>    lp_solution <span class="op">=</span> [random.random() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(num_vars)]</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Round probabilistically</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>    assignment <span class="op">=</span> [random.random() <span class="op">&lt;</span> prob <span class="cf">for</span> prob <span class="kw">in</span> lp_solution]</span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>    satisfied <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> clause <span class="kw">in</span> clauses:</span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> var, is_positive <span class="kw">in</span> clause:</span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> is_positive <span class="kw">and</span> assignment[var]:</span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>                satisfied <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb12-51"><a href="#cb12-51" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> <span class="kw">not</span> is_positive <span class="kw">and</span> <span class="kw">not</span> assignment[var]:</span>
<span id="cb12-52"><a href="#cb12-52" aria-hidden="true" tabindex="-1"></a>                satisfied <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-53"><a href="#cb12-53" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb12-54"><a href="#cb12-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-55"><a href="#cb12-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> assignment, satisfied</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="the-method-of-conditional-expectations" class="level3" data-number="9.7.4">
<h3 data-number="9.7.4" class="anchored" data-anchor-id="the-method-of-conditional-expectations"><span class="header-section-number">9.7.4</span> The Method of Conditional Expectations</h3>
<p>We can derandomize many randomized algorithms!</p>
<p><strong>The Idea:</strong> 1. Instead of random choices, make greedy choices 2. At each step, choose option maximizing expected outcome 3. Final result at least as good as expected value of randomized algorithm</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> derandomize_vertex_cover(graph):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Derandomize the randomized 2-approximation for Vertex Cover.</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Original: Include each vertex with probability 0.5</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Derandomized: Include vertex if it improves expected coverage</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    vertices <span class="op">=</span> <span class="bu">list</span>(graph.vertices)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    cover <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> vertices:</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate expected uncovered edges for each choice</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        uncovered_if_include <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        uncovered_if_exclude <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u, w <span class="kw">in</span> graph.edges:</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v <span class="kw">not</span> <span class="kw">in</span> [u, w]:</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Edge doesn't involve v</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> cover <span class="kw">and</span> w <span class="kw">not</span> <span class="kw">in</span> cover:</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Currently uncovered</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>                    uncovered_if_include <span class="op">+=</span> <span class="fl">0.25</span>  <span class="co"># Prob both excluded later</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>                    uncovered_if_exclude <span class="op">+=</span> <span class="fl">0.25</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> v <span class="op">==</span> u <span class="kw">or</span> v <span class="op">==</span> w:</span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>                other <span class="op">=</span> w <span class="cf">if</span> v <span class="op">==</span> u <span class="cf">else</span> u</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> other <span class="kw">in</span> cover:</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Already covered</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">pass</span></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> other <span class="kw">in</span> vertices[vertices.index(v)<span class="op">+</span><span class="dv">1</span>:]:</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># Other vertex not yet decided</span></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>                    uncovered_if_exclude <span class="op">+=</span> <span class="fl">0.5</span>  <span class="co"># Prob other excluded</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># uncovered_if_include = 0 (edge covered by v)</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Choose option with fewer expected uncovered edges</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> uncovered_if_include <span class="op">&lt;=</span> uncovered_if_exclude:</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a>            cover.add(v)</span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cover</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
</section>
</section>
<section id="section-8.6-linear-programming-relaxation" class="level2" data-number="9.8">
<h2 data-number="9.8" class="anchored" data-anchor-id="section-8.6-linear-programming-relaxation"><span class="header-section-number">9.8</span> Section 8.6: Linear Programming Relaxation</h2>
<section id="the-power-of-relaxation" class="level3" data-number="9.8.1">
<h3 data-number="9.8.1" class="anchored" data-anchor-id="the-power-of-relaxation"><span class="header-section-number">9.8.1</span> The Power of Relaxation</h3>
<p>Many discrete optimization problems become easy when we relax integrality constraints!</p>
</section>
<section id="vertex-cover-via-lp-relaxation" class="level3" data-number="9.8.2">
<h3 data-number="9.8.2" class="anchored" data-anchor-id="vertex-cover-via-lp-relaxation"><span class="header-section-number">9.8.2</span> Vertex Cover via LP Relaxation</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vertex_cover_lp_relaxation(graph):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">    LP relaxation approach for Vertex Cover.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">    1. Formulate as Integer Linear Program (ILP)</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">    2. Relax to Linear Program (LP)</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">    3. Solve LP (polynomial time)</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">    4. Round fractional solution</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Approximation ratio: 2</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ILP formulation:</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Minimize: Σ x_v</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Subject to: x_u + x_v ≥ 1 for each edge (u,v)</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">#            x_v ∈ {0,1} for each vertex v</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># LP relaxation:</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Same but x_v ∈ [0,1]</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For demonstration, using simple heuristic</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># In practice, use LP solver like scipy.optimize.linprog</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simple fractional solution: x_v = 0.5 for all v</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This satisfies all constraints!</span></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Deterministic rounding: include if x_v ≥ 0.5</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    cover <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> graph.vertices:</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">True</span>:  <span class="co"># In real implementation: if lp_solution[v] &gt;= 0.5</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>            cover.add(v)</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cover</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> vertex_cover_primal_dual(graph):</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span class="co">    Primal-Dual approach for Vertex Cover.</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a><span class="co">    Provides both solution and certificate of optimality.</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>    cover <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>    dual_values <span class="op">=</span> {}  <span class="co"># Dual variable for each edge</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> graph.edges:</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> u <span class="kw">not</span> <span class="kw">in</span> cover <span class="kw">and</span> v <span class="kw">not</span> <span class="kw">in</span> cover:</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Increase dual variable for this edge</span></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>            dual_values[(u, v)] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Add vertices when dual constraint tight</span></span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a>            u_dual_sum <span class="op">=</span> <span class="bu">sum</span>(val <span class="cf">for</span> edge, val <span class="kw">in</span> dual_values.items() </span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a>                           <span class="cf">if</span> u <span class="kw">in</span> edge)</span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a>            v_dual_sum <span class="op">=</span> <span class="bu">sum</span>(val <span class="cf">for</span> edge, val <span class="kw">in</span> dual_values.items() </span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>                           <span class="cf">if</span> v <span class="kw">in</span> edge)</span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> u_dual_sum <span class="op">&gt;=</span> <span class="dv">1</span>:</span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>                cover.add(u)</span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> v_dual_sum <span class="op">&gt;=</span> <span class="dv">1</span>:</span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a>                cover.add(v)</span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cover</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="set-cover-via-lp-relaxation" class="level3" data-number="9.8.3">
<h3 data-number="9.8.3" class="anchored" data-anchor-id="set-cover-via-lp-relaxation"><span class="header-section-number">9.8.3</span> Set Cover via LP Relaxation</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> linprog</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> set_cover_lp(universe, sets, weights<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="co">    LP relaxation for Weighted Set Cover.</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Better than ln(n) approximation in practice!</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    n_sets <span class="op">=</span> <span class="bu">len</span>(sets)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    n_elements <span class="op">=</span> <span class="bu">len</span>(universe)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> weights <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        weights <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n_sets</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create constraint matrix</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># A[i][j] = 1 if element i is in set j</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> np.zeros((n_elements, n_sets))</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j, s <span class="kw">in</span> <span class="bu">enumerate</span>(sets):</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, elem <span class="kw">in</span> <span class="bu">enumerate</span>(universe):</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> elem <span class="kw">in</span> s:</span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>                A[i][j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Solve LP: minimize c^T x subject to Ax &gt;= 1, 0 &lt;= x &lt;= 1</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> linprog(</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>        c<span class="op">=</span>weights,</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>        A_ub<span class="op">=-</span>A,  <span class="co"># Convert to &lt;=</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>        b_ub<span class="op">=-</span>np.ones(n_elements),</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>        bounds<span class="op">=</span>[(<span class="dv">0</span>, <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n_sets)],</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>        method<span class="op">=</span><span class="st">'highs'</span></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> result.success:</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Round fractional solution</span></span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Strategy 1: Include if x_i &gt;= 1/f where f is max frequency</span></span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>    max_frequency <span class="op">=</span> <span class="bu">max</span>(<span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> s <span class="kw">in</span> sets <span class="cf">if</span> elem <span class="kw">in</span> s) </span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> elem <span class="kw">in</span> universe)</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>    threshold <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> max_frequency</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>    cover <span class="op">=</span> [i <span class="cf">for</span> i, x <span class="kw">in</span> <span class="bu">enumerate</span>(result.x) <span class="cf">if</span> x <span class="op">&gt;=</span> threshold]</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cover</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="the-integrality-gap" class="level3" data-number="9.8.4">
<h3 data-number="9.8.4" class="anchored" data-anchor-id="the-integrality-gap"><span class="header-section-number">9.8.4</span> The Integrality Gap</h3>
<p>The <strong>integrality gap</strong> measures how much we lose by relaxing:</p>
<pre><code>Integrality Gap = (Worst integer solution) / (Best fractional solution)</code></pre>
<p><strong>Examples:</strong> - Vertex Cover: Gap = 2 - Set Cover: Gap = ln(n) - TSP: Gap can be arbitrarily large!</p>
<p>Understanding the gap helps us know how well LP relaxation can work.</p>
<hr>
</section>
</section>
<section id="section-8.7-approximation-schemes" class="level2" data-number="9.9">
<h2 data-number="9.9" class="anchored" data-anchor-id="section-8.7-approximation-schemes"><span class="header-section-number">9.9</span> Section 8.7: Approximation Schemes</h2>
<section id="ptas-polynomial-time-approximation-scheme" class="level3" data-number="9.9.1">
<h3 data-number="9.9.1" class="anchored" data-anchor-id="ptas-polynomial-time-approximation-scheme"><span class="header-section-number">9.9.1</span> PTAS: Polynomial Time Approximation Scheme</h3>
<p>Get arbitrarily close to optimal, trading time for accuracy!</p>
</section>
<section id="knapsack-a-classic-fptas" class="level3" data-number="9.9.2">
<h3 data-number="9.9.2" class="anchored" data-anchor-id="knapsack-a-classic-fptas"><span class="header-section-number">9.9.2</span> Knapsack: A Classic FPTAS</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> knapsack_fptas(weights, values, capacity, epsilon<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">    FPTAS for 0/1 Knapsack.</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Achieves (1 + epsilon) approximation in time O(n³/epsilon).</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Algorithm:</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">    1. Scale down values</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co">    2. Solve scaled problem exactly with DP</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="co">    3. Solution is approximately optimal for original</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(weights)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find scaling factor</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    max_value <span class="op">=</span> <span class="bu">max</span>(values)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    K <span class="op">=</span> epsilon <span class="op">*</span> max_value <span class="op">/</span> n</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scale values</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    scaled_values <span class="op">=</span> [<span class="bu">int</span>(v <span class="op">/</span> K) <span class="cf">for</span> v <span class="kw">in</span> values]</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># DP on scaled problem</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    max_scaled_value <span class="op">=</span> <span class="bu">sum</span>(scaled_values)</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>] <span class="op">*</span> (max_scaled_value <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(capacity <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Traverse in reverse to avoid using item multiple times</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(capacity, weights[i] <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(max_scaled_value <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dp[w <span class="op">-</span> weights[i]][v]:</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>                    dp[w][v <span class="op">+</span> scaled_values[i]] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find maximum achievable value</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>    max_achieved <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(max_scaled_value <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(capacity <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dp[w][v]:</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>                max_achieved <span class="op">=</span> <span class="bu">max</span>(max_achieved, v)</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reconstruct solution</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>    current_weight <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>    current_value <span class="op">=</span> max_achieved</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a>    selected <span class="op">=</span> []</span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current_weight <span class="op">+</span> weights[i] <span class="op">&lt;=</span> capacity <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>           current_value <span class="op">&gt;=</span> scaled_values[i] <span class="kw">and</span> <span class="op">\</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>           dp[current_weight <span class="op">+</span> weights[i]][current_value <span class="op">-</span> scaled_values[i]]:</span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a>            selected.append(i)</span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>            current_weight <span class="op">+=</span> weights[i]</span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>            current_value <span class="op">-=</span> scaled_values[i]</span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate actual value</span></span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a>    actual_value <span class="op">=</span> <span class="bu">sum</span>(values[i] <span class="cf">for</span> i <span class="kw">in</span> selected)</span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> selected, actual_value</span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>, <span class="dv">40</span>]</span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> [<span class="dv">60</span>, <span class="dv">100</span>, <span class="dv">120</span>, <span class="dv">240</span>]</span>
<span id="cb17-61"><a href="#cb17-61" aria-hidden="true" tabindex="-1"></a>capacity <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb17-62"><a href="#cb17-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-63"><a href="#cb17-63" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epsilon <span class="kw">in</span> [<span class="fl">0.5</span>, <span class="fl">0.1</span>, <span class="fl">0.01</span>]:</span>
<span id="cb17-64"><a href="#cb17-64" aria-hidden="true" tabindex="-1"></a>    items, value <span class="op">=</span> knapsack_fptas(weights, values, capacity, epsilon)</span>
<span id="cb17-65"><a href="#cb17-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"ε=</span><span class="sc">{</span>epsilon<span class="sc">}</span><span class="ss">: Value=</span><span class="sc">{</span>value<span class="sc">}</span><span class="ss">, Items=</span><span class="sc">{</span>items<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why This Works:</strong></p>
<ol type="1">
<li><strong>Scaling preserves relative order</strong> (mostly)</li>
<li><strong>Error per item ≤ K</strong></li>
<li><strong>Total error ≤ n × K = ε × max_value</strong></li>
<li><strong>Approximation ratio ≤ (1 + ε)</strong></li>
</ol>
</section>
<section id="euclidean-tsp-a-ptas" class="level3" data-number="9.9.3">
<h3 data-number="9.9.3" class="anchored" data-anchor-id="euclidean-tsp-a-ptas"><span class="header-section-number">9.9.3</span> Euclidean TSP: A PTAS</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euclidean_tsp_ptas(points, epsilon<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">    PTAS for Euclidean TSP using geometric decomposition.</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Simplified version of Arora's algorithm.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Time: O(n × (log n)^(O(1/epsilon)))</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> divide_and_conquer(points, depth, max_depth):</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co">        Recursively partition plane and solve subproblems.</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(points) <span class="op">&lt;=</span> <span class="dv">3</span> <span class="kw">or</span> depth <span class="op">&gt;=</span> max_depth:</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Base case: solve small instance exactly</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> tsp_exact_small(points)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Partition into quadrants</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        mid_x <span class="op">=</span> <span class="bu">sorted</span>(p[<span class="dv">0</span>] <span class="cf">for</span> p <span class="kw">in</span> points)[<span class="bu">len</span>(points)<span class="op">//</span><span class="dv">2</span>]</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>        mid_y <span class="op">=</span> <span class="bu">sorted</span>(p[<span class="dv">1</span>] <span class="cf">for</span> p <span class="kw">in</span> points)[<span class="bu">len</span>(points)<span class="op">//</span><span class="dv">2</span>]</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>        quadrants <span class="op">=</span> [[], [], [], []]</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> p <span class="kw">in</span> points:</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p[<span class="dv">0</span>] <span class="op">&lt;=</span> mid_x <span class="kw">and</span> p[<span class="dv">1</span>] <span class="op">&lt;=</span> mid_y:</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>                quadrants[<span class="dv">0</span>].append(p)</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> p[<span class="dv">0</span>] <span class="op">&gt;</span> mid_x <span class="kw">and</span> p[<span class="dv">1</span>] <span class="op">&lt;=</span> mid_y:</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>                quadrants[<span class="dv">1</span>].append(p)</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> p[<span class="dv">0</span>] <span class="op">&lt;=</span> mid_x <span class="kw">and</span> p[<span class="dv">1</span>] <span class="op">&gt;</span> mid_y:</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>                quadrants[<span class="dv">2</span>].append(p)</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>                quadrants[<span class="dv">3</span>].append(p)</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Solve each quadrant</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>        tours <span class="op">=</span> []</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> quad <span class="kw">in</span> quadrants:</span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> quad:</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>                tours.append(divide_and_conquer(quad, depth <span class="op">+</span> <span class="dv">1</span>, max_depth))</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Combine tours (simplified - real algorithm is complex)</span></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> combine_tours(tours)</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set recursion depth based on epsilon</span></span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>    max_depth <span class="op">=</span> <span class="bu">int</span>(<span class="dv">1</span> <span class="op">/</span> epsilon)</span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> divide_and_conquer(points, <span class="dv">0</span>, max_depth)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="when-ptas-exists" class="level3" data-number="9.9.4">
<h3 data-number="9.9.4" class="anchored" data-anchor-id="when-ptas-exists"><span class="header-section-number">9.9.4</span> When PTAS Exists</h3>
<p>Problems admitting PTAS often have: 1. <strong>Geometric structure</strong> (Euclidean space) 2. <strong>Bounded treewidth</strong> (planar graphs) 3. <strong>Fixed parameter</strong> (k-center for fixed k)</p>
<p>Problems usually NOT admitting PTAS: 1. <strong>General graphs</strong> (no structure) 2. <strong>Strong NP-hard problems</strong> (unless P = NP) 3. <strong>Problems with large integrality gaps</strong></p>
<hr>
</section>
</section>
<section id="section-8.8-hardness-of-approximation" class="level2" data-number="9.10">
<h2 data-number="9.10" class="anchored" data-anchor-id="section-8.8-hardness-of-approximation"><span class="header-section-number">9.10</span> Section 8.8: Hardness of Approximation</h2>
<section id="some-problems-resist-approximation" class="level3" data-number="9.10.1">
<h3 data-number="9.10.1" class="anchored" data-anchor-id="some-problems-resist-approximation"><span class="header-section-number">9.10.1</span> Some Problems Resist Approximation</h3>
<p>Not all NP-hard problems can be approximated!</p>
</section>
<section id="inapproximability-results" class="level3" data-number="9.10.2">
<h3 data-number="9.10.2" class="anchored" data-anchor-id="inapproximability-results"><span class="header-section-number">9.10.2</span> Inapproximability Results</h3>
<div class="sourceCode" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> why_general_tsp_is_hard():</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Proof that general TSP cannot be approximated.</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    explanation <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="st">    Theorem: Unless P = NP, no polynomial-time algorithm can </span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="st">    approximate general TSP within ANY constant factor.</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="st">    Proof idea:</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="st">    1. Suppose we have α-approximation for TSP</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="st">    2. Given Hamiltonian Cycle instance G:</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="st">       - Create TSP instance with:</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="st">         * distance 1 for edges in G</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="st">         * distance α×n + 1 for non-edges</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="st">    3. If G has Hamiltonian cycle:</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="st">       - Optimal TSP = n</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="st">       - Algorithm returns ≤ α×n</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="st">    4. If G has no Hamiltonian cycle:</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="st">       - Optimal TSP &gt; α×n</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="st">       - Algorithm returns &gt; α×n</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="st">    5. We can decide Hamiltonian Cycle!</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a><span class="st">    6. But Hamiltonian Cycle is NP-complete</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a><span class="st">    7. Therefore, no such approximation exists</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="st">    """</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> explanation</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> gap_preserving_reductions():</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="co">    How we prove hardness of approximation.</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>    explanation <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a><span class="st">    Gap-Preserving Reduction:</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a><span class="st">    Transform problem A to problem B such that:</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a><span class="st">    - YES instance of A → OPT(B) ≥ c</span></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a><span class="st">    - NO instance of A → OPT(B) &lt; c/α</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a><span class="st">    This creates a "gap" that approximation must distinguish.</span></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a><span class="st">    Example: Proving MAX-3SAT is hard to approximate:</span></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a><span class="st">    1. Start with 3SAT (NP-complete)</span></span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a><span class="st">    2. Create MAX-3SAT instance</span></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a><span class="st">    3. Satisfiable → can satisfy all clauses</span></span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a><span class="st">    4. Unsatisfiable → can't satisfy &gt; 7/8 + ε fraction</span></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a><span class="st">    5. Gap of 1 vs 7/8 + ε</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a><span class="st">    6. So can't approximate better than 7/8 + ε</span></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a><span class="st">    """</span></span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> explanation</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="the-pcp-theorem" class="level3" data-number="9.10.3">
<h3 data-number="9.10.3" class="anchored" data-anchor-id="the-pcp-theorem"><span class="header-section-number">9.10.3</span> The PCP Theorem</h3>
<p>The most important result in hardness of approximation:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pcp_theorem():</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">    The PCP (Probabilistically Checkable Proofs) Theorem.</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    explanation <span class="op">=</span> <span class="st">"""</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="st">    PCP Theorem: NP = PCP(log n, 1)</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="st">    In English: </span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="st">    Every NP problem has proofs that can be verified by:</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="st">    - Reading only O(log n) random bits</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="st">    - Examining only O(1) bits of the proof</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="st">    - Accepting correct proofs with probability 1</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="st">    - Rejecting incorrect proofs with probability ≥ 1/2</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="st">    Implications:</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="st">    1. MAX-3SAT cannot be approximated better than 7/8</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="st">    2. MAX-CLIQUE cannot be approximated within n^ε</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="st">    3. Set Cover cannot be approximated better than ln n</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="st">    The PCP theorem revolutionized our understanding of approximation!</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="st">    """</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> explanation</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="apx-completeness" class="level3" data-number="9.10.4">
<h3 data-number="9.10.4" class="anchored" data-anchor-id="apx-completeness"><span class="header-section-number">9.10.4</span> APX-Completeness</h3>
<p>Some problems are “hardest to approximate”:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> APXComplete:</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Problems that are complete for APX (constant-factor approximable).</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    PROBLEMS <span class="op">=</span> [</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">"MAX-3SAT"</span>,</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Vertex Cover"</span>,</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">"MAX-CUT"</span>,</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Metric TSP"</span>,</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Bin Packing"</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> implications(<span class="va">self</span>):</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a><span class="co">        What APX-completeness means.</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"""</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="st">        If any APX-complete problem has a PTAS, then ALL do!</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="st">        </span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a><span class="st">        This is unlikely because:</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="st">        - Would imply PTAS for problems we've studied for decades</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="st">        - No progress despite enormous effort</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a><span class="st">        - Would collapse complexity classes</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="st">        </span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a><span class="st">        APX-complete = "Goldilocks zone" of approximation</span></span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a><span class="st">        - Not too easy (has PTAS)</span></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="st">        - Not too hard (no constant approximation)</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a><span class="st">        - Just right (constant factor, but no PTAS)</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a><span class="st">        """</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
</section>
</section>
<section id="chapter-8-practical-implementation-guide" class="level2" data-number="9.11">
<h2 data-number="9.11" class="anchored" data-anchor-id="chapter-8-practical-implementation-guide"><span class="header-section-number">9.11</span> Chapter 8: Practical Implementation Guide</h2>
<section id="a-complete-approximation-algorithm-toolkit" class="level3" data-number="9.11.1">
<h3 data-number="9.11.1" class="anchored" data-anchor-id="a-complete-approximation-algorithm-toolkit"><span class="header-section-number">9.11.1</span> A Complete Approximation Algorithm Toolkit</h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ApproximationToolkit:</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Ready-to-use approximation algorithms for common problems.</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.algorithms <span class="op">=</span> {</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>            <span class="st">'vertex_cover'</span>: {</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>                <span class="st">'simple'</span>: <span class="va">self</span>.vertex_cover_simple,</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>                <span class="st">'matching'</span>: <span class="va">self</span>.vertex_cover_matching,</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>                <span class="st">'lp'</span>: <span class="va">self</span>.vertex_cover_lp</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>            },</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>            <span class="st">'set_cover'</span>: {</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>                <span class="st">'greedy'</span>: <span class="va">self</span>.set_cover_greedy,</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>                <span class="st">'lp'</span>: <span class="va">self</span>.set_cover_lp</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>            },</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>            <span class="st">'tsp'</span>: {</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>                <span class="st">'mst'</span>: <span class="va">self</span>.tsp_mst,</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>                <span class="st">'christofides'</span>: <span class="va">self</span>.tsp_christofides</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>            },</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>            <span class="st">'max_cut'</span>: {</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>                <span class="st">'random'</span>: <span class="va">self</span>.max_cut_random,</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>                <span class="st">'sdp'</span>: <span class="va">self</span>.max_cut_sdp</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>            }</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve(<span class="va">self</span>, problem, instance, method<span class="op">=</span><span class="st">'best'</span>):</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a><span class="co">        Solve problem with specified or best method.</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> method <span class="op">==</span> <span class="st">'best'</span>:</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Choose based on instance characteristics</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>            method <span class="op">=</span> <span class="va">self</span>.choose_best_method(problem, instance)</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.algorithms[problem][method](instance)</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> choose_best_method(<span class="va">self</span>, problem, instance):</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a><span class="co">        Heuristic to choose best algorithm for instance.</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> problem <span class="op">==</span> <span class="st">'vertex_cover'</span>:</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use LP for dense graphs, matching for sparse</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>            density <span class="op">=</span> <span class="bu">len</span>(instance.edges) <span class="op">/</span> (<span class="bu">len</span>(instance.vertices) <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">'lp'</span> <span class="cf">if</span> density <span class="op">&gt;</span> <span class="fl">0.3</span> <span class="cf">else</span> <span class="st">'matching'</span></span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> problem <span class="op">==</span> <span class="st">'tsp'</span>:</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Use Christofides for metric TSP</span></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.is_metric(instance):</span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="st">'christofides'</span></span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="st">'mst'</span></span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Default choices</span></span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">list</span>(<span class="va">self</span>.algorithms[problem].keys())[<span class="dv">0</span>]</span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-55"><a href="#cb22-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> analyze_performance(<span class="va">self</span>, problem, instance, method):</span>
<span id="cb22-56"><a href="#cb22-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb22-57"><a href="#cb22-57" aria-hidden="true" tabindex="-1"></a><span class="co">        Analyze algorithm performance on instance.</span></span>
<span id="cb22-58"><a href="#cb22-58" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb22-59"><a href="#cb22-59" aria-hidden="true" tabindex="-1"></a>        <span class="im">import</span> time</span>
<span id="cb22-60"><a href="#cb22-60" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-61"><a href="#cb22-61" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> time.time()</span>
<span id="cb22-62"><a href="#cb22-62" aria-hidden="true" tabindex="-1"></a>        solution <span class="op">=</span> <span class="va">self</span>.solve(problem, instance, method)</span>
<span id="cb22-63"><a href="#cb22-63" aria-hidden="true" tabindex="-1"></a>        runtime <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb22-64"><a href="#cb22-64" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-65"><a href="#cb22-65" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calculate approximation ratio (if optimal known)</span></span>
<span id="cb22-66"><a href="#cb22-66" aria-hidden="true" tabindex="-1"></a>        ratio <span class="op">=</span> <span class="va">None</span></span>
<span id="cb22-67"><a href="#cb22-67" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">hasattr</span>(instance, <span class="st">'optimal'</span>):</span>
<span id="cb22-68"><a href="#cb22-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> problem <span class="kw">in</span> [<span class="st">'vertex_cover'</span>, <span class="st">'set_cover'</span>, <span class="st">'tsp'</span>]:</span>
<span id="cb22-69"><a href="#cb22-69" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Minimization</span></span>
<span id="cb22-70"><a href="#cb22-70" aria-hidden="true" tabindex="-1"></a>                ratio <span class="op">=</span> <span class="bu">len</span>(solution) <span class="op">/</span> instance.optimal</span>
<span id="cb22-71"><a href="#cb22-71" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb22-72"><a href="#cb22-72" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Maximization</span></span>
<span id="cb22-73"><a href="#cb22-73" aria-hidden="true" tabindex="-1"></a>                ratio <span class="op">=</span> instance.optimal <span class="op">/</span> <span class="bu">len</span>(solution)</span>
<span id="cb22-74"><a href="#cb22-74" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb22-75"><a href="#cb22-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> {</span>
<span id="cb22-76"><a href="#cb22-76" aria-hidden="true" tabindex="-1"></a>            <span class="st">'solution'</span>: solution,</span>
<span id="cb22-77"><a href="#cb22-77" aria-hidden="true" tabindex="-1"></a>            <span class="st">'runtime'</span>: runtime,</span>
<span id="cb22-78"><a href="#cb22-78" aria-hidden="true" tabindex="-1"></a>            <span class="st">'approximation_ratio'</span>: ratio,</span>
<span id="cb22-79"><a href="#cb22-79" aria-hidden="true" tabindex="-1"></a>            <span class="st">'theoretical_guarantee'</span>: <span class="va">self</span>.get_guarantee(problem, method)</span>
<span id="cb22-80"><a href="#cb22-80" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb22-81"><a href="#cb22-81" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-82"><a href="#cb22-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> get_guarantee(<span class="va">self</span>, problem, method):</span>
<span id="cb22-83"><a href="#cb22-83" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb22-84"><a href="#cb22-84" aria-hidden="true" tabindex="-1"></a><span class="co">        Return theoretical approximation guarantee.</span></span>
<span id="cb22-85"><a href="#cb22-85" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb22-86"><a href="#cb22-86" aria-hidden="true" tabindex="-1"></a>        guarantees <span class="op">=</span> {</span>
<span id="cb22-87"><a href="#cb22-87" aria-hidden="true" tabindex="-1"></a>            <span class="st">'vertex_cover'</span>: {<span class="st">'simple'</span>: <span class="dv">2</span>, <span class="st">'matching'</span>: <span class="dv">2</span>, <span class="st">'lp'</span>: <span class="dv">2</span>},</span>
<span id="cb22-88"><a href="#cb22-88" aria-hidden="true" tabindex="-1"></a>            <span class="st">'set_cover'</span>: {<span class="st">'greedy'</span>: <span class="st">'ln(n)'</span>, <span class="st">'lp'</span>: <span class="st">'f'</span>},</span>
<span id="cb22-89"><a href="#cb22-89" aria-hidden="true" tabindex="-1"></a>            <span class="st">'tsp'</span>: {<span class="st">'mst'</span>: <span class="dv">2</span>, <span class="st">'christofides'</span>: <span class="fl">1.5</span>},</span>
<span id="cb22-90"><a href="#cb22-90" aria-hidden="true" tabindex="-1"></a>            <span class="st">'max_cut'</span>: {<span class="st">'random'</span>: <span class="fl">0.5</span>, <span class="st">'sdp'</span>: <span class="fl">0.878</span>}</span>
<span id="cb22-91"><a href="#cb22-91" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb22-92"><a href="#cb22-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> guarantees.get(problem, {}).get(method, <span class="st">'Unknown'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
</section>
</section>
<section id="chapter-8-exercises" class="level2" data-number="9.12">
<h2 data-number="9.12" class="anchored" data-anchor-id="chapter-8-exercises"><span class="header-section-number">9.12</span> Chapter 8 Exercises</h2>
<section id="conceptual-understanding" class="level3" data-number="9.12.1">
<h3 data-number="9.12.1" class="anchored" data-anchor-id="conceptual-understanding"><span class="header-section-number">9.12.1</span> Conceptual Understanding</h3>
<p><strong>8.1 Approximation Ratios</strong> For each algorithm, determine its approximation ratio:</p>
<ol type="a">
<li>Always pick the largest available item for bin packing</li>
<li>Color vertices greedily with minimum available color</li>
<li>For MAX-SAT, set each variable to satisfy majority of its clauses</li>
<li>For facility location, open facility at each client location</li>
</ol>
<p><strong>8.2 Hardness of Approximation</strong> Prove that these problems are hard to approximate:</p>
<ol type="a">
<li>General TSP (any constant factor)</li>
<li>Graph coloring (within n^(1-ε))</li>
<li>Maximum independent set (within n^(1-ε))</li>
</ol>
<p><strong>8.3 Algorithm Design</strong> Design approximation algorithms for:</p>
<ol type="a">
<li>Minimum dominating set in graphs</li>
<li>Maximum weight matching</li>
<li>Minimum feedback vertex set</li>
<li>k-median clustering</li>
</ol>
</section>
<section id="implementation-problems" class="level3" data-number="9.12.2">
<h3 data-number="9.12.2" class="anchored" data-anchor-id="implementation-problems"><span class="header-section-number">9.12.2</span> Implementation Problems</h3>
<p><strong>8.4 Implement Core Algorithms</strong></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> implement_core_approximations():</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Implement these essential approximation algorithms."""</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> weighted_vertex_cover(graph, weights):</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""2-approximation for weighted vertex cover."""</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> max_3sat_random(formula):</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""7/8-approximation for MAX-3SAT."""</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> bin_packing_first_fit(items, bin_size):</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""First-fit algorithm for bin packing."""</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> k_center_greedy(points, k):</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""2-approximation for k-center clustering."""</span></span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>8.5 Advanced Techniques</strong></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> advanced_approximations():</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Implement advanced approximation techniques."""</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> primal_dual_set_cover(universe, sets):</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Primal-dual approach for set cover."""</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> sdp_max_cut(graph):</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""SDP relaxation for MAX-CUT."""</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> local_search_k_median(points, k):</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Local search (5+ε)-approximation."""</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="analysis-problems" class="level3" data-number="9.12.3">
<h3 data-number="9.12.3" class="anchored" data-anchor-id="analysis-problems"><span class="header-section-number">9.12.3</span> Analysis Problems</h3>
<p><strong>8.6 Prove Approximation Ratios</strong> Prove the approximation ratio for:</p>
<ol type="a">
<li>First-fit decreasing for bin packing (11/9 OPT + 6/9)</li>
<li>Greedy set cover (ln n + 1)</li>
<li>Random assignment for MAX-CUT (0.5)</li>
<li>MST-based TSP (2.0)</li>
</ol>
<p><strong>8.7 Compare Algorithms</strong> Experimentally compare:</p>
<ol type="a">
<li>Different vertex cover algorithms on random graphs</li>
<li>Greedy vs LP rounding for set cover</li>
<li>Various TSP approximations on Euclidean instances</li>
<li>Randomized vs deterministic MAX-CUT</li>
</ol>
<p><strong>8.8 Real-World Applications</strong> Apply approximation algorithms to:</p>
<ol type="a">
<li>Amazon delivery route optimization</li>
<li>Cell tower placement for coverage</li>
<li>Course scheduling minimizing conflicts</li>
<li>Data center task allocation</li>
</ol>
<hr>
</section>
</section>
<section id="chapter-8-summary" class="level2" data-number="9.13">
<h2 data-number="9.13" class="anchored" data-anchor-id="chapter-8-summary"><span class="header-section-number">9.13</span> Chapter 8 Summary</h2>
<section id="key-takeaways" class="level3" data-number="9.13.1">
<h3 data-number="9.13.1" class="anchored" data-anchor-id="key-takeaways"><span class="header-section-number">9.13.1</span> Key Takeaways</h3>
<ol type="1">
<li><strong>Approximation Guarantees Matter</strong>
<ul>
<li>Not just heuristics—provable quality bounds</li>
<li>Know exactly how far from optimal you might be</li>
<li>Different guarantees: constant, logarithmic, PTAS</li>
</ul></li>
<li><strong>Standard Techniques</strong>
<ul>
<li><strong>Greedy</strong>: Simple, often optimal for special structures</li>
<li><strong>LP Relaxation</strong>: Powerful, good bounds</li>
<li><strong>Randomization</strong>: Surprisingly effective</li>
<li><strong>Local Search</strong>: Practical, good empirical performance</li>
</ul></li>
<li><strong>Problem-Specific Insights</strong>
<ul>
<li>Vertex Cover: Any maximal matching gives 2-approx</li>
<li>TSP: Metric property enables approximation</li>
<li>Set Cover: Greedy is nearly optimal</li>
<li>MAX-CUT: Random is hard to beat!</li>
</ul></li>
<li><strong>Hardness Results</strong>
<ul>
<li>Some problems resist approximation</li>
<li>PCP theorem revolutionized the field</li>
<li>Knowing limits prevents wasted effort</li>
</ul></li>
<li><strong>Practical Considerations</strong>
<ul>
<li>Approximation algorithms used everywhere</li>
<li>Often perform better than worst-case guarantee</li>
<li>Can combine with heuristics for better results</li>
<li>Speed vs quality trade-off is controllable</li>
</ul></li>
</ol>
</section>
<section id="decision-framework" class="level3" data-number="9.13.2">
<h3 data-number="9.13.2" class="anchored" data-anchor-id="decision-framework"><span class="header-section-number">9.13.2</span> Decision Framework</h3>
<p>When facing an NP-hard optimization problem:</p>
<ol type="1">
<li><strong>Check for approximation algorithms</strong>
<ul>
<li>Look for existing results</li>
<li>Consider problem structure</li>
</ul></li>
<li><strong>Choose your approach</strong>
<ul>
<li>Need guarantee? → Approximation algorithm</li>
<li>Need speed? → Simple greedy</li>
<li>Need quality? → LP relaxation or PTAS</li>
<li>Instance-specific? → Heuristics</li>
</ul></li>
<li><strong>Implement and evaluate</strong>
<ul>
<li>Start simple (greedy)</li>
<li>Measure actual performance</li>
<li>Refine based on results</li>
</ul></li>
<li><strong>Know the limits</strong>
<ul>
<li>Check hardness results</li>
<li>Don’t seek impossible guarantees</li>
<li>Focus effort where it matters</li>
</ul></li>
</ol>
</section>
<section id="the-art-of-approximation" class="level3" data-number="9.13.3">
<h3 data-number="9.13.3" class="anchored" data-anchor-id="the-art-of-approximation"><span class="header-section-number">9.13.3</span> The Art of Approximation</h3>
<p>Approximation algorithms represent a beautiful compromise between theory and practice:</p>
<ul>
<li><strong>Theory</strong>: Rigorous guarantees, worst-case analysis</li>
<li><strong>Practice</strong>: Fast algorithms, good solutions</li>
<li><strong>Together</strong>: Practical algorithms with confidence</li>
</ul>
</section>
<section id="looking-forward" class="level3" data-number="9.13.4">
<h3 data-number="9.13.4" class="anchored" data-anchor-id="looking-forward"><span class="header-section-number">9.13.4</span> Looking Forward</h3>
<p>The field of approximation algorithms continues to evolve:</p>
<ul>
<li><strong>Improved bounds</strong> for classic problems</li>
<li><strong>New techniques</strong> (SDP, metric embeddings)</li>
<li><strong>Practical implementations</strong> beating guarantees</li>
<li><strong>Machine learning</strong> guiding algorithm choice</li>
</ul>
</section>
<section id="next-chapter-preview" class="level3" data-number="9.13.5">
<h3 data-number="9.13.5" class="anchored" data-anchor-id="next-chapter-preview"><span class="header-section-number">9.13.5</span> Next Chapter Preview</h3>
<p>In Chapter 9, we explore <strong>Advanced Graph Algorithms</strong>, where we’ll use our approximation techniques alongside exact algorithms to solve complex network problems!</p>
</section>
<section id="final-thought" class="level3" data-number="9.13.6">
<h3 data-number="9.13.6" class="anchored" data-anchor-id="final-thought"><span class="header-section-number">9.13.6</span> Final Thought</h3>
<p><em>“In the real world, a bird in the hand is worth two in the bush. In computer science, we can prove it’s worth at least half a bird in the bush—and that’s often good enough!”</em></p>
<p>Approximation algorithms teach us that perfection is not always necessary or even desirable. By accepting solutions that are provably close to optimal, we can solve problems that would otherwise be impossible. This is not giving up—it’s strategic compromise with mathematical backing.</p>
<p>Master approximation algorithms, and you’ll never be stuck waiting for the perfect solution when a great one is available now!</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/07-Computational-Complexity.html" class="pagination-link" aria-label="Chapter 7: Computational Complexity &amp; NP-Completeness - The Limits of Computing">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Chapter 7: Computational Complexity &amp; NP-Completeness - The Limits of Computing</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>