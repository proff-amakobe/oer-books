<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Advanced Algorithms: A Journey Through Computational Problem Solving – Advanced Computational Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/01-introduction.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-9b98f18118eee809be1c051eb5cc78e4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/02-Divide-and-Conquer.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Advanced Algorithms: A Journey Through Computational Problem Solving</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Advanced Computational Algorithms</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Advanced Computational Algorithms</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/01-introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Advanced Algorithms: A Journey Through Computational Problem Solving</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/02-Divide-and-Conquer.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Advanced Algorithms: A Journey Through Computational Problem Solving</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#chapter-2-divide-and-conquer---the-art-of-problem-decomposition" id="toc-chapter-2-divide-and-conquer---the-art-of-problem-decomposition" class="nav-link active" data-scroll-target="#chapter-2-divide-and-conquer---the-art-of-problem-decomposition"><span class="header-section-number">3.1</span> Chapter 2: Divide and Conquer - The Art of Problem Decomposition</a></li>
  <li><a href="#welcome-to-the-power-of-recursion" id="toc-welcome-to-the-power-of-recursion" class="nav-link" data-scroll-target="#welcome-to-the-power-of-recursion"><span class="header-section-number">3.2</span> Welcome to the Power of Recursion</a>
  <ul class="collapse">
  <li><a href="#why-this-matters" id="toc-why-this-matters" class="nav-link" data-scroll-target="#why-this-matters"><span class="header-section-number">3.2.1</span> Why This Matters</a></li>
  <li><a href="#what-youll-learn" id="toc-what-youll-learn" class="nav-link" data-scroll-target="#what-youll-learn"><span class="header-section-number">3.2.2</span> What You’ll Learn</a></li>
  <li><a href="#chapter-roadmap" id="toc-chapter-roadmap" class="nav-link" data-scroll-target="#chapter-roadmap"><span class="header-section-number">3.2.3</span> Chapter Roadmap</a></li>
  </ul></li>
  <li><a href="#section-2.1-the-divide-and-conquer-paradigm" id="toc-section-2.1-the-divide-and-conquer-paradigm" class="nav-link" data-scroll-target="#section-2.1-the-divide-and-conquer-paradigm"><span class="header-section-number">3.3</span> Section 2.1: The Divide and Conquer Paradigm</a>
  <ul class="collapse">
  <li><a href="#the-three-step-dance" id="toc-the-three-step-dance" class="nav-link" data-scroll-target="#the-three-step-dance"><span class="header-section-number">3.3.1</span> The Three-Step Dance</a></li>
  <li><a href="#real-world-analogy-organizing-a-tournament" id="toc-real-world-analogy-organizing-a-tournament" class="nav-link" data-scroll-target="#real-world-analogy-organizing-a-tournament"><span class="header-section-number">3.3.2</span> Real-World Analogy: Organizing a Tournament</a></li>
  <li><a href="#a-simple-example-finding-maximum-element" id="toc-a-simple-example-finding-maximum-element" class="nav-link" data-scroll-target="#a-simple-example-finding-maximum-element"><span class="header-section-number">3.3.3</span> A Simple Example: Finding Maximum Element</a></li>
  <li><a href="#when-does-divide-and-conquer-help" id="toc-when-does-divide-and-conquer-help" class="nav-link" data-scroll-target="#when-does-divide-and-conquer-help"><span class="header-section-number">3.3.4</span> When Does Divide and Conquer Help?</a></li>
  <li><a href="#the-recursion-tree-visualizing-divide-and-conquer" id="toc-the-recursion-tree-visualizing-divide-and-conquer" class="nav-link" data-scroll-target="#the-recursion-tree-visualizing-divide-and-conquer"><span class="header-section-number">3.3.5</span> The Recursion Tree: Visualizing Divide and Conquer</a></li>
  <li><a href="#designing-divide-and-conquer-algorithms-a-checklist" id="toc-designing-divide-and-conquer-algorithms-a-checklist" class="nav-link" data-scroll-target="#designing-divide-and-conquer-algorithms-a-checklist"><span class="header-section-number">3.3.6</span> Designing Divide and Conquer Algorithms: A Checklist</a></li>
  </ul></li>
  <li><a href="#section-2.2-merge-sort---guaranteed-on-log-n-performance" id="toc-section-2.2-merge-sort---guaranteed-on-log-n-performance" class="nav-link" data-scroll-target="#section-2.2-merge-sort---guaranteed-on-log-n-performance"><span class="header-section-number">3.4</span> Section 2.2: Merge Sort - Guaranteed O(n log n) Performance</a>
  <ul class="collapse">
  <li><a href="#the-sorting-challenge-revisited" id="toc-the-sorting-challenge-revisited" class="nav-link" data-scroll-target="#the-sorting-challenge-revisited"><span class="header-section-number">3.4.1</span> The Sorting Challenge Revisited</a></li>
  <li><a href="#the-merge-operation-the-secret-sauce" id="toc-the-merge-operation-the-secret-sauce" class="nav-link" data-scroll-target="#the-merge-operation-the-secret-sauce"><span class="header-section-number">3.4.2</span> The Merge Operation: The Secret Sauce</a></li>
  <li><a href="#the-complete-merge-sort-algorithm" id="toc-the-complete-merge-sort-algorithm" class="nav-link" data-scroll-target="#the-complete-merge-sort-algorithm"><span class="header-section-number">3.4.3</span> The Complete Merge Sort Algorithm</a></li>
  <li><a href="#correctness-proof-for-merge-sort" id="toc-correctness-proof-for-merge-sort" class="nav-link" data-scroll-target="#correctness-proof-for-merge-sort"><span class="header-section-number">3.4.4</span> Correctness Proof for Merge Sort</a></li>
  <li><a href="#time-complexity-analysis" id="toc-time-complexity-analysis" class="nav-link" data-scroll-target="#time-complexity-analysis"><span class="header-section-number">3.4.5</span> Time Complexity Analysis</a></li>
  <li><a href="#space-complexity-analysis" id="toc-space-complexity-analysis" class="nav-link" data-scroll-target="#space-complexity-analysis"><span class="header-section-number">3.4.6</span> Space Complexity Analysis</a></li>
  <li><a href="#merge-sort-properties" id="toc-merge-sort-properties" class="nav-link" data-scroll-target="#merge-sort-properties"><span class="header-section-number">3.4.7</span> Merge Sort Properties</a></li>
  <li><a href="#optimizing-merge-sort" id="toc-optimizing-merge-sort" class="nav-link" data-scroll-target="#optimizing-merge-sort"><span class="header-section-number">3.4.8</span> Optimizing Merge Sort</a></li>
  </ul></li>
  <li><a href="#section-2.3-quicksort---the-practical-champion" id="toc-section-2.3-quicksort---the-practical-champion" class="nav-link" data-scroll-target="#section-2.3-quicksort---the-practical-champion"><span class="header-section-number">3.5</span> Section 2.3: QuickSort - The Practical Champion</a>
  <ul class="collapse">
  <li><a href="#why-another-sorting-algorithm" id="toc-why-another-sorting-algorithm" class="nav-link" data-scroll-target="#why-another-sorting-algorithm"><span class="header-section-number">3.5.1</span> Why Another Sorting Algorithm?</a></li>
  <li><a href="#the-quicksort-idea" id="toc-the-quicksort-idea" class="nav-link" data-scroll-target="#the-quicksort-idea"><span class="header-section-number">3.5.2</span> The QuickSort Idea</a></li>
  <li><a href="#a-simple-example" id="toc-a-simple-example" class="nav-link" data-scroll-target="#a-simple-example"><span class="header-section-number">3.5.3</span> A Simple Example</a></li>
  <li><a href="#the-partition-operation" id="toc-the-partition-operation" class="nav-link" data-scroll-target="#the-partition-operation"><span class="header-section-number">3.5.4</span> The Partition Operation</a></li>
  <li><a href="#the-complete-quicksort-algorithm" id="toc-the-complete-quicksort-algorithm" class="nav-link" data-scroll-target="#the-complete-quicksort-algorithm"><span class="header-section-number">3.5.5</span> The Complete QuickSort Algorithm</a></li>
  <li><a href="#analysis-best-case-worst-case-average-case" id="toc-analysis-best-case-worst-case-average-case" class="nav-link" data-scroll-target="#analysis-best-case-worst-case-average-case"><span class="header-section-number">3.5.6</span> Analysis: Best Case, Worst Case, Average Case</a></li>
  <li><a href="#the-worst-case-problem-randomization-to-the-rescue" id="toc-the-worst-case-problem-randomization-to-the-rescue" class="nav-link" data-scroll-target="#the-worst-case-problem-randomization-to-the-rescue"><span class="header-section-number">3.5.7</span> The Worst Case Problem: Randomization to the Rescue!</a></li>
  <li><a href="#alternative-pivot-selection-strategies" id="toc-alternative-pivot-selection-strategies" class="nav-link" data-scroll-target="#alternative-pivot-selection-strategies"><span class="header-section-number">3.5.8</span> Alternative Pivot Selection Strategies</a></li>
  <li><a href="#quicksort-vs-merge-sort-the-showdown" id="toc-quicksort-vs-merge-sort-the-showdown" class="nav-link" data-scroll-target="#quicksort-vs-merge-sort-the-showdown"><span class="header-section-number">3.5.9</span> QuickSort vs Merge Sort: The Showdown</a></li>
  <li><a href="#optimizing-quicksort-for-production" id="toc-optimizing-quicksort-for-production" class="nav-link" data-scroll-target="#optimizing-quicksort-for-production"><span class="header-section-number">3.5.10</span> Optimizing QuickSort for Production</a></li>
  </ul></li>
  <li><a href="#section-2.4-recurrence-relations-and-the-master-theorem" id="toc-section-2.4-recurrence-relations-and-the-master-theorem" class="nav-link" data-scroll-target="#section-2.4-recurrence-relations-and-the-master-theorem"><span class="header-section-number">3.6</span> Section 2.4: Recurrence Relations and The Master Theorem</a>
  <ul class="collapse">
  <li><a href="#why-we-need-better-analysis-tools" id="toc-why-we-need-better-analysis-tools" class="nav-link" data-scroll-target="#why-we-need-better-analysis-tools"><span class="header-section-number">3.6.1</span> Why We Need Better Analysis Tools</a></li>
  <li><a href="#recurrence-relations-the-language-of-recursion" id="toc-recurrence-relations-the-language-of-recursion" class="nav-link" data-scroll-target="#recurrence-relations-the-language-of-recursion"><span class="header-section-number">3.6.2</span> Recurrence Relations: The Language of Recursion</a></li>
  <li><a href="#solving-recurrences-multiple-methods" id="toc-solving-recurrences-multiple-methods" class="nav-link" data-scroll-target="#solving-recurrences-multiple-methods"><span class="header-section-number">3.6.3</span> Solving Recurrences: Multiple Methods</a></li>
  <li><a href="#the-master-theorem" id="toc-the-master-theorem" class="nav-link" data-scroll-target="#the-master-theorem"><span class="header-section-number">3.6.4</span> The Master Theorem</a></li>
  <li><a href="#understanding-the-master-theorem-intuitively" id="toc-understanding-the-master-theorem-intuitively" class="nav-link" data-scroll-target="#understanding-the-master-theorem-intuitively"><span class="header-section-number">3.6.5</span> Understanding the Master Theorem Intuitively</a></li>
  <li><a href="#master-theorem-examples" id="toc-master-theorem-examples" class="nav-link" data-scroll-target="#master-theorem-examples"><span class="header-section-number">3.6.6</span> Master Theorem Examples</a></li>
  <li><a href="#when-master-theorem-doesnt-apply" id="toc-when-master-theorem-doesnt-apply" class="nav-link" data-scroll-target="#when-master-theorem-doesnt-apply"><span class="header-section-number">3.6.7</span> When Master Theorem Doesn’t Apply</a></li>
  <li><a href="#master-theorem-cheat-sheet" id="toc-master-theorem-cheat-sheet" class="nav-link" data-scroll-target="#master-theorem-cheat-sheet"><span class="header-section-number">3.6.8</span> Master Theorem Cheat Sheet</a></li>
  <li><a href="#practice-problems" id="toc-practice-problems" class="nav-link" data-scroll-target="#practice-problems"><span class="header-section-number">3.6.9</span> Practice Problems</a></li>
  <li><a href="#beyond-the-master-theorem-advanced-recurrence-solving" id="toc-beyond-the-master-theorem-advanced-recurrence-solving" class="nav-link" data-scroll-target="#beyond-the-master-theorem-advanced-recurrence-solving"><span class="header-section-number">3.6.10</span> Beyond the Master Theorem: Advanced Recurrence Solving</a></li>
  </ul></li>
  <li><a href="#section-2.5-advanced-applications-and-case-studies" id="toc-section-2.5-advanced-applications-and-case-studies" class="nav-link" data-scroll-target="#section-2.5-advanced-applications-and-case-studies"><span class="header-section-number">3.7</span> Section 2.5: Advanced Applications and Case Studies</a>
  <ul class="collapse">
  <li><a href="#beyond-sorting-where-divide-and-conquer-shines" id="toc-beyond-sorting-where-divide-and-conquer-shines" class="nav-link" data-scroll-target="#beyond-sorting-where-divide-and-conquer-shines"><span class="header-section-number">3.7.1</span> Beyond Sorting: Where Divide and Conquer Shines</a></li>
  <li><a href="#application-1-fast-integer-multiplication-karatsuba-algorithm" id="toc-application-1-fast-integer-multiplication-karatsuba-algorithm" class="nav-link" data-scroll-target="#application-1-fast-integer-multiplication-karatsuba-algorithm"><span class="header-section-number">3.7.2</span> Application 1: Fast Integer Multiplication (Karatsuba Algorithm)</a></li>
  <li><a href="#application-2-closest-pair-of-points" id="toc-application-2-closest-pair-of-points" class="nav-link" data-scroll-target="#application-2-closest-pair-of-points"><span class="header-section-number">3.7.3</span> Application 2: Closest Pair of Points</a></li>
  <li><a href="#application-3-matrix-multiplication-strassens-algorithm" id="toc-application-3-matrix-multiplication-strassens-algorithm" class="nav-link" data-scroll-target="#application-3-matrix-multiplication-strassens-algorithm"><span class="header-section-number">3.7.4</span> Application 3: Matrix Multiplication (Strassen’s Algorithm)</a></li>
  <li><a href="#application-4-fast-fourier-transform-fft" id="toc-application-4-fast-fourier-transform-fft" class="nav-link" data-scroll-target="#application-4-fast-fourier-transform-fft"><span class="header-section-number">3.7.5</span> Application 4: Fast Fourier Transform (FFT)</a></li>
  </ul></li>
  <li><a href="#section-2.6-implementation-and-optimization" id="toc-section-2.6-implementation-and-optimization" class="nav-link" data-scroll-target="#section-2.6-implementation-and-optimization"><span class="header-section-number">3.8</span> Section 2.6: Implementation and Optimization</a>
  <ul class="collapse">
  <li><a href="#building-a-production-quality-sorting-library" id="toc-building-a-production-quality-sorting-library" class="nav-link" data-scroll-target="#building-a-production-quality-sorting-library"><span class="header-section-number">3.8.1</span> Building a Production-Quality Sorting Library</a></li>
  <li><a href="#performance-benchmarking" id="toc-performance-benchmarking" class="nav-link" data-scroll-target="#performance-benchmarking"><span class="header-section-number">3.8.2</span> Performance Benchmarking</a></li>
  <li><a href="#real-world-performance-tips" id="toc-real-world-performance-tips" class="nav-link" data-scroll-target="#real-world-performance-tips"><span class="header-section-number">3.8.3</span> Real-World Performance Tips</a></li>
  <li><a href="#common-implementation-pitfalls" id="toc-common-implementation-pitfalls" class="nav-link" data-scroll-target="#common-implementation-pitfalls"><span class="header-section-number">3.8.4</span> Common Implementation Pitfalls</a></li>
  </ul></li>
  <li><a href="#section-2.7-advanced-topics-and-extensions" id="toc-section-2.7-advanced-topics-and-extensions" class="nav-link" data-scroll-target="#section-2.7-advanced-topics-and-extensions"><span class="header-section-number">3.9</span> Section 2.7: Advanced Topics and Extensions</a>
  <ul class="collapse">
  <li><a href="#parallel-divide-and-conquer" id="toc-parallel-divide-and-conquer" class="nav-link" data-scroll-target="#parallel-divide-and-conquer"><span class="header-section-number">3.9.1</span> Parallel Divide and Conquer</a></li>
  <li><a href="#cache-oblivious-algorithms" id="toc-cache-oblivious-algorithms" class="nav-link" data-scroll-target="#cache-oblivious-algorithms"><span class="header-section-number">3.9.2</span> Cache-Oblivious Algorithms</a></li>
  <li><a href="#external-memory-algorithms" id="toc-external-memory-algorithms" class="nav-link" data-scroll-target="#external-memory-algorithms"><span class="header-section-number">3.9.3</span> External Memory Algorithms</a></li>
  </ul></li>
  <li><a href="#chapter-summary-and-key-takeaways" id="toc-chapter-summary-and-key-takeaways" class="nav-link" data-scroll-target="#chapter-summary-and-key-takeaways"><span class="header-section-number">3.10</span> Chapter Summary and Key Takeaways</a>
  <ul class="collapse">
  <li><a href="#core-concepts-mastered" id="toc-core-concepts-mastered" class="nav-link" data-scroll-target="#core-concepts-mastered"><span class="header-section-number">3.10.1</span> Core Concepts Mastered</a></li>
  <li><a href="#performance-comparison-chart" id="toc-performance-comparison-chart" class="nav-link" data-scroll-target="#performance-comparison-chart"><span class="header-section-number">3.10.2</span> Performance Comparison Chart</a></li>
  <li><a href="#when-to-use-each-algorithm" id="toc-when-to-use-each-algorithm" class="nav-link" data-scroll-target="#when-to-use-each-algorithm"><span class="header-section-number">3.10.3</span> When to Use Each Algorithm</a></li>
  <li><a href="#common-mistakes-to-avoid" id="toc-common-mistakes-to-avoid" class="nav-link" data-scroll-target="#common-mistakes-to-avoid"><span class="header-section-number">3.10.4</span> Common Mistakes to Avoid</a></li>
  <li><a href="#key-insights-for-algorithm-design" id="toc-key-insights-for-algorithm-design" class="nav-link" data-scroll-target="#key-insights-for-algorithm-design"><span class="header-section-number">3.10.5</span> Key Insights for Algorithm Design</a></li>
  </ul></li>
  <li><a href="#looking-ahead-chapter-3-preview" id="toc-looking-ahead-chapter-3-preview" class="nav-link" data-scroll-target="#looking-ahead-chapter-3-preview"><span class="header-section-number">3.11</span> Looking Ahead: Chapter 3 Preview</a></li>
  <li><a href="#chapter-2-exercises" id="toc-chapter-2-exercises" class="nav-link" data-scroll-target="#chapter-2-exercises"><span class="header-section-number">3.12</span> Chapter 2 Exercises</a>
  <ul class="collapse">
  <li><a href="#theoretical-problems" id="toc-theoretical-problems" class="nav-link" data-scroll-target="#theoretical-problems"><span class="header-section-number">3.12.1</span> Theoretical Problems</a></li>
  <li><a href="#programming-problems" id="toc-programming-problems" class="nav-link" data-scroll-target="#programming-problems"><span class="header-section-number">3.12.2</span> Programming Problems</a></li>
  <li><a href="#challenge-problems" id="toc-challenge-problems" class="nav-link" data-scroll-target="#challenge-problems"><span class="header-section-number">3.12.3</span> Challenge Problems</a></li>
  </ul></li>
  <li><a href="#additional-resources" id="toc-additional-resources" class="nav-link" data-scroll-target="#additional-resources"><span class="header-section-number">3.13</span> Additional Resources</a>
  <ul class="collapse">
  <li><a href="#recommended-reading" id="toc-recommended-reading" class="nav-link" data-scroll-target="#recommended-reading"><span class="header-section-number">3.13.1</span> Recommended Reading</a></li>
  <li><a href="#video-lectures" id="toc-video-lectures" class="nav-link" data-scroll-target="#video-lectures"><span class="header-section-number">3.13.2</span> Video Lectures</a></li>
  <li><a href="#practice-platforms" id="toc-practice-platforms" class="nav-link" data-scroll-target="#practice-platforms"><span class="header-section-number">3.13.3</span> Practice Platforms</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Advanced Algorithms: A Journey Through Computational Problem Solving</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="chapter-2-divide-and-conquer---the-art-of-problem-decomposition" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="chapter-2-divide-and-conquer---the-art-of-problem-decomposition"><span class="header-section-number">3.1</span> Chapter 2: Divide and Conquer - The Art of Problem Decomposition</h2>
<p><em>“The secret to getting ahead is getting started. The secret to getting started is breaking your complex overwhelming tasks into small manageable tasks, and then starting on the first one.” - Mark Twain</em></p>
<hr>
</section>
<section id="welcome-to-the-power-of-recursion" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="welcome-to-the-power-of-recursion"><span class="header-section-number">3.2</span> Welcome to the Power of Recursion</h2>
<p>Imagine you’re organizing a massive library with 1 million books scattered randomly across the floor. Your task is to alphabetize them all. If you tried to do this alone, directly comparing and moving individual books, you’d be there for months (or years!). But what if you could recruit helpers, and each person took a stack of books, sorted their stack, and then you combined all the sorted stacks? Suddenly, an impossible task becomes manageable.</p>
<p>This is the essence of <strong>divide and conquer</strong>—one of the most elegant and powerful paradigms in all of computer science. Instead of solving a large problem directly, we break it into smaller subproblems, solve those recursively, and then combine the solutions. It’s the same strategy that successful armies, businesses, and problem-solvers have used throughout history: divide your challenge into manageable pieces, conquer each piece, and unite the results.</p>
<p>In Chapter 1, we learned to analyze algorithms and implemented basic sorting methods that worked directly on the entire input. Those algorithms—bubble sort, selection sort, insertion sort—all had O(n²) time complexity in the worst case. Now we’re going to blow past that limitation. By the end of this chapter, you’ll understand and implement sorting algorithms that run in O(n log n) time, making them thousands of times faster on large datasets. The key? Divide and conquer.</p>
<section id="why-this-matters" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="why-this-matters"><span class="header-section-number">3.2.1</span> Why This Matters</h3>
<p>Divide and conquer isn’t just about sorting faster. This paradigm powers some of the most important algorithms in computing:</p>
<p><strong>🔍 Binary Search:</strong> Finding elements in sorted arrays in O(log n) time instead of O(n)</p>
<p><strong>📊 Fast Fourier Transform (FFT):</strong> Processing signals and audio in telecommunications, used billions of times per day</p>
<p><strong>🎮 Graphics Rendering:</strong> Breaking down complex 3D scenes into manageable pieces for real-time video games</p>
<p><strong>🧬 Computational Biology:</strong> Analyzing DNA sequences by breaking them into overlapping fragments</p>
<p><strong>💰 Financial Modeling:</strong> Monte Carlo simulations that break random scenarios into parallelizable chunks</p>
<p><strong>🤖 Machine Learning:</strong> Training algorithms that partition data recursively (decision trees, nearest neighbors)</p>
<p>The beautiful thing about divide and conquer is that once you understand the pattern, you’ll start seeing opportunities to apply it everywhere. It’s not just a technique—it’s a way of thinking about problems that will fundamentally change how you approach algorithm design.</p>
</section>
<section id="what-youll-learn" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="what-youll-learn"><span class="header-section-number">3.2.2</span> What You’ll Learn</h3>
<p>By the end of this chapter, you’ll master:</p>
<ol type="1">
<li><strong>The Divide and Conquer Paradigm:</strong> Understanding the three-step pattern and when to apply it</li>
<li><strong>Merge Sort:</strong> A guaranteed O(n log n) sorting algorithm with elegant simplicity</li>
<li><strong>QuickSort:</strong> The practical champion of sorting with average-case O(n log n) performance</li>
<li><strong>Recurrence Relations:</strong> Mathematical tools for analyzing recursive algorithms</li>
<li><strong>Master Theorem:</strong> A powerful formula for solving common recurrences quickly</li>
<li><strong>Advanced Applications:</strong> From integer multiplication to matrix algorithms</li>
</ol>
<p>Most importantly, you’ll develop <strong>recursive thinking</strong>—the ability to see how big problems can be solved by solving smaller versions of themselves. This skill will serve you throughout your career, whether you’re optimizing databases, designing distributed systems, or building AI algorithms.</p>
</section>
<section id="chapter-roadmap" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="chapter-roadmap"><span class="header-section-number">3.2.3</span> Chapter Roadmap</h3>
<p>We’ll build your understanding systematically:</p>
<ul>
<li><strong>Section 2.1:</strong> Introduces the divide and conquer pattern with intuitive examples</li>
<li><strong>Section 2.2:</strong> Develops merge sort from scratch, proving its correctness and efficiency</li>
<li><strong>Section 2.3:</strong> Explores quicksort and randomization techniques</li>
<li><strong>Section 2.4:</strong> Equips you with mathematical tools for analyzing recursive algorithms</li>
<li><strong>Section 2.5:</strong> Shows advanced applications and when NOT to use divide and conquer</li>
<li><strong>Section 2.6:</strong> Guides you through implementing and optimizing these algorithms</li>
</ul>
<p>Don’t worry if recursion feels challenging at first—it’s genuinely difficult for most people. The human brain is wired to think iteratively (step 1, step 2, step 3…) rather than recursively (solve by solving smaller versions). We’ll take it slow, build intuition with examples, and practice until recursive thinking becomes second nature.</p>
<p>Let’s begin by understanding what makes divide and conquer so powerful!</p>
<hr>
</section>
</section>
<section id="section-2.1-the-divide-and-conquer-paradigm" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="section-2.1-the-divide-and-conquer-paradigm"><span class="header-section-number">3.3</span> Section 2.1: The Divide and Conquer Paradigm</h2>
<section id="the-three-step-dance" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="the-three-step-dance"><span class="header-section-number">3.3.1</span> The Three-Step Dance</h3>
<p>Every divide and conquer algorithm follows the same beautiful three-step pattern:</p>
<p><strong>1. DIVIDE:</strong> Break the problem into smaller subproblems of the same type <strong>2. CONQUER:</strong> Solve the subproblems recursively (or directly if they’re small enough) <strong>3. COMBINE:</strong> Merge the solutions to create a solution to the original problem</p>
<p>Think of it like this recipe analogy:</p>
<p><strong>Problem:</strong> Make dinner for 100 people</p>
<ul>
<li><strong>DIVIDE:</strong> Break into 10 groups of 10 people each</li>
<li><strong>CONQUER:</strong> Have 10 cooks each make dinner for their group of 10</li>
<li><strong>COMBINE:</strong> Bring all the meals together for the feast</li>
</ul>
<p>The magic happens because each subproblem is simpler than the original, and eventually, you reach subproblems so small they’re trivial to solve.</p>
</section>
<section id="real-world-analogy-organizing-a-tournament" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="real-world-analogy-organizing-a-tournament"><span class="header-section-number">3.3.2</span> Real-World Analogy: Organizing a Tournament</h3>
<p>Let’s say you need to find the best chess player among 1,024 competitors.</p>
<p><strong>Naive Approach (Round-robin):</strong></p>
<ul>
<li>Everyone plays everyone else</li>
<li>Total games: 1,024 × 1,023 / 2 = 523,776 games!</li>
<li>Time complexity: O(n²)</li>
</ul>
<p><strong>Divide and Conquer Approach (Tournament bracket):</strong></p>
<ul>
<li><strong>Round 1:</strong> Divide into 512 pairs, each pair plays → 512 games</li>
<li><strong>Round 2:</strong> Divide winners into 256 pairs → 256 games</li>
<li><strong>Round 3:</strong> Divide winners into 128 pairs → 128 games</li>
<li>…continue until final winner</li>
<li><strong>Total games:</strong> 512 + 256 + 128 + … + 2 + 1 = 1,023 games</li>
<li>Time complexity: O(n)… actually O(n) in this case, but O(log n) rounds!</li>
</ul>
<p>You just reduced the problem from over 500,000 games to about 1,000 games—a 500× speedup! This is the power of divide and conquer.</p>
</section>
<section id="a-simple-example-finding-maximum-element" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="a-simple-example-finding-maximum-element"><span class="header-section-number">3.3.3</span> A Simple Example: Finding Maximum Element</h3>
<p>Before we tackle sorting, let’s see divide and conquer in action with a simpler problem.</p>
<p><strong>Problem:</strong> Find the maximum element in an array.</p>
<p><strong>Iterative Solution (from Chapter 1):</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_max_iterative(arr):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""O(n) time, O(1) space - simple and effective"""</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    max_val <span class="op">=</span> arr[<span class="dv">0</span>]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> element <span class="kw">in</span> arr:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> element <span class="op">&gt;</span> max_val:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            max_val <span class="op">=</span> element</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_val</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Divide and Conquer Solution:</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_max_divide_conquer(arr, left, right):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Find maximum using divide and conquer.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Still O(n) time, but demonstrates the pattern.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># BASE CASE: If array has one element, that's the max</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> left <span class="op">==</span> right:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr[left]</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># BASE CASE: If array has two elements, return the larger</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> right <span class="op">==</span> left <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(arr[left], arr[right])</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># DIVIDE: Split array in half</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> (left <span class="op">+</span> right) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CONQUER: Find max in each half recursively</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    left_max <span class="op">=</span> find_max_divide_conquer(arr, left, mid)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    right_max <span class="op">=</span> find_max_divide_conquer(arr, mid <span class="op">+</span> <span class="dv">1</span>, right)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># COMBINE: The overall max is the larger of the two halves</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(left_max, right_max)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Usage</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">9</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">8</span>]</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> find_max_divide_conquer(arr, <span class="dv">0</span>, <span class="bu">len</span>(arr) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: 9</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Analysis:</strong></p>
<ul>
<li><strong>Divide:</strong> Split array into two halves → O(1)</li>
<li><strong>Conquer:</strong> Recursively find max in each half → 2 × T(n/2)</li>
<li><strong>Combine:</strong> Compare two numbers → O(1)</li>
</ul>
<p><strong>Recurrence relation:</strong> T(n) = 2T(n/2) + O(1) <strong>Solution:</strong> T(n) = O(n)</p>
<p>Wait—we got the same time complexity as the iterative version! So why bother with divide and conquer?</p>
<p><strong>Good question!</strong> For finding the maximum, divide and conquer doesn’t help. But here’s what’s interesting:</p>
<ol type="1">
<li><strong>Parallelization:</strong> The two recursive calls are independent—they could run simultaneously on different processors!</li>
<li><strong>Pattern Practice:</strong> Understanding this simple example prepares us for problems where divide and conquer DOES improve complexity</li>
<li><strong>Elegance:</strong> Some people find the recursive solution more intuitive</li>
</ol>
<p>The key insight: <strong>Not every problem benefits from divide and conquer.</strong> You need to check if the divide and combine steps are efficient enough to justify the approach.</p>
</section>
<section id="when-does-divide-and-conquer-help" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="when-does-divide-and-conquer-help"><span class="header-section-number">3.3.4</span> When Does Divide and Conquer Help?</h3>
<p>Divide and conquer typically improves time complexity when:</p>
<p><strong>✅ Subproblems are independent</strong> (can be solved separately) <strong>✅ Combining solutions is relatively cheap</strong> (ideally O(n) or better) <strong>✅ Problem size reduces significantly</strong> (usually by half or more) <strong>✅ Base cases are simple</strong> (direct solutions exist for small inputs)</p>
<p><strong>Examples where it helps:</strong></p>
<ul>
<li><strong>Sorting</strong> (merge sort, quicksort): O(n²) → O(n log n)</li>
<li><strong>Binary search</strong>: O(n) → O(log n)</li>
<li><strong>Matrix multiplication</strong> (Strassen’s): O(n³) → O(n^2.807)</li>
<li><strong>Integer multiplication</strong> (Karatsuba): O(n²) → O(n^1.585)</li>
</ul>
<p><strong>Examples where it doesn’t help much:</strong></p>
<ul>
<li><strong>Finding maximum</strong> (as we just saw)</li>
<li><strong>Computing array sum</strong> (simple iteration is better)</li>
<li><strong>Checking if sorted</strong> (must examine every element anyway)</li>
</ul>
</section>
<section id="the-recursion-tree-visualizing-divide-and-conquer" class="level3" data-number="3.3.5">
<h3 data-number="3.3.5" class="anchored" data-anchor-id="the-recursion-tree-visualizing-divide-and-conquer"><span class="header-section-number">3.3.5</span> The Recursion Tree: Visualizing Divide and Conquer</h3>
<p>Understanding recursion trees is crucial for analyzing divide and conquer algorithms. Let’s visualize our max-finding example:</p>
<pre><code>                    find_max([3,7,2,9,1,5,8,4])  ← Original problem
                           /              \
                          /                \
              find_max([3,7,2,9])    find_max([1,5,8,4])  ← Divide in half
                   /        \             /        \
                  /          \           /          \
        find_max([3,7]) find_max([2,9]) find_max([1,5]) find_max([8,4])
            /    \        /    \          /    \         /    \
           3     7       2     9         1     5        8     4  ← Base cases
           
        Return 7    Return 9          Return 5       Return 8
              \      /                      \          /
               \    /                        \        /
            Return 9                      Return 8
                  \                          /
                   \                        /
                    \                      /
                            Return 9  ← Final answer</code></pre>
<p><strong>Key observations about the tree:</strong></p>
<ol type="1">
<li><strong>Height of tree:</strong> log₂(8) = 3 levels (plus base level)</li>
<li><strong>Work per level:</strong> We compare all n elements once per level → O(n) per level</li>
<li><strong>Total work:</strong> O(n) × log(n) levels = O(n log n)… wait, no!</li>
</ol>
<p>Actually, for this problem, the work decreases as we go down:</p>
<ul>
<li>Level 0: 8 elements</li>
<li>Level 1: 4 + 4 = 8 elements</li>
<li>Level 2: 2 + 2 + 2 + 2 = 8 elements</li>
<li>Level 3: 8 base cases (1 element each)</li>
</ul>
<p>Each level processes n elements total, and there are log(n) levels, but the combine step is O(1), so total is O(n).</p>
<p><strong>Important lesson:</strong> The combine step’s complexity determines whether divide and conquer helps! We’ll see this more clearly with merge sort.</p>
</section>
<section id="designing-divide-and-conquer-algorithms-a-checklist" class="level3" data-number="3.3.6">
<h3 data-number="3.3.6" class="anchored" data-anchor-id="designing-divide-and-conquer-algorithms-a-checklist"><span class="header-section-number">3.3.6</span> Designing Divide and Conquer Algorithms: A Checklist</h3>
<p>When approaching a new problem with divide and conquer, ask yourself:</p>
<p><strong>1. Can the problem be divided?</strong></p>
<ul>
<li>Is there a natural way to split the problem?</li>
<li>Do the subproblems have the same structure as the original?</li>
<li>Example: Arrays can be split by index; problems can be divided by constraint</li>
</ul>
<p><strong>2. Are subproblems independent?</strong></p>
<ul>
<li>Can each subproblem be solved without information from others?</li>
<li>If subproblems overlap significantly, consider dynamic programming instead</li>
<li>Example: In merge sort, sorting left half doesn’t depend on right half</li>
</ul>
<p><strong>3. What’s the base case?</strong></p>
<ul>
<li>When is the problem small enough to solve directly?</li>
<li>Usually when n = 1 or n = 0</li>
<li>Example: An array of one element is already sorted</li>
</ul>
<p><strong>4. How do we combine solutions?</strong></p>
<ul>
<li>What operation merges subproblem solutions?</li>
<li>How expensive is this operation?</li>
<li>Example: Merging two sorted arrays takes O(n) time</li>
</ul>
<p><strong>5. Does the math work out?</strong></p>
<ul>
<li>Write the recurrence relation</li>
<li>Solve it to find time complexity</li>
<li>Is it better than the naive approach?</li>
</ul>
<p>Let’s apply this framework to sorting!</p>
<hr>
</section>
</section>
<section id="section-2.2-merge-sort---guaranteed-on-log-n-performance" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="section-2.2-merge-sort---guaranteed-on-log-n-performance"><span class="header-section-number">3.4</span> Section 2.2: Merge Sort - Guaranteed O(n log n) Performance</h2>
<section id="the-sorting-challenge-revisited" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="the-sorting-challenge-revisited"><span class="header-section-number">3.4.1</span> The Sorting Challenge Revisited</h3>
<p>In Chapter 1, we implemented three sorting algorithms: bubble sort, selection sort, and insertion sort. All three have O(n²) worst-case time complexity. For small arrays, that’s fine. But what about sorting a million elements?</p>
<p><strong>O(n²) algorithms:</strong> 1,000,000² = 1,000,000,000,000 operations (1 trillion!) <strong>O(n log n) algorithms:</strong> 1,000,000 × log₂(1,000,000) ≈ 20,000,000 operations (20 million)</p>
<p>That’s a <strong>50,000× speedup</strong>! This is why understanding efficient sorting matters.</p>
<p>Merge sort achieves O(n log n) by using divide and conquer:</p>
<ol type="1">
<li><strong>Divide:</strong> Split the array into two halves</li>
<li><strong>Conquer:</strong> Recursively sort each half</li>
<li><strong>Combine:</strong> Merge the two sorted halves into one sorted array</li>
</ol>
<p>The brilliance is in step 3: merging two sorted arrays is surprisingly efficient!</p>
</section>
<section id="the-merge-operation-the-secret-sauce" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="the-merge-operation-the-secret-sauce"><span class="header-section-number">3.4.2</span> The Merge Operation: The Secret Sauce</h3>
<p>Before we look at the full merge sort algorithm, let’s understand how to merge two sorted arrays efficiently.</p>
<p><strong>Problem:</strong> Given two sorted arrays, create one sorted array containing all elements.</p>
<p><strong>Example:</strong></p>
<pre><code>Left:  [2, 5, 7, 9]
Right: [1, 3, 6, 8]
Result: [1, 2, 3, 5, 6, 7, 8, 9]</code></pre>
<p><strong>Key insight:</strong> Since both arrays are already sorted, we can merge them by comparing elements from the front of each array, taking the smaller one each time.</p>
<p><strong>The Merge Algorithm:</strong></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge(left, right):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Merge two sorted arrays into one sorted array.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Time Complexity: O(n + m) where n = len(left), m = len(right)</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Space Complexity: O(n + m) for result array</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">        left: Sorted list</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co">        right: Sorted list</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co">        Merged sorted list containing all elements</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">        &gt;&gt;&gt; merge([2, 5, 7], [1, 3, 6])</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co">        [1, 2, 3, 5, 6, 7]</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> j <span class="op">=</span> <span class="dv">0</span>  <span class="co"># Pointers for left and right arrays</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compare elements and take the smaller one</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(left) <span class="kw">and</span> j <span class="op">&lt;</span> <span class="bu">len</span>(right):</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> left[i] <span class="op">&lt;=</span> right[j]:</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            result.append(left[i])</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>            result.append(right[j])</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Append remaining elements (one array will be exhausted first)</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    result.extend(left[i:])  <span class="co"># Add remaining left elements (if any)</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    result.extend(right[j:]) <span class="co"># Add remaining right elements (if any)</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Let’s trace through the example:</strong></p>
<pre><code>Initial state:
left = [2, 5, 7, 9],  right = [1, 3, 6, 8]
i = 0, j = 0
result = []

Step 1: Compare left[0]=2 vs right[0]=1 → 1 is smaller
result = [1], j = 1

Step 2: Compare left[0]=2 vs right[1]=3 → 2 is smaller  
result = [1, 2], i = 1

Step 3: Compare left[1]=5 vs right[1]=3 → 3 is smaller
result = [1, 2, 3], j = 2

Step 4: Compare left[1]=5 vs right[2]=6 → 5 is smaller
result = [1, 2, 3, 5], i = 2

Step 5: Compare left[2]=7 vs right[2]=6 → 6 is smaller
result = [1, 2, 3, 5, 6], j = 3

Step 6: Compare left[2]=7 vs right[3]=8 → 7 is smaller
result = [1, 2, 3, 5, 6, 7], i = 3

Step 7: Compare left[3]=9 vs right[3]=8 → 8 is smaller
result = [1, 2, 3, 5, 6, 7, 8], j = 4

Step 8: right is exhausted, append remaining from left
result = [1, 2, 3, 5, 6, 7, 8, 9]</code></pre>
<p><strong>Analysis:</strong></p>
<ul>
<li>We examine each element exactly once</li>
<li>Total comparisons ≤ (n + m)</li>
<li>Time complexity: <strong>O(n + m)</strong> where n and m are the lengths of the input arrays</li>
<li>In the context of merge sort, this will be O(n) where n is the total number of elements</li>
</ul>
<p>This linear-time merge is what makes merge sort efficient!</p>
</section>
<section id="the-complete-merge-sort-algorithm" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3" class="anchored" data-anchor-id="the-complete-merge-sort-algorithm"><span class="header-section-number">3.4.3</span> The Complete Merge Sort Algorithm</h3>
<p>Now we can build the full algorithm:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_sort(arr):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Sort an array using merge sort (divide and conquer).</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Time Complexity: O(n log n) in all cases</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Space Complexity: O(n) for temporary arrays</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Stability: Stable (maintains relative order of equal elements)</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">        arr: List of comparable elements</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">        New sorted list</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">        &gt;&gt;&gt; merge_sort([64, 34, 25, 12, 22, 11, 90])</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">        [11, 12, 22, 25, 34, 64, 90]</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># BASE CASE: Arrays of length 0 or 1 are already sorted</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(arr) <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># DIVIDE: Split array in half</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> <span class="bu">len</span>(arr) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    left_half <span class="op">=</span> arr[:mid]</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    right_half <span class="op">=</span> arr[mid:]</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CONQUER: Recursively sort each half</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    sorted_left <span class="op">=</span> merge_sort(left_half)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    sorted_right <span class="op">=</span> merge_sort(right_half)</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># COMBINE: Merge the sorted halves</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merge(sorted_left, sorted_right)</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="co"># The merge function from before</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge(left, right):</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Merge two sorted arrays into one sorted array."""</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> j <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> <span class="bu">len</span>(left) <span class="kw">and</span> j <span class="op">&lt;</span> <span class="bu">len</span>(right):</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> left[i] <span class="op">&lt;=</span> right[j]:</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>            result.append(left[i])</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>            result.append(right[j])</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    result.extend(left[i:])</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>    result.extend(right[j:])</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Example Execution:</strong></p>
<p>Let’s sort <code>[38, 27, 43, 3]</code> step by step:</p>
<pre><code>Initial call: merge_sort([38, 27, 43, 3])
    ↓
    Split into [38, 27] and [43, 3]
    ↓
    Call merge_sort([38, 27])          Call merge_sort([43, 3])
        ↓                                  ↓
        Split into [38] and [27]           Split into [43] and [3]
        ↓                                  ↓
        [38] and [27] are base cases       [43] and [3] are base cases
        ↓                                  ↓
        Merge([38], [27]) → [27, 38]      Merge([43], [3]) → [3, 43]
        ↓                                  ↓
        Return [27, 38]                    Return [3, 43]
    ↓
    Merge([27, 38], [3, 43])
    ↓
    [3, 27, 38, 43]  ← Final result</code></pre>
<p><strong>Complete recursion tree:</strong></p>
<pre><code>                    [38, 27, 43, 3]
                    /              \
              [38, 27]            [43, 3]
              /      \            /      \
           [38]     [27]       [43]     [3]     ← Base cases
             |        |          |        |
           [38]     [27]       [43]     [3]     ← Return as-is
              \      /            \      /
             [27, 38]            [3, 43]         ← Merge pairs
                  \                  /
                   \                /
                  [3, 27, 38, 43]                ← Final merge</code></pre>
</section>
<section id="correctness-proof-for-merge-sort" class="level3" data-number="3.4.4">
<h3 data-number="3.4.4" class="anchored" data-anchor-id="correctness-proof-for-merge-sort"><span class="header-section-number">3.4.4</span> Correctness Proof for Merge Sort</h3>
<p>Let’s prove that merge sort actually works using <strong>mathematical induction</strong>.</p>
<p><strong>Theorem:</strong> Merge sort correctly sorts any array of comparable elements.</p>
<p><strong>Proof by induction on array size n:</strong></p>
<p><strong>Base case (n ≤ 1):</strong></p>
<ul>
<li>Arrays of size 0 or 1 are already sorted</li>
<li>Merge sort returns them unchanged</li>
<li>✓ Correct</li>
</ul>
<p><strong>Inductive hypothesis:</strong></p>
<ul>
<li>Assume merge sort correctly sorts all arrays of size k &lt; n</li>
</ul>
<p><strong>Inductive step:</strong></p>
<ul>
<li>Consider an array of size n</li>
<li>Merge sort splits it into two halves of size ≤ n/2</li>
<li>By inductive hypothesis, both halves are sorted correctly (since n/2 &lt; n)</li>
<li>The merge operation combines two sorted arrays into one sorted array (proven separately)</li>
<li>Therefore, merge sort correctly sorts the array of size n</li>
<li>✓ Correct</li>
</ul>
<p><strong>Conclusion:</strong> By mathematical induction, merge sort correctly sorts arrays of any size. ∎</p>
<p><strong>Proof that merge is correct:</strong></p>
<ul>
<li>The merge operation maintains a loop invariant:
<ul>
<li><strong>Invariant:</strong> result[0…k] contains the k smallest elements from left and right, in sorted order</li>
<li><strong>Initialization:</strong> result is empty (trivially sorted)</li>
<li><strong>Maintenance:</strong> We always take the smaller of left[i] or right[j], preserving sorted order</li>
<li><strong>Termination:</strong> When one array is exhausted, we append the remainder (already sorted)</li>
</ul></li>
<li>Therefore, merge produces a correctly sorted array ∎</li>
</ul>
</section>
<section id="time-complexity-analysis" class="level3" data-number="3.4.5">
<h3 data-number="3.4.5" class="anchored" data-anchor-id="time-complexity-analysis"><span class="header-section-number">3.4.5</span> Time Complexity Analysis</h3>
<p>Now let’s rigorously analyze merge sort’s performance.</p>
<p><strong>Divide step:</strong> Finding the midpoint takes O(1) time</p>
<p><strong>Conquer step:</strong> We make two recursive calls on arrays of size n/2</p>
<p><strong>Combine step:</strong> Merging takes O(n) time (we process each element once)</p>
<p><strong>Recurrence relation:</strong></p>
<pre><code>T(n) = 2T(n/2) + O(n)
T(1) = O(1)</code></pre>
<p><strong>Solving the recurrence (using the recursion tree method):</strong></p>
<pre><code>Level 0: 1 problem of size n          → Work: cn
Level 1: 2 problems of size n/2       → Work: 2 × c(n/2) = cn
Level 2: 4 problems of size n/4       → Work: 4 × c(n/4) = cn
Level 3: 8 problems of size n/8       → Work: 8 × c(n/8) = cn
...
Level log n: n problems of size 1     → Work: n × c(1) = cn

Total work = cn × (log₂ n + 1) = O(n log n)</code></pre>
<p><strong>Visual representation:</strong></p>
<pre><code>                            cn                    ← Level 0: n work
                    /              \
                cn/2              cn/2             ← Level 1: n work total
              /      \          /      \
           cn/4    cn/4      cn/4    cn/4         ← Level 2: n work total
          /  \    /  \      /  \    /  \
        ...  ...  ...  ...  ...  ...  ...  ...   ← ...
        c    c    c    c    c    c    c    c     ← Level log n: n work total

Total levels: log₂(n) + 1
Work per level: cn
Total work: cn log₂(n) = O(n log n)</code></pre>
<p><strong>Formal proof using substitution method:</strong></p>
<p>Guess: T(n) ≤ cn log n for some constant c</p>
<p>Base case: T(1) = c₁ ≤ c·1·log 1 = 0… we need T(1) ≤ c for this to work</p>
<p>Let’s refine: T(n) ≤ cn log n + d for constants c, d</p>
<p><strong>Inductive step:</strong></p>
<pre><code>T(n) = 2T(n/2) + cn
     ≤ 2[c(n/2)log(n/2) + d] + cn          (by hypothesis)
     = cn log(n/2) + 2d + cn
     = cn(log n - log 2) + 2d + cn
     = cn log n - cn + 2d + cn
     = cn log n + 2d
     ≤ cn log n + d  (if d ≥ 2d, which we can choose)</code></pre>
<p>Therefore T(n) = O(n log n) ✓</p>
<p><strong>Why O(n log n) is significantly better than O(n²):</strong></p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Input Size</th>
<th>O(n²) Operations</th>
<th>O(n log n) Operations</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>100</td>
<td>10,000</td>
<td>664</td>
<td>15×</td>
</tr>
<tr class="even">
<td>1,000</td>
<td>1,000,000</td>
<td>9,966</td>
<td>100×</td>
</tr>
<tr class="odd">
<td>10,000</td>
<td>100,000,000</td>
<td>132,877</td>
<td>752×</td>
</tr>
<tr class="even">
<td>100,000</td>
<td>10,000,000,000</td>
<td>1,660,964</td>
<td>6,020×</td>
</tr>
<tr class="odd">
<td>1,000,000</td>
<td>1,000,000,000,000</td>
<td>19,931,569</td>
<td>50,170×</td>
</tr>
</tbody>
</table>
<p>For a million elements, merge sort is <strong>50,000 times faster</strong> than bubble sort!</p>
</section>
<section id="space-complexity-analysis" class="level3" data-number="3.4.6">
<h3 data-number="3.4.6" class="anchored" data-anchor-id="space-complexity-analysis"><span class="header-section-number">3.4.6</span> Space Complexity Analysis</h3>
<p>Unlike our O(n²) sorting algorithms from Chapter 1 (which sorted in-place), merge sort requires additional memory:</p>
<p><strong>During merging:</strong></p>
<ul>
<li>We create a new result array of size n</li>
<li>This happens at each level of recursion</li>
</ul>
<p><strong>Recursion stack:</strong></p>
<ul>
<li>Maximum depth is log n</li>
<li>Each level stores its own variables</li>
</ul>
<p><strong>Total space complexity:</strong> O(n)</p>
<p>The space used at each recursive level is:</p>
<ul>
<li>Level 0: n space for merging</li>
<li>Level 1: n/2 + n/2 = n space total (two merges)</li>
<li>Level 2: n/4 + n/4 + n/4 + n/4 = n space total</li>
<li>…</li>
</ul>
<p>However, the merges at different levels don’t overlap in time, so we can reuse space. The dominant factor is O(n) for the merge operations plus O(log n) for the recursion stack, giving us <strong>O(n) total space complexity</strong>.</p>
<p><strong>Trade-off:</strong> Merge sort trades space for time. We use extra memory to achieve faster sorting.</p>
</section>
<section id="merge-sort-properties" class="level3" data-number="3.4.7">
<h3 data-number="3.4.7" class="anchored" data-anchor-id="merge-sort-properties"><span class="header-section-number">3.4.7</span> Merge Sort Properties</h3>
<p>Let’s summarize merge sort’s characteristics:</p>
<p><strong>✅ Advantages:</strong></p>
<ul>
<li><strong>Guaranteed O(n log n)</strong> in worst, average, and best cases (predictable performance)</li>
<li><strong>Stable:</strong> Maintains relative order of equal elements</li>
<li><strong>Simple to understand and implement</strong> once you grasp recursion</li>
<li><strong>Parallelizable:</strong> The two recursive calls can run simultaneously</li>
<li><strong>Great for linked lists:</strong> Can be implemented without extra space on linked structures</li>
<li><strong>External sorting:</strong> Works well for data that doesn’t fit in memory</li>
</ul>
<p><strong>❌ Disadvantages:</strong></p>
<ul>
<li><strong>O(n) extra space required</strong> (not in-place)</li>
<li><strong>Slower in practice than quicksort</strong> on arrays due to memory allocation overhead</li>
<li><strong>Not adaptive:</strong> Doesn’t take advantage of existing order in the data</li>
<li><strong>Cache-unfriendly:</strong> Memory access pattern isn’t optimal for modern CPUs</li>
</ul>
</section>
<section id="optimizing-merge-sort" class="level3" data-number="3.4.8">
<h3 data-number="3.4.8" class="anchored" data-anchor-id="optimizing-merge-sort"><span class="header-section-number">3.4.8</span> Optimizing Merge Sort</h3>
<p>While the basic merge sort is elegant, we can make it faster in practice:</p>
<p><strong>Optimization 1: Switch to insertion sort for small subarrays</strong></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_sort_optimized(arr):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Merge sort with insertion sort for small arrays."""</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Switch to insertion sort for small arrays (faster due to lower overhead)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(arr) <span class="op">&lt;=</span> <span class="dv">10</span>:  <span class="co"># Threshold found empirically</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> insertion_sort(arr)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(arr) <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> <span class="bu">len</span>(arr) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> merge_sort_optimized(arr[:mid])</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> merge_sort_optimized(arr[mid:])</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merge(left, right)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why this helps:</strong></p>
<ul>
<li>Insertion sort has lower overhead for small inputs</li>
<li>O(n²) vs O(n log n) doesn’t matter when n ≤ 10</li>
<li>Reduces recursion depth</li>
<li>Typical speedup: 10-15%</li>
</ul>
<p><strong>Optimization 2: Check if already sorted</strong></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_sort_smart(arr):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Skip merge if already sorted."""</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(arr) <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> <span class="bu">len</span>(arr) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> merge_sort_smart(arr[:mid])</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> merge_sort_smart(arr[mid:])</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If last element of left ≤ first element of right, already sorted!</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> left[<span class="op">-</span><span class="dv">1</span>] <span class="op">&lt;=</span> right[<span class="dv">0</span>]:</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> left <span class="op">+</span> right</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merge(left, right)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why this helps:</strong></p>
<ul>
<li>On nearly-sorted data, many subarrays are already in order</li>
<li>Avoids expensive merge operation</li>
<li>Typical speedup: 20-30% on nearly-sorted data</li>
</ul>
<p><strong>Optimization 3: In-place merge (advanced)</strong></p>
<p>The standard merge creates a new array. We can reduce space usage with an in-place merge, but it’s more complex and slower:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_inplace(arr, left, mid, right):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">    In-place merge (harder to implement correctly).</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Reduces space but doesn't eliminate it entirely.</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This is significantly more complex</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Usually not worth the complexity vs. space trade-off</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Included here for completeness</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span>  <span class="co"># Implementation omitted for brevity</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Most production implementations use the standard merge with space optimizations elsewhere.</p>
<hr>
</section>
</section>
<section id="section-2.3-quicksort---the-practical-champion" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="section-2.3-quicksort---the-practical-champion"><span class="header-section-number">3.5</span> Section 2.3: QuickSort - The Practical Champion</h2>
<section id="why-another-sorting-algorithm" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="why-another-sorting-algorithm"><span class="header-section-number">3.5.1</span> Why Another Sorting Algorithm?</h3>
<p>You might be thinking: “We have merge sort with guaranteed O(n log n) performance. Why do we need another algorithm?”</p>
<p>Great question! While merge sort is excellent in theory, <strong>quicksort is often faster in practice</strong> for several reasons:</p>
<ol type="1">
<li><strong>In-place sorting:</strong> Uses only O(log n) extra space for recursion (vs.&nbsp;merge sort’s O(n))</li>
<li><strong>Cache-friendly:</strong> Better memory access patterns on modern CPUs</li>
<li><strong>Fewer data movements:</strong> Elements are often already close to their final positions</li>
<li><strong>Simpler partitioning:</strong> The partition operation is often faster than merging</li>
</ol>
<p>The catch? Quick sort’s worst-case performance is O(n²). But with randomization, this worst case becomes extremely unlikely—so unlikely that quicksort is the go-to sorting algorithm in most standard libraries (C’s <code>qsort</code>, Java’s <code>Arrays.sort</code> for primitives, etc.).</p>
</section>
<section id="the-quicksort-idea" class="level3" data-number="3.5.2">
<h3 data-number="3.5.2" class="anchored" data-anchor-id="the-quicksort-idea"><span class="header-section-number">3.5.2</span> The QuickSort Idea</h3>
<p>QuickSort uses a different divide and conquer strategy than merge sort:</p>
<p><strong>Merge Sort approach:</strong></p>
<ul>
<li>Divide mechanically (just split in half)</li>
<li>Do all the work in the combine step (merging is complex)</li>
</ul>
<p><strong>QuickSort approach:</strong></p>
<ul>
<li>Divide intelligently (partition around a pivot)</li>
<li>Combine step is trivial (already sorted!)</li>
</ul>
<p>Here’s the pattern:</p>
<ol type="1">
<li><strong>DIVIDE:</strong> Choose a “pivot” element and partition the array so that:
<ul>
<li>All elements ≤ pivot are on the left</li>
<li>All elements &gt; pivot are on the right</li>
</ul></li>
<li><strong>CONQUER:</strong> Recursively sort the left and right partitions</li>
<li><strong>COMBINE:</strong> Do nothing! (The array is already sorted after recursive calls)</li>
</ol>
<p><strong>Key insight:</strong> After partitioning, the pivot is in its final sorted position. We never need to move it again.</p>
</section>
<section id="a-simple-example" class="level3" data-number="3.5.3">
<h3 data-number="3.5.3" class="anchored" data-anchor-id="a-simple-example"><span class="header-section-number">3.5.3</span> A Simple Example</h3>
<p>Let’s sort <code>[8, 3, 1, 7, 0, 10, 2]</code> using quicksort:</p>
<pre><code>Initial array: [8, 3, 1, 7, 0, 10, 2]

Step 1: Choose pivot (let's pick the last element: 2)
Partition around 2:
  Elements ≤ 2: [1, 0]
  Pivot: [2]
  Elements &gt; 2: [8, 3, 7, 10]
Result: [1, 0, 2, 8, 3, 7, 10]
         ^^^^^  ^  ^^^^^^^^^^^
         Left   P     Right

Step 2: Recursively sort left [1, 0]
  Choose pivot: 0
  Partition: [] [0] [1]
  Result: [0, 1]

Step 3: Recursively sort right [8, 3, 7, 10]
  Choose pivot: 10
  Partition: [8, 3, 7] [10] []
  Result: [3, 7, 8, 10] (after recursively sorting [8, 3, 7])

Final result: [0, 1, 2, 3, 7, 8, 10]</code></pre>
<p>Notice how the pivot (2) ended up in position 2 (its final sorted position) and never moved again!</p>
</section>
<section id="the-partition-operation" class="level3" data-number="3.5.4">
<h3 data-number="3.5.4" class="anchored" data-anchor-id="the-partition-operation"><span class="header-section-number">3.5.4</span> The Partition Operation</h3>
<p>The heart of quicksort is the partition operation. Let’s understand it deeply:</p>
<p><strong>Goal:</strong> Given an array and a pivot element, rearrange the array so that:</p>
<ul>
<li>All elements ≤ pivot are on the left</li>
<li>Pivot is in the middle</li>
<li>All elements &gt; pivot are on the right</li>
</ul>
<p><strong>Lomuto Partition Scheme (simpler, what we’ll use):</strong></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> partition(arr, low, high):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Partition array around pivot (last element).</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns the final position of the pivot.</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Time Complexity: O(n) where n = high - low + 1</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Space Complexity: O(1)</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co">        arr: Array to partition (modified in-place)</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">        low: Starting index</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="co">        high: Ending index</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Final position of pivot</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="co">        arr = [8, 3, 1, 7, 0, 10, 2], low = 0, high = 6</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="co">        After partition: [1, 0, 2, 7, 8, 10, 3]</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns: 2 (position of pivot 2)</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Choose the last element as pivot</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    pivot <span class="op">=</span> arr[high]</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># i tracks the boundary between ≤ pivot and &gt; pivot</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> low <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Scan through array</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(low, high):</span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If current element is ≤ pivot, move it to the left partition</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr[j] <span class="op">&lt;=</span> pivot:</span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>            arr[i], arr[j] <span class="op">=</span> arr[j], arr[i]  <span class="co"># Swap</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Place pivot in its final position</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>    arr[i], arr[high] <span class="op">=</span> arr[high], arr[i]</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i  <span class="co"># Return pivot's final position</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Let’s trace through an example step by step:</strong></p>
<pre><code>Array: [8, 3, 1, 7, 0, 10, 2], pivot = 2 (at index 6)
low = 0, high = 6, i = -1

Initial: [8, 3, 1, 7, 0, 10, 2]
          ^                  ^
          j                  pivot

j=0: arr[0]=8 &gt; 2, skip
i = -1

j=1: arr[1]=3 &gt; 2, skip  
i = -1

j=2: arr[2]=1 ≤ 2, swap with position i+1=0
Array: [1, 3, 8, 7, 0, 10, 2]
        ^  ^
        i  j
i = 0

j=3: arr[3]=7 &gt; 2, skip
i = 0

j=4: arr[4]=0 ≤ 2, swap with position i+1=1
Array: [1, 0, 8, 7, 3, 10, 2]
           ^        ^
           i        j
i = 1

j=5: arr[5]=10 &gt; 2, skip
i = 1

End of loop, place pivot at position i+1=2
Array: [1, 0, 2, 7, 3, 10, 8]
              ^
              pivot in final position

Return 2</code></pre>
<p><strong>Loop Invariant:</strong> At each iteration, the array satisfies:</p>
<ul>
<li><code>arr[low...i]</code>: All elements ≤ pivot</li>
<li><code>arr[i+1...j-1]</code>: All elements &gt; pivot</li>
<li><code>arr[j...high-1]</code>: Unprocessed elements</li>
<li><code>arr[high]</code>: Pivot element</li>
</ul>
<p>This invariant ensures correctness!</p>
</section>
<section id="the-complete-quicksort-algorithm" class="level3" data-number="3.5.5">
<h3 data-number="3.5.5" class="anchored" data-anchor-id="the-complete-quicksort-algorithm"><span class="header-section-number">3.5.5</span> The Complete QuickSort Algorithm</h3>
<p>Now we can implement the full algorithm:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quicksort(arr, low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Sort array using quicksort (divide and conquer).</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Time Complexity: </span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">        Best/Average: O(n log n)</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">        Worst: O(n²) - rare with randomization</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Space Complexity: O(log n) for recursion stack</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Stability: Unstable</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="co">        arr: List to sort (modified in-place)</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="co">        low: Starting index (default 0)</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="co">        high: Ending index (default len(arr)-1)</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a><span class="co">        None (sorts in-place)</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="co">        &gt;&gt;&gt; arr = [64, 34, 25, 12, 22, 11, 90]</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span class="co">        &gt;&gt;&gt; quicksort(arr)</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="co">        &gt;&gt;&gt; arr</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span class="co">        [11, 12, 22, 25, 34, 64, 90]</span></span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle default parameter</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> high <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>        high <span class="op">=</span> <span class="bu">len</span>(arr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># BASE CASE: If partition has 0 or 1 elements, it's sorted</span></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> low <span class="op">&lt;</span> high:</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># DIVIDE: Partition array and get pivot position</span></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>        pivot_pos <span class="op">=</span> partition(arr, low, high)</span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># CONQUER: Recursively sort elements before and after pivot</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>        quicksort(arr, low, pivot_pos <span class="op">-</span> <span class="dv">1</span>)   <span class="co"># Sort left partition</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>        quicksort(arr, pivot_pos <span class="op">+</span> <span class="dv">1</span>, high)  <span class="co"># Sort right partition</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a>        <span class="co"># COMBINE: Nothing to do! Array is already sorted</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> partition(arr, low, high):</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Partition array around pivot (last element)."""</span></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a>    pivot <span class="op">=</span> arr[high]</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> low <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(low, high):</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr[j] <span class="op">&lt;=</span> pivot:</span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>            arr[i], arr[j] <span class="op">=</span> arr[j], arr[i]</span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>    arr[i], arr[high] <span class="op">=</span> arr[high], arr[i]</span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Example execution:</strong></p>
<pre><code>quicksort([8, 3, 1, 7, 0, 10, 2])
    ↓
    Partition around 2 → [1, 0, 2, 8, 3, 7, 10]
                              ^
                           pivot at position 2
    ↓
    quicksort([1, 0])              quicksort([8, 3, 7, 10])
         ↓                                  ↓
    Partition around 0           Partition around 10
    [0, 1]                       [7, 3, 8, 10]
     ^                                    ^
    pivot at 0                     pivot at position 3
         ↓                                  ↓
    quicksort([])  quicksort([1])  quicksort([7, 3, 8])  quicksort([])
         ↓              ↓                    ↓                ↓
       base case    base case      Partition around 8    base case
                                   [7, 3, 8]
                                        ^
                                   pivot at position 2
                                        ↓
                              quicksort([7, 3])  quicksort([])
                                   ↓                  ↓
                            Partition around 3    base case
                            [3, 7]
                             ^
                        pivot at position 0
                             ↓
                    quicksort([])  quicksort([7])
                         ↓              ↓
                    base case       base case

Final result: [0, 1, 2, 3, 7, 8, 10]</code></pre>
</section>
<section id="analysis-best-case-worst-case-average-case" class="level3" data-number="3.5.6">
<h3 data-number="3.5.6" class="anchored" data-anchor-id="analysis-best-case-worst-case-average-case"><span class="header-section-number">3.5.6</span> Analysis: Best Case, Worst Case, Average Case</h3>
<p>QuickSort’s performance varies dramatically based on pivot selection:</p>
<section id="best-case-on-log-n" class="level4" data-number="3.5.6.1">
<h4 data-number="3.5.6.1" class="anchored" data-anchor-id="best-case-on-log-n"><span class="header-section-number">3.5.6.1</span> Best Case: O(n log n)</h4>
<p><strong>Occurs when:</strong> Pivot always divides array perfectly in half</p>
<pre><code>T(n) = 2T(n/2) + O(n)

This is the same recurrence as merge sort!
Solution: T(n) = O(n log n)</code></pre>
<p><strong>Recursion tree:</strong></p>
<pre><code>                    n                    ← cn work
                /        \
              n/2        n/2             ← cn work
             /  \        /  \
          n/4  n/4    n/4  n/4           ← cn work
          ...  ...    ...  ...
          
Height: log n
Work per level: cn
Total: cn log n = O(n log n)</code></pre>
</section>
<section id="worst-case-on²" class="level4" data-number="3.5.6.2">
<h4 data-number="3.5.6.2" class="anchored" data-anchor-id="worst-case-on²"><span class="header-section-number">3.5.6.2</span> Worst Case: O(n²)</h4>
<p><strong>Occurs when:</strong> Pivot is always the smallest or largest element</p>
<p><strong>Example:</strong> Array is already sorted, we always pick the last element</p>
<pre><code>[1, 2, 3, 4, 5]
Pick 5 as pivot → partition into [1,2,3,4] and []
Pick 4 as pivot → partition into [1,2,3] and []
Pick 3 as pivot → partition into [1,2] and []
...</code></pre>
<p><strong>Recurrence:</strong></p>
<pre><code>T(n) = T(n-1) + O(n)
     = T(n-2) + O(n-1) + O(n)
     = T(n-3) + O(n-2) + O(n-1) + O(n)
     = ...
     = O(1) + O(2) + ... + O(n)
     = O(n²)</code></pre>
<p><strong>Recursion tree:</strong></p>
<pre><code>                    n                    ← cn work
                   /
                  n-1                    ← c(n-1) work
                 /
                n-2                      ← c(n-2) work
               /
              ...
             /
            1                            ← c work

Height: n
Total work: cn + c(n-1) + c(n-2) + ... + c
          = c(n + (n-1) + (n-2) + ... + 1)
          = c(n(n+1)/2)
          = O(n²)</code></pre>
<p><strong>This is bad!</strong> Same as bubble sort, selection sort, insertion sort.</p>
</section>
<section id="average-case-on-log-n" class="level4" data-number="3.5.6.3">
<h4 data-number="3.5.6.3" class="anchored" data-anchor-id="average-case-on-log-n"><span class="header-section-number">3.5.6.3</span> Average Case: O(n log n)</h4>
<p><strong>More complex analysis:</strong> Even with random pivots, average case is O(n log n)</p>
<p><strong>Intuition:</strong> On average, pivot will be somewhere in the middle 50% of values, giving reasonably balanced partitions.</p>
<p><strong>Formal analysis (simplified):</strong></p>
<ul>
<li>Probability of getting a “good” split (25%-75% or better): 50%</li>
<li>Expected number of levels until all partitions are “good”: O(log n)</li>
<li>Work per level: O(n)</li>
<li>Total: O(n log n)</li>
</ul>
<p><strong>Key insight:</strong> We don’t need perfect splits to get O(n log n) performance, just “reasonably balanced” ones!</p>
</section>
</section>
<section id="the-worst-case-problem-randomization-to-the-rescue" class="level3" data-number="3.5.7">
<h3 data-number="3.5.7" class="anchored" data-anchor-id="the-worst-case-problem-randomization-to-the-rescue"><span class="header-section-number">3.5.7</span> The Worst Case Problem: Randomization to the Rescue!</h3>
<p>The worst case O(n²) behavior is unacceptable for a production sorting algorithm. How do we avoid it?</p>
<p><strong>Solution: Randomized QuickSort</strong></p>
<p>Instead of always picking the last element as pivot, we pick a <strong>random element</strong>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> randomized_partition(arr, low, high):</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Partition with random pivot selection.</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">    This makes worst case O(n²) extremely unlikely.</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pick random index between low and high</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    random_index <span class="op">=</span> random.randint(low, high)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Swap random element with last element</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    arr[random_index], arr[high] <span class="op">=</span> arr[high], arr[random_index]</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Now proceed with standard partition</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> partition(arr, low, high)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> randomized_quicksort(arr, low<span class="op">=</span><span class="dv">0</span>, high<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="co">    QuickSort with randomized pivot selection.</span></span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a><span class="co">    Expected time: O(n log n) for ANY input</span></span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a><span class="co">    Worst case: O(n²) but with probability ≈ 0</span></span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> high <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>        high <span class="op">=</span> <span class="bu">len</span>(arr) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb27-29"><a href="#cb27-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> low <span class="op">&lt;</span> high:</span>
<span id="cb27-30"><a href="#cb27-30" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use randomized partition</span></span>
<span id="cb27-31"><a href="#cb27-31" aria-hidden="true" tabindex="-1"></a>        pivot_pos <span class="op">=</span> randomized_partition(arr, low, high)</span>
<span id="cb27-32"><a href="#cb27-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb27-33"><a href="#cb27-33" aria-hidden="true" tabindex="-1"></a>        randomized_quicksort(arr, low, pivot_pos <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb27-34"><a href="#cb27-34" aria-hidden="true" tabindex="-1"></a>        randomized_quicksort(arr, pivot_pos <span class="op">+</span> <span class="dv">1</span>, high)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why this works:</strong></p>
<p>With random pivot selection:</p>
<ul>
<li><strong>Probability of worst case:</strong> (1/n!)^(log n) ≈ astronomically small</li>
<li><strong>Expected running time:</strong> O(n log n) regardless of input order</li>
<li><strong>No bad inputs exist!</strong> Every input has the same expected performance</li>
</ul>
<p><strong>Practical impact:</strong></p>
<ul>
<li>Sorted array: O(n²) deterministic → O(n log n) randomized</li>
<li>Reverse sorted: O(n²) deterministic → O(n log n) randomized</li>
<li>Any adversarial input: O(n²) deterministic → O(n log n) randomized</li>
</ul>
<p>This is a powerful idea: <strong>randomization eliminates worst-case inputs!</strong></p>
</section>
<section id="alternative-pivot-selection-strategies" class="level3" data-number="3.5.8">
<h3 data-number="3.5.8" class="anchored" data-anchor-id="alternative-pivot-selection-strategies"><span class="header-section-number">3.5.8</span> Alternative Pivot Selection Strategies</h3>
<p>Besides randomization, other pivot selection methods exist:</p>
<p><strong>1. Median-of-Three:</strong></p>
<div class="sourceCode" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> median_of_three(arr, low, high):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Choose median of first, middle, and last elements as pivot.</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Good balance between performance and simplicity.</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> (low <span class="op">+</span> high) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort low, mid, high</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> arr[mid] <span class="op">&lt;</span> arr[low]:</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        arr[low], arr[mid] <span class="op">=</span> arr[mid], arr[low]</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> arr[high] <span class="op">&lt;</span> arr[low]:</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>        arr[low], arr[high] <span class="op">=</span> arr[high], arr[low]</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> arr[high] <span class="op">&lt;</span> arr[mid]:</span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>        arr[mid], arr[high] <span class="op">=</span> arr[high], arr[mid]</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Place median at high position</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>    arr[mid], arr[high] <span class="op">=</span> arr[high], arr[mid]</span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> arr[high]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Advantages:</strong></p>
<ul>
<li>More reliable than single random pick</li>
<li>Handles sorted/reverse-sorted arrays well</li>
<li>Only 2-3 comparisons overhead</li>
</ul>
<p><strong>2. Ninther (median-of-medians-of-three):</strong></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ninther(arr, low, high):</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Choose median of three medians.</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Used in high-performance implementations like Java's Arrays.sort</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Divide into 3 sections, find median of each</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    third <span class="op">=</span> (high <span class="op">-</span> low <span class="op">+</span> <span class="dv">1</span>) <span class="op">//</span> <span class="dv">3</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    m1 <span class="op">=</span> median_of_three(arr, low, low <span class="op">+</span> third)</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    m2 <span class="op">=</span> median_of_three(arr, low <span class="op">+</span> third, low <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>third)</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    m3 <span class="op">=</span> median_of_three(arr, low <span class="op">+</span> <span class="dv">2</span><span class="op">*</span>third, high)</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Return median of the three medians</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> median_of_three([m1, m2, m3], <span class="dv">0</span>, <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Advantages:</strong></p>
<ul>
<li>Even more robust against bad inputs</li>
<li>Good for large arrays</li>
<li>Used in production implementations</li>
</ul>
<p><strong>3. True Median (too expensive):</strong></p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co"># DON'T DO THIS in quicksort!</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> true_median(arr, low, high):</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Finding true median takes O(n) time... </span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="co">       but we're trying to SAVE time with good pivots!</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="co">       This defeats the purpose."""</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    sorted_section <span class="op">=</span> <span class="bu">sorted</span>(arr[low:high<span class="op">+</span><span class="dv">1</span>])</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sorted_section[<span class="bu">len</span>(sorted_section)<span class="op">//</span><span class="dv">2</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is counterproductive—we’re sorting to find a pivot to sort!</p>
</section>
<section id="quicksort-vs-merge-sort-the-showdown" class="level3" data-number="3.5.9">
<h3 data-number="3.5.9" class="anchored" data-anchor-id="quicksort-vs-merge-sort-the-showdown"><span class="header-section-number">3.5.9</span> QuickSort vs Merge Sort: The Showdown</h3>
<p>Let’s compare our two O(n log n) algorithms:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th>Criterion</th>
<th>Merge Sort</th>
<th>QuickSort</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Worst-case time</strong></td>
<td>O(n log n) ✓</td>
<td>O(n²) ✗ (but O(n log n) expected with randomization)</td>
</tr>
<tr class="even">
<td><strong>Best-case time</strong></td>
<td>O(n log n)</td>
<td>O(n log n) ✓</td>
</tr>
<tr class="odd">
<td><strong>Average-case time</strong></td>
<td>O(n log n)</td>
<td>O(n log n) ✓</td>
</tr>
<tr class="even">
<td><strong>Space complexity</strong></td>
<td>O(n)</td>
<td>O(log n) ✓</td>
</tr>
<tr class="odd">
<td><strong>In-place</strong></td>
<td>No ✗</td>
<td>Yes ✓</td>
</tr>
<tr class="even">
<td><strong>Stable</strong></td>
<td>Yes ✓</td>
<td>No ✗</td>
</tr>
<tr class="odd">
<td><strong>Practical speed</strong></td>
<td>Good</td>
<td>Excellent ✓</td>
</tr>
<tr class="even">
<td><strong>Cache performance</strong></td>
<td>Poor</td>
<td>Good ✓</td>
</tr>
<tr class="odd">
<td><strong>Parallelizable</strong></td>
<td>Yes ✓</td>
<td>Yes ✓</td>
</tr>
<tr class="even">
<td><strong>Adaptive</strong></td>
<td>No</td>
<td>Somewhat</td>
</tr>
</tbody>
</table>
<p><strong>When to use Merge Sort:</strong></p>
<ul>
<li>Need guaranteed O(n log n) time</li>
<li>Stability is required</li>
<li>External sorting (data doesn’t fit in memory)</li>
<li>Linked lists (can be done in O(1) space)</li>
<li>Need predictable performance</li>
</ul>
<p><strong>When to use QuickSort:</strong></p>
<ul>
<li>Arrays with random access</li>
<li>Space is limited</li>
<li>Want fastest average-case performance</li>
<li>Can use randomization</li>
<li>Most general-purpose sorting</li>
</ul>
<p><strong>Industry practice:</strong></p>
<ul>
<li><strong>C’s <code>qsort()</code>:</strong> QuickSort with median-of-three pivot</li>
<li><strong>Java’s <code>Arrays.sort()</code>:</strong>
<ul>
<li>Primitives: Dual-pivot QuickSort</li>
<li>Objects: TimSort (merge sort variant) for stability</li>
</ul></li>
<li><strong>Python’s <code>sorted()</code>:</strong> TimSort (adaptive merge sort)</li>
<li><strong>C++’s <code>std::sort()</code>:</strong> IntroSort (QuickSort + HeapSort + InsertionSort hybrid)</li>
</ul>
<p>Modern implementations use <strong>hybrid algorithms</strong> that combine the best features of multiple approaches!</p>
</section>
<section id="optimizing-quicksort-for-production" class="level3" data-number="3.5.10">
<h3 data-number="3.5.10" class="anchored" data-anchor-id="optimizing-quicksort-for-production"><span class="header-section-number">3.5.10</span> Optimizing QuickSort for Production</h3>
<p>Real-world implementations include several optimizations:</p>
<p><strong>Optimization 1: Switch to insertion sort for small partitions</strong></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>INSERTION_SORT_THRESHOLD <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quicksort_optimized(arr, low, high):</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""QuickSort with insertion sort for small partitions."""</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> low <span class="op">&lt;</span> high:</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use insertion sort for small partitions</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> high <span class="op">-</span> low <span class="op">&lt;</span> INSERTION_SORT_THRESHOLD:</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>            insertion_sort_range(arr, low, high)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>            pivot_pos <span class="op">=</span> randomized_partition(arr, low, high)</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>            quicksort_optimized(arr, low, pivot_pos <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>            quicksort_optimized(arr, pivot_pos <span class="op">+</span> <span class="dv">1</span>, high)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> insertion_sort_range(arr, low, high):</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Insertion sort for arr[low...high]."""</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(low <span class="op">+</span> <span class="dv">1</span>, high <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>        key <span class="op">=</span> arr[i]</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&gt;=</span> low <span class="kw">and</span> arr[j] <span class="op">&gt;</span> key:</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>            arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> arr[j]</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>        arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> key</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why this helps:</strong></p>
<ul>
<li>Reduces recursion overhead</li>
<li>Insertion sort is faster for small arrays</li>
<li>Typical speedup: 15-20%</li>
</ul>
<p><strong>Optimization 2: Three-way partitioning for duplicates</strong></p>
<p>Standard partition creates two regions: ≤ pivot and &gt; pivot. But what if we have many equal elements?</p>
<p><strong>Better approach: Dutch National Flag partitioning</strong></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> three_way_partition(arr, low, high):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Partition into three regions: &lt; pivot, = pivot, &gt; pivot</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Excellent for arrays with many duplicates.</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns: (lt, gt) where:</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co">        arr[low...lt-1] &lt; pivot</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co">        arr[lt...gt] = pivot  </span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="co">        arr[gt+1...high] &gt; pivot</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    pivot <span class="op">=</span> arr[low]</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    lt <span class="op">=</span> low      <span class="co"># Everything before lt is &lt; pivot</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> low <span class="op">+</span> <span class="dv">1</span>   <span class="co"># Current element being examined</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>    gt <span class="op">=</span> high     <span class="co"># Everything after gt is &gt; pivot</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;=</span> gt:</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr[i] <span class="op">&lt;</span> pivot:</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>            arr[lt], arr[i] <span class="op">=</span> arr[i], arr[lt]</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>            lt <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> arr[i] <span class="op">&gt;</span> pivot:</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>            arr[i], arr[gt] <span class="op">=</span> arr[gt], arr[i]</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>            gt <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:  <span class="co"># arr[i] == pivot</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lt, gt</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quicksort_3way(arr, low, high):</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""QuickSort with 3-way partitioning."""</span></span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> low <span class="op">&lt;</span> high:</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a>        lt, gt <span class="op">=</span> three_way_partition(arr, low, high)</span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a>        quicksort_3way(arr, low, lt <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a>        quicksort_3way(arr, gt <span class="op">+</span> <span class="dv">1</span>, high)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why this helps:</strong></p>
<ul>
<li>Elements equal to pivot are already in place (don’t need to recurse on them)</li>
<li>For arrays with many duplicates: massive speedup</li>
<li>Example: array of only 10 distinct values → nearly O(n) performance!</li>
</ul>
<p><strong>Optimization 3: Tail recursion elimination</strong></p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quicksort_iterative(arr, low, high):</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">    QuickSort with tail recursion eliminated.</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Reduces stack space from O(n) worst-case to O(log n).</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> low <span class="op">&lt;</span> high:</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        pivot_pos <span class="op">=</span> partition(arr, low, high)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Recurse on smaller partition, iterate on larger</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># This guarantees O(log n) stack depth</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pivot_pos <span class="op">-</span> low <span class="op">&lt;</span> high <span class="op">-</span> pivot_pos:</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>            quicksort_iterative(arr, low, pivot_pos <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>            low <span class="op">=</span> pivot_pos <span class="op">+</span> <span class="dv">1</span>  <span class="co"># Tail call replaced with iteration</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>            quicksort_iterative(arr, pivot_pos <span class="op">+</span> <span class="dv">1</span>, high)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>            high <span class="op">=</span> pivot_pos <span class="op">-</span> <span class="dv">1</span>  <span class="co"># Tail call replaced with iteration</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Why this helps:</strong></p>
<ul>
<li>Reduces stack space usage</li>
<li>Prevents stack overflow on worst-case inputs</li>
<li>Used in most production implementations</li>
</ul>
<hr>
</section>
</section>
<section id="section-2.4-recurrence-relations-and-the-master-theorem" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="section-2.4-recurrence-relations-and-the-master-theorem"><span class="header-section-number">3.6</span> Section 2.4: Recurrence Relations and The Master Theorem</h2>
<section id="why-we-need-better-analysis-tools" class="level3" data-number="3.6.1">
<h3 data-number="3.6.1" class="anchored" data-anchor-id="why-we-need-better-analysis-tools"><span class="header-section-number">3.6.1</span> Why We Need Better Analysis Tools</h3>
<p>So far, we’ve analyzed divide and conquer algorithms by:</p>
<ol type="1">
<li>Drawing recursion trees</li>
<li>Summing work at each level</li>
<li>Using substitution to verify guesses</li>
</ol>
<p>This works, but it’s tedious and error-prone. What if we had a <strong>formula</strong> that could instantly tell us the complexity of most divide and conquer algorithms?</p>
<p>Enter the <strong>Master Theorem</strong>—one of the most powerful tools in algorithm analysis.</p>
</section>
<section id="recurrence-relations-the-language-of-recursion" class="level3" data-number="3.6.2">
<h3 data-number="3.6.2" class="anchored" data-anchor-id="recurrence-relations-the-language-of-recursion"><span class="header-section-number">3.6.2</span> Recurrence Relations: The Language of Recursion</h3>
<p>A <strong>recurrence relation</strong> expresses the running time of a recursive algorithm in terms of its running time on smaller inputs.</p>
<p><strong>General form:</strong></p>
<pre><code>T(n) = aT(n/b) + f(n)

where:
  a = number of recursive subproblems
  b = factor by which problem size shrinks
  f(n) = work done outside recursive calls (divide + combine)</code></pre>
<p><strong>Examples we’ve seen:</strong></p>
<p><strong>Merge Sort:</strong></p>
<pre><code>T(n) = 2T(n/2) + O(n)

Explanation:
  - 2 recursive calls (a = 2)
  - Each on problem of size n/2 (b = 2)  
  - O(n) work to merge (f(n) = n)</code></pre>
<p><strong>QuickSort (best case):</strong></p>
<pre><code>T(n) = 2T(n/2) + O(n)

Same as merge sort!</code></pre>
<p><strong>Finding Maximum (divide &amp; conquer):</strong></p>
<pre><code>T(n) = 2T(n/2) + O(1)

Explanation:
  - 2 recursive calls (a = 2)
  - Each on size n/2 (b = 2)
  - O(1) to compare two values (f(n) = 1)</code></pre>
<p><strong>Binary Search:</strong></p>
<pre><code>T(n) = T(n/2) + O(1)

Explanation:
  - 1 recursive call (a = 1)
  - On problem size n/2 (b = 2)
  - O(1) to compare and choose side (f(n) = 1)</code></pre>
</section>
<section id="solving-recurrences-multiple-methods" class="level3" data-number="3.6.3">
<h3 data-number="3.6.3" class="anchored" data-anchor-id="solving-recurrences-multiple-methods"><span class="header-section-number">3.6.3</span> Solving Recurrences: Multiple Methods</h3>
<p>Before we get to the Master Theorem, let’s see other solution techniques:</p>
<section id="method-1-recursion-tree-visual" class="level4" data-number="3.6.3.1">
<h4 data-number="3.6.3.1" class="anchored" data-anchor-id="method-1-recursion-tree-visual"><span class="header-section-number">3.6.3.1</span> Method 1: Recursion Tree (Visual)</h4>
<p>We’ve used this already. Let’s formalize it:</p>
<p><strong>Example:</strong> T(n) = 2T(n/2) + cn</p>
<pre><code>Level 0:                cn                      Total: cn
Level 1:        cn/2         cn/2               Total: cn  
Level 2:    cn/4  cn/4   cn/4  cn/4            Total: cn
Level 3:  cn/8 cn/8... (8 terms)               Total: cn
...
Level log n: (n terms of c each)               Total: cn

Tree height: log₂(n)
Work per level: cn
Total work: cn × log n = O(n log n)</code></pre>
<p><strong>Steps:</strong></p>
<ol type="1">
<li>Draw tree showing how problem breaks down</li>
<li>Calculate work at each level</li>
<li>Sum across all levels</li>
<li>Multiply by tree height</li>
</ol>
</section>
<section id="method-2-substitution-guess-and-verify" class="level4" data-number="3.6.3.2">
<h4 data-number="3.6.3.2" class="anchored" data-anchor-id="method-2-substitution-guess-and-verify"><span class="header-section-number">3.6.3.2</span> Method 2: Substitution (Guess and Verify)</h4>
<p><strong>Steps:</strong></p>
<ol type="1">
<li>Guess the form of the solution</li>
<li>Use mathematical induction to prove it</li>
<li>Find constants that make it work</li>
</ol>
<p><strong>Example:</strong> T(n) = 2T(n/2) + n</p>
<p><strong>Guess:</strong> T(n) = O(n log n), so T(n) ≤ cn log n</p>
<p><strong>Proof by induction:</strong></p>
<p><em>Base case:</em> T(1) = c₁ ≤ c · 1 · log 1 = 0… This doesn’t work! We need T(1) ≤ c for some constant c.</p>
<p><em>Refined guess:</em> T(n) ≤ cn log n + d</p>
<p><em>Inductive step:</em></p>
<pre><code>T(n) = 2T(n/2) + n
     ≤ 2[c(n/2)log(n/2) + d] + n          [by hypothesis]
     = cn log(n/2) + 2d + n
     = cn(log n - 1) + 2d + n
     = cn log n - cn + 2d + n
     = cn log n + (2d + n - cn)

For this ≤ cn log n + d, we need:
     2d + n - cn ≤ d
     d + n ≤ cn
     
Choose c large enough that cn ≥ n + d for all n ≥ n₀
This works! ✓</code></pre>
<p>Therefore T(n) = O(n log n) ✓</p>
<p>This method works but requires good intuition about what to guess!</p>
</section>
<section id="method-3-master-theorem-the-power-tool" class="level4" data-number="3.6.3.3">
<h4 data-number="3.6.3.3" class="anchored" data-anchor-id="method-3-master-theorem-the-power-tool"><span class="header-section-number">3.6.3.3</span> Method 3: Master Theorem (The Power Tool!)</h4>
<p>The Master Theorem provides a cookbook for solving many common recurrences instantly.</p>
</section>
</section>
<section id="the-master-theorem" class="level3" data-number="3.6.4">
<h3 data-number="3.6.4" class="anchored" data-anchor-id="the-master-theorem"><span class="header-section-number">3.6.4</span> The Master Theorem</h3>
<p><strong>Theorem:</strong> Let a ≥ 1 and b &gt; 1 be constants, let f(n) be a function, and let T(n) be defined on non-negative integers by the recurrence:</p>
<pre><code>T(n) = aT(n/b) + f(n)</code></pre>
<p>Then T(n) has the following asymptotic bounds:</p>
<p><strong>Case 1:</strong> If f(n) = O(n^(log_b(a) - ε)) for some constant ε &gt; 0, then:</p>
<pre><code>T(n) = Θ(n^(log_b(a)))</code></pre>
<p><strong>Case 2:</strong> If f(n) = Θ(n^(log_b(a))), then:</p>
<pre><code>T(n) = Θ(n^(log_b(a)) log n)</code></pre>
<p><strong>Case 3:</strong> If f(n) = Ω(n^(log_b(a) + ε)) for some constant ε &gt; 0, AND if af(n/b) ≤ cf(n) for some constant c &lt; 1 and sufficiently large n, then:</p>
<pre><code>T(n) = Θ(f(n))</code></pre>
<p><strong>Whoa! That’s a lot of notation. Let’s break it down…</strong></p>
</section>
<section id="understanding-the-master-theorem-intuitively" class="level3" data-number="3.6.5">
<h3 data-number="3.6.5" class="anchored" data-anchor-id="understanding-the-master-theorem-intuitively"><span class="header-section-number">3.6.5</span> Understanding the Master Theorem Intuitively</h3>
<p>The Master Theorem compares two quantities:</p>
<ol type="1">
<li><strong>Work done by recursive calls:</strong> n^(log_b(a))</li>
<li><strong>Work done outside recursion:</strong> f(n)</li>
</ol>
<p><strong>The critical exponent:</strong> log_b(a)</p>
<p>This represents how fast the number of subproblems grows relative to how fast the problem size shrinks.</p>
<p><strong>Intuition:</strong></p>
<ul>
<li><strong>Case 1:</strong> Recursion dominates → Answer is Θ(n^(log_b(a)))</li>
<li><strong>Case 2:</strong> Recursion and f(n) are balanced → Answer is Θ(n^(log_b(a)) log n)</li>
<li><strong>Case 3:</strong> f(n) dominates → Answer is Θ(f(n))</li>
</ul>
<p><strong>Think of it like a tug-of-war:</strong></p>
<ul>
<li>Recursive work pulls one way</li>
<li>Non-recursive work pulls the other way</li>
<li>Whichever is asymptotically larger wins!</li>
</ul>
</section>
<section id="master-theorem-examples" class="level3" data-number="3.6.6">
<h3 data-number="3.6.6" class="anchored" data-anchor-id="master-theorem-examples"><span class="header-section-number">3.6.6</span> Master Theorem Examples</h3>
<p>Let’s apply the Master Theorem to algorithms we know:</p>
<section id="example-1-merge-sort" class="level4" data-number="3.6.6.1">
<h4 data-number="3.6.6.1" class="anchored" data-anchor-id="example-1-merge-sort"><span class="header-section-number">3.6.6.1</span> Example 1: Merge Sort</h4>
<p><strong>Recurrence:</strong> T(n) = 2T(n/2) + n</p>
<p><strong>Identify parameters:</strong></p>
<ul>
<li>a = 2 (two recursive calls)</li>
<li>b = 2 (problem size halves)</li>
<li>f(n) = n</li>
</ul>
<p><strong>Calculate critical exponent:</strong></p>
<pre><code>log_b(a) = log₂(2) = 1</code></pre>
<p><strong>Compare f(n) with n^(log_b(a)):</strong></p>
<pre><code>f(n) = n
n^(log_b(a)) = n¹ = n

f(n) = Θ(n^(log_b(a)))  ← They're equal!</code></pre>
<p><strong>This is Case 2!</strong></p>
<p><strong>Solution:</strong></p>
<pre><code>T(n) = Θ(n^(log_b(a)) log n)
     = Θ(n¹ log n)
     = Θ(n log n) ✓</code></pre>
<p>Matches what we found before!</p>
</section>
<section id="example-2-binary-search" class="level4" data-number="3.6.6.2">
<h4 data-number="3.6.6.2" class="anchored" data-anchor-id="example-2-binary-search"><span class="header-section-number">3.6.6.2</span> Example 2: Binary Search</h4>
<p><strong>Recurrence:</strong> T(n) = T(n/2) + O(1)</p>
<p><strong>Identify parameters:</strong></p>
<ul>
<li>a = 1</li>
<li>b = 2</li>
<li>f(n) = 1</li>
</ul>
<p><strong>Calculate critical exponent:</strong></p>
<pre><code>log_b(a) = log₂(1) = 0</code></pre>
<p><strong>Compare:</strong></p>
<pre><code>f(n) = 1 = Θ(1)
n^(log_b(a)) = n⁰ = 1

f(n) = Θ(n^(log_b(a)))  ← Equal again!</code></pre>
<p><strong>This is Case 2!</strong></p>
<p><strong>Solution:</strong></p>
<pre><code>T(n) = Θ(n⁰ log n) = Θ(log n) ✓</code></pre>
<p>Perfect! Binary search is O(log n).</p>
</section>
<section id="example-3-finding-maximum-divide-conquer" class="level4" data-number="3.6.6.3">
<h4 data-number="3.6.6.3" class="anchored" data-anchor-id="example-3-finding-maximum-divide-conquer"><span class="header-section-number">3.6.6.3</span> Example 3: Finding Maximum (Divide &amp; Conquer)</h4>
<p><strong>Recurrence:</strong> T(n) = 2T(n/2) + O(1)</p>
<p><strong>Identify parameters:</strong></p>
<ul>
<li>a = 2</li>
<li>b = 2</li>
<li>f(n) = 1</li>
</ul>
<p><strong>Calculate critical exponent:</strong></p>
<pre><code>log_b(a) = log₂(2) = 1</code></pre>
<p><strong>Compare:</strong></p>
<pre><code>f(n) = 1 = O(n⁰)
n^(log_b(a)) = n¹ = n

f(n) = O(n^(1-ε)) for ε = 1  ← f(n) is polynomially smaller!</code></pre>
<p><strong>This is Case 1!</strong></p>
<p><strong>Solution:</strong></p>
<pre><code>T(n) = Θ(n^(log_b(a)))
     = Θ(n¹)
     = Θ(n) ✓</code></pre>
<p>Makes sense! We still need to look at every element.</p>
</section>
<section id="example-4-strassens-matrix-multiplication-preview" class="level4" data-number="3.6.6.4">
<h4 data-number="3.6.6.4" class="anchored" data-anchor-id="example-4-strassens-matrix-multiplication-preview"><span class="header-section-number">3.6.6.4</span> Example 4: Strassen’s Matrix Multiplication (Preview)</h4>
<p><strong>Recurrence:</strong> T(n) = 7T(n/2) + O(n²)</p>
<p><strong>Identify parameters:</strong></p>
<ul>
<li>a = 7 (seven recursive multiplications)</li>
<li>b = 2 (matrices split into quadrants)</li>
<li>f(n) = n² (combining results)</li>
</ul>
<p><strong>Calculate critical exponent:</strong></p>
<pre><code>log_b(a) = log₂(7) ≈ 2.807</code></pre>
<p><strong>Compare:</strong></p>
<pre><code>f(n) = n² = O(n²)
n^(log_b(a)) = n^2.807

f(n) = O(n^(2.807 - ε)) for ε ≈ 0.807  ← f(n) is smaller!</code></pre>
<p><strong>This is Case 1!</strong></p>
<p><strong>Solution:</strong></p>
<pre><code>T(n) = Θ(n^(log₂(7)))
     = Θ(n^2.807) ✓</code></pre>
<p>Better than naive O(n³) matrix multiplication!</p>
</section>
<section id="example-5-a-contrived-case-3-example" class="level4" data-number="3.6.6.5">
<h4 data-number="3.6.6.5" class="anchored" data-anchor-id="example-5-a-contrived-case-3-example"><span class="header-section-number">3.6.6.5</span> Example 5: A Contrived Case 3 Example</h4>
<p><strong>Recurrence:</strong> T(n) = 2T(n/2) + n²</p>
<p><strong>Identify parameters:</strong></p>
<ul>
<li>a = 2</li>
<li>b = 2</li>
<li>f(n) = n²</li>
</ul>
<p><strong>Calculate critical exponent:</strong></p>
<pre><code>log_b(a) = log₂(2) = 1</code></pre>
<p><strong>Compare:</strong></p>
<pre><code>f(n) = n²
n^(log_b(a)) = n¹ = n

f(n) = Ω(n^(1+ε)) for ε = 1  ← f(n) is polynomially larger!</code></pre>
<p><strong>Check regularity condition:</strong> af(n/b) ≤ cf(n)</p>
<pre><code>2·(n/2)² ≤ c·n²
2·n²/4 ≤ c·n²
n²/2 ≤ c·n²

Choose c = 1/2, this works! ✓</code></pre>
<p><strong>This is Case 3!</strong></p>
<p><strong>Solution:</strong></p>
<pre><code>T(n) = Θ(f(n))
     = Θ(n²) ✓</code></pre>
<p>The quadratic work outside recursion dominates!</p>
</section>
</section>
<section id="when-master-theorem-doesnt-apply" class="level3" data-number="3.6.7">
<h3 data-number="3.6.7" class="anchored" data-anchor-id="when-master-theorem-doesnt-apply"><span class="header-section-number">3.6.7</span> When Master Theorem Doesn’t Apply</h3>
<p>The Master Theorem is powerful but not universal. It <strong>cannot</strong> be used when:</p>
<p><strong>1. f(n) is not polynomially larger or smaller</strong></p>
<p><strong>Example:</strong> T(n) = 2T(n/2) + n log n</p>
<pre><code>log_b(a) = log₂(2) = 1
f(n) = n log n
n^(log_b(a)) = n

Compare: n log n vs n
n log n is larger, but not POLYNOMIALLY larger
(not Ω(n^(1+ε)) for any ε &gt; 0)

Master Theorem doesn't apply! ❌
Need recursion tree or substitution method.</code></pre>
<p><strong>2. Subproblems are not equal size</strong></p>
<p><strong>Example:</strong> T(n) = T(n/3) + T(2n/3) + n</p>
<pre><code>Subproblems of different sizes!
Master Theorem doesn't apply! ❌</code></pre>
<p><strong>3. Non-standard recurrence forms</strong></p>
<p><strong>Example:</strong> T(n) = 2T(n/2) + n/log n</p>
<pre><code>f(n) involves log n in denominator
Doesn't fit standard comparison
Master Theorem doesn't apply! ❌</code></pre>
<p><strong>4. Regularity condition fails (Case 3)</strong></p>
<p><strong>Example:</strong> T(n) = 2T(n/2) + n²/log n</p>
<pre><code>log_b(a) = 1
f(n) = n²/log n is larger than n

But checking regularity: 2(n/2)²/log(n/2) ≤ c·n²/log n?
2n²/(4 log(n/2)) ≤ c·n²/log n
n²/(2 log(n/2)) ≤ c·n²/log n

This doesn't work for constant c! ❌</code></pre>
</section>
<section id="master-theorem-cheat-sheet" class="level3" data-number="3.6.8">
<h3 data-number="3.6.8" class="anchored" data-anchor-id="master-theorem-cheat-sheet"><span class="header-section-number">3.6.8</span> Master Theorem Cheat Sheet</h3>
<p>Here’s a quick reference for applying the Master Theorem:</p>
<p><strong>Given:</strong> T(n) = aT(n/b) + f(n)</p>
<p><strong>Step 1:</strong> Calculate critical exponent</p>
<pre><code>E = log_b(a)</code></pre>
<p><strong>Step 2:</strong> Compare f(n) with n^E</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Comparison</th>
<th>Case</th>
<th>Solution</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>f(n) = O(n^(E-ε)), ε &gt; 0</td>
<td>Case 1</td>
<td>T(n) = Θ(n^E)</td>
</tr>
<tr class="even">
<td>f(n) = Θ(n^E)</td>
<td>Case 2</td>
<td>T(n) = Θ(n^E log n)</td>
</tr>
<tr class="odd">
<td>f(n) = Ω(n^(E+ε)), ε &gt; 0<br>AND regularity holds</td>
<td>Case 3</td>
<td>T(n) = Θ(f(n))</td>
</tr>
</tbody>
</table>
<p><strong>Quick identification tricks:</strong></p>
<p><strong>Case 1 (Recursion dominates):</strong></p>
<ul>
<li>Many subproblems (large a)</li>
<li>Small f(n)</li>
<li>Example: T(n) = 8T(n/2) + n²</li>
</ul>
<p><strong>Case 2 (Perfect balance):</strong></p>
<ul>
<li>Balanced growth</li>
<li>f(n) exactly matches recursive work</li>
<li>Most common in practice</li>
<li>Example: Merge sort, binary search</li>
</ul>
<p><strong>Case 3 (Non-recursive work dominates):</strong></p>
<ul>
<li>Few subproblems (small a)</li>
<li>Large f(n)</li>
<li>Example: T(n) = 2T(n/2) + n²</li>
</ul>
</section>
<section id="practice-problems" class="level3" data-number="3.6.9">
<h3 data-number="3.6.9" class="anchored" data-anchor-id="practice-problems"><span class="header-section-number">3.6.9</span> Practice Problems</h3>
<p><strong>Try these yourself!</strong></p>
<ol type="1">
<li>T(n) = 4T(n/2) + n</li>
<li>T(n) = 4T(n/2) + n²</li>
<li>T(n) = 4T(n/2) + n³</li>
<li>T(n) = T(n/2) + n</li>
<li>T(n) = 16T(n/4) + n</li>
<li>T(n) = 9T(n/3) + n²</li>
</ol>
<details>
<summary>
Solutions (click to reveal)
</summary>
<ol type="1">
<li><p><strong>T(n) = 4T(n/2) + n</strong></p>
<ul>
<li>a=4, b=2, f(n)=n, log₂(4)=2</li>
<li>f(n) = O(n^(2-ε)), Case 1</li>
<li><strong>Answer: Θ(n²)</strong></li>
</ul></li>
<li><p><strong>T(n) = 4T(n/2) + n²</strong></p>
<ul>
<li>a=4, b=2, f(n)=n², log₂(4)=2</li>
<li>f(n) = Θ(n²), Case 2</li>
<li><strong>Answer: Θ(n² log n)</strong></li>
</ul></li>
<li><p><strong>T(n) = 4T(n/2) + n³</strong></p>
<ul>
<li>a=4, b=2, f(n)=n³, log₂(4)=2</li>
<li>f(n) = Ω(n^(2+ε)), Case 3</li>
<li>Check: 4(n/2)³ = n³/2 ≤ c·n³ ✓</li>
<li><strong>Answer: Θ(n³)</strong></li>
</ul></li>
<li><p><strong>T(n) = T(n/2) + n</strong></p>
<ul>
<li>a=1, b=2, f(n)=n, log₂(1)=0</li>
<li>f(n) = Ω(n^(0+ε)), Case 3</li>
<li>Check: 1·(n/2) ≤ c·n ✓</li>
<li><strong>Answer: Θ(n)</strong></li>
</ul></li>
<li><p><strong>T(n) = 16T(n/4) + n</strong></p>
<ul>
<li>a=16, b=4, f(n)=n, log₄(16)=2</li>
<li>f(n) = O(n^(2-ε)), Case 1</li>
<li><strong>Answer: Θ(n²)</strong></li>
</ul></li>
<li><p><strong>T(n) = 9T(n/3) + n²</strong></p>
<ul>
<li>a=9, b=3, f(n)=n², log₃(9)=2</li>
<li>f(n) = Θ(n²), Case 2</li>
<li><strong>Answer: Θ(n² log n)</strong></li>
</ul></li>
</ol>
</details>
</section>
<section id="beyond-the-master-theorem-advanced-recurrence-solving" class="level3" data-number="3.6.10">
<h3 data-number="3.6.10" class="anchored" data-anchor-id="beyond-the-master-theorem-advanced-recurrence-solving"><span class="header-section-number">3.6.10</span> Beyond the Master Theorem: Advanced Recurrence Solving</h3>
<p>For recurrences that don’t fit the Master Theorem, we have additional techniques:</p>
<section id="akra-bazzi-method-generalized-master-theorem" class="level4" data-number="3.6.10.1">
<h4 data-number="3.6.10.1" class="anchored" data-anchor-id="akra-bazzi-method-generalized-master-theorem"><span class="header-section-number">3.6.10.1</span> Akra-Bazzi Method (Generalized Master Theorem)</h4>
<p>Handles unequal subproblem sizes:</p>
<pre><code>T(n) = T(n/3) + T(2n/3) + n

Solution: Still Θ(n log n) using Akra-Bazzi</code></pre>
</section>
<section id="generating-functions" class="level4" data-number="3.6.10.2">
<h4 data-number="3.6.10.2" class="anchored" data-anchor-id="generating-functions"><span class="header-section-number">3.6.10.2</span> Generating Functions</h4>
<p>For more complex recurrences:</p>
<pre><code>T(n) = T(n-1) + T(n-2) + n

This is like Fibonacci with extra term!</code></pre>
</section>
<section id="recursion-tree-for-irregular-patterns" class="level4" data-number="3.6.10.3">
<h4 data-number="3.6.10.3" class="anchored" data-anchor-id="recursion-tree-for-irregular-patterns"><span class="header-section-number">3.6.10.3</span> Recursion Tree for Irregular Patterns</h4>
<p>When all else fails, draw the tree and sum carefully.</p>
<hr>
</section>
</section>
</section>
<section id="section-2.5-advanced-applications-and-case-studies" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="section-2.5-advanced-applications-and-case-studies"><span class="header-section-number">3.7</span> Section 2.5: Advanced Applications and Case Studies</h2>
<section id="beyond-sorting-where-divide-and-conquer-shines" class="level3" data-number="3.7.1">
<h3 data-number="3.7.1" class="anchored" data-anchor-id="beyond-sorting-where-divide-and-conquer-shines"><span class="header-section-number">3.7.1</span> Beyond Sorting: Where Divide and Conquer Shines</h3>
<p>Now that we understand the paradigm deeply, let’s explore fascinating applications beyond sorting.</p>
</section>
<section id="application-1-fast-integer-multiplication-karatsuba-algorithm" class="level3" data-number="3.7.2">
<h3 data-number="3.7.2" class="anchored" data-anchor-id="application-1-fast-integer-multiplication-karatsuba-algorithm"><span class="header-section-number">3.7.2</span> Application 1: Fast Integer Multiplication (Karatsuba Algorithm)</h3>
<p><strong>Problem:</strong> Multiply two n-digit numbers</p>
<p><strong>Naive approach:</strong> Grade-school multiplication</p>
<pre><code>  1234
×  5678
------
T(n) = O(n²) operations</code></pre>
<p><strong>Divide and conquer approach:</strong></p>
<p>Split each n-digit number into two halves:</p>
<pre><code>x = x₁ · 10^(n/2) + x₀
y = y₁ · 10^(n/2) + y₀

Example: 1234 = 12 · 10² + 34</code></pre>
<p><strong>Naive recursive multiplication:</strong></p>
<pre><code>xy = (x₁ · 10^(n/2) + x₀)(y₁ · 10^(n/2) + y₀)
   = x₁y₁ · 10^n + (x₁y₀ + x₀y₁) · 10^(n/2) + x₀y₀

Requires 4 multiplications:
- x₁y₁
- x₁y₀  
- x₀y₁
- x₀y₀

Recurrence: T(n) = 4T(n/2) + O(n)
Solution: Θ(n²) - no improvement! ❌</code></pre>
<p><strong>Karatsuba’s insight (1960):</strong> Compute the middle term differently!</p>
<pre><code>(x₁y₀ + x₀y₁) = (x₁ + x₀)(y₁ + y₀) - x₁y₁ - x₀y₀

Now we only need 3 multiplications:
- z₀ = x₀y₀
- z₂ = x₁y₁
- z₁ = (x₁ + x₀)(y₁ + y₀) - z₂ - z₀

Result: z₂ · 10^n + z₁ · 10^(n/2) + z₀</code></pre>
<p><strong>Implementation:</strong></p>
<div class="sourceCode" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> karatsuba(x, y):</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Fast integer multiplication using Karatsuba algorithm.</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Time Complexity: O(n^log₂(3)) ≈ O(n^1.585)</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Much better than O(n²) for large numbers!</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a><span class="co">        x, y: Integers to multiply</span></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a><span class="co">        Product x * y</span></span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case for recursion</span></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">10</span> <span class="kw">or</span> y <span class="op">&lt;</span> <span class="dv">10</span>:</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x <span class="op">*</span> y</span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate number of digits</span></span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">max</span>(<span class="bu">len</span>(<span class="bu">str</span>(x)), <span class="bu">len</span>(<span class="bu">str</span>(y)))</span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>    half <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Split numbers into halves</span></span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a>    power <span class="op">=</span> <span class="dv">10</span> <span class="op">**</span> half</span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>    x1, x0 <span class="op">=</span> <span class="bu">divmod</span>(x, power)</span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>    y1, y0 <span class="op">=</span> <span class="bu">divmod</span>(y, power)</span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Three recursive multiplications</span></span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>    z0 <span class="op">=</span> karatsuba(x0, y0)</span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a>    z2 <span class="op">=</span> karatsuba(x1, y1)</span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a>    z1 <span class="op">=</span> karatsuba(x1 <span class="op">+</span> x0, y1 <span class="op">+</span> y0) <span class="op">-</span> z2 <span class="op">-</span> z0</span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine results</span></span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> z2 <span class="op">*</span> (<span class="dv">10</span> <span class="op">**</span> (<span class="dv">2</span> <span class="op">*</span> half)) <span class="op">+</span> z1 <span class="op">*</span> (<span class="dv">10</span> <span class="op">**</span> half) <span class="op">+</span> z0</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Analysis:</strong></p>
<pre><code>Recurrence: T(n) = 3T(n/2) + O(n)

Using Master Theorem:
a = 3, b = 2, f(n) = n
log₂(3) ≈ 1.585

f(n) = O(n^(1.585 - ε)), Case 1

Solution: T(n) = Θ(n^log₂(3)) ≈ Θ(n^1.585) ✓</code></pre>
<p><strong>Impact:</strong></p>
<ul>
<li>For 1000-digit numbers: ~3× faster than naive</li>
<li>For 10,000-digit numbers: ~10× faster</li>
<li>For 1,000,000-digit numbers: ~300× faster!</li>
</ul>
<p>Used in cryptography for large prime multiplication!</p>
</section>
<section id="application-2-closest-pair-of-points" class="level3" data-number="3.7.3">
<h3 data-number="3.7.3" class="anchored" data-anchor-id="application-2-closest-pair-of-points"><span class="header-section-number">3.7.3</span> Application 2: Closest Pair of Points</h3>
<p><strong>Problem:</strong> Given n points in a plane, find the two closest points.</p>
<p><strong>Naive approach:</strong></p>
<div class="sourceCode" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closest_pair_naive(points):</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Check all pairs - O(n²)"""</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    min_dist <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>            dist <span class="op">=</span> distance(points[i], points[j])</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>            min_dist <span class="op">=</span> <span class="bu">min</span>(min_dist, dist)</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_dist</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Divide and conquer approach: O(n log n)</strong></p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> distance(p1, p2):</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Euclidean distance between two points."""</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> math.sqrt((p1[<span class="dv">0</span>] <span class="op">-</span> p2[<span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (p1[<span class="dv">1</span>] <span class="op">-</span> p2[<span class="dv">1</span>])<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> closest_pair_divide_conquer(points):</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Find closest pair using divide and conquer.</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Time Complexity: O(n log n)</span></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Algorithm:</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a><span class="co">    1. Sort points by x-coordinate</span></span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a><span class="co">    2. Divide into left and right halves</span></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a><span class="co">    3. Recursively find closest in each half</span></span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a><span class="co">    4. Check for closer pairs crossing the dividing line</span></span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Preprocessing: sort by x-coordinate</span></span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a>    points_sorted_x <span class="op">=</span> <span class="bu">sorted</span>(points, key<span class="op">=</span><span class="kw">lambda</span> p: p[<span class="dv">0</span>])</span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a>    points_sorted_y <span class="op">=</span> <span class="bu">sorted</span>(points, key<span class="op">=</span><span class="kw">lambda</span> p: p[<span class="dv">1</span>])</span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> _closest_pair_recursive(points_sorted_x, points_sorted_y)</span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-26"><a href="#cb75-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-27"><a href="#cb75-27" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _closest_pair_recursive(px, py):</span>
<span id="cb75-28"><a href="#cb75-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb75-29"><a href="#cb75-29" aria-hidden="true" tabindex="-1"></a><span class="co">    Recursive helper function.</span></span>
<span id="cb75-30"><a href="#cb75-30" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb75-31"><a href="#cb75-31" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb75-32"><a href="#cb75-32" aria-hidden="true" tabindex="-1"></a><span class="co">        px: Points sorted by x-coordinate</span></span>
<span id="cb75-33"><a href="#cb75-33" aria-hidden="true" tabindex="-1"></a><span class="co">        py: Points sorted by y-coordinate</span></span>
<span id="cb75-34"><a href="#cb75-34" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb75-35"><a href="#cb75-35" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(px)</span>
<span id="cb75-36"><a href="#cb75-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-37"><a href="#cb75-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: use brute force for small inputs</span></span>
<span id="cb75-38"><a href="#cb75-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">3</span>:</span>
<span id="cb75-39"><a href="#cb75-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> _brute_force_closest(px)</span>
<span id="cb75-40"><a href="#cb75-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-41"><a href="#cb75-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># DIVIDE: Split at median x-coordinate</span></span>
<span id="cb75-42"><a href="#cb75-42" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb75-43"><a href="#cb75-43" aria-hidden="true" tabindex="-1"></a>    midpoint <span class="op">=</span> px[mid]</span>
<span id="cb75-44"><a href="#cb75-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-45"><a href="#cb75-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Split into left and right halves</span></span>
<span id="cb75-46"><a href="#cb75-46" aria-hidden="true" tabindex="-1"></a>    pyl <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> py <span class="cf">if</span> p[<span class="dv">0</span>] <span class="op">&lt;=</span> midpoint[<span class="dv">0</span>]]</span>
<span id="cb75-47"><a href="#cb75-47" aria-hidden="true" tabindex="-1"></a>    pyr <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> py <span class="cf">if</span> p[<span class="dv">0</span>] <span class="op">&gt;</span> midpoint[<span class="dv">0</span>]]</span>
<span id="cb75-48"><a href="#cb75-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-49"><a href="#cb75-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># CONQUER: Find closest in each half</span></span>
<span id="cb75-50"><a href="#cb75-50" aria-hidden="true" tabindex="-1"></a>    dl <span class="op">=</span> _closest_pair_recursive(px[:mid], pyl)</span>
<span id="cb75-51"><a href="#cb75-51" aria-hidden="true" tabindex="-1"></a>    dr <span class="op">=</span> _closest_pair_recursive(px[mid:], pyr)</span>
<span id="cb75-52"><a href="#cb75-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-53"><a href="#cb75-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Minimum of the two sides</span></span>
<span id="cb75-54"><a href="#cb75-54" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> <span class="bu">min</span>(dl, dr)</span>
<span id="cb75-55"><a href="#cb75-55" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-56"><a href="#cb75-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># COMBINE: Check for closer pairs across dividing line</span></span>
<span id="cb75-57"><a href="#cb75-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Only need to check points within distance d of dividing line</span></span>
<span id="cb75-58"><a href="#cb75-58" aria-hidden="true" tabindex="-1"></a>    strip <span class="op">=</span> [p <span class="cf">for</span> p <span class="kw">in</span> py <span class="cf">if</span> <span class="bu">abs</span>(p[<span class="dv">0</span>] <span class="op">-</span> midpoint[<span class="dv">0</span>]) <span class="op">&lt;</span> d]</span>
<span id="cb75-59"><a href="#cb75-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-60"><a href="#cb75-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find closest pair in strip</span></span>
<span id="cb75-61"><a href="#cb75-61" aria-hidden="true" tabindex="-1"></a>    d_strip <span class="op">=</span> _strip_closest(strip, d)</span>
<span id="cb75-62"><a href="#cb75-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-63"><a href="#cb75-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(d, d_strip)</span>
<span id="cb75-64"><a href="#cb75-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-65"><a href="#cb75-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-66"><a href="#cb75-66" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _brute_force_closest(points):</span>
<span id="cb75-67"><a href="#cb75-67" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Brute force for small inputs."""</span></span>
<span id="cb75-68"><a href="#cb75-68" aria-hidden="true" tabindex="-1"></a>    min_dist <span class="op">=</span> <span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb75-69"><a href="#cb75-69" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(points)</span>
<span id="cb75-70"><a href="#cb75-70" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-71"><a href="#cb75-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb75-72"><a href="#cb75-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb75-73"><a href="#cb75-73" aria-hidden="true" tabindex="-1"></a>            min_dist <span class="op">=</span> <span class="bu">min</span>(min_dist, distance(points[i], points[j]))</span>
<span id="cb75-74"><a href="#cb75-74" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-75"><a href="#cb75-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_dist</span>
<span id="cb75-76"><a href="#cb75-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-77"><a href="#cb75-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-78"><a href="#cb75-78" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _strip_closest(strip, d):</span>
<span id="cb75-79"><a href="#cb75-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb75-80"><a href="#cb75-80" aria-hidden="true" tabindex="-1"></a><span class="co">    Find closest pair in vertical strip.</span></span>
<span id="cb75-81"><a href="#cb75-81" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb75-82"><a href="#cb75-82" aria-hidden="true" tabindex="-1"></a><span class="co">    Key insight: For each point, only need to check next 7 points!</span></span>
<span id="cb75-83"><a href="#cb75-83" aria-hidden="true" tabindex="-1"></a><span class="co">    (Proven geometrically)</span></span>
<span id="cb75-84"><a href="#cb75-84" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb75-85"><a href="#cb75-85" aria-hidden="true" tabindex="-1"></a>    min_dist <span class="op">=</span> d</span>
<span id="cb75-86"><a href="#cb75-86" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-87"><a href="#cb75-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(strip)):</span>
<span id="cb75-88"><a href="#cb75-88" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Only check next 7 points (geometric bound)</span></span>
<span id="cb75-89"><a href="#cb75-89" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb75-90"><a href="#cb75-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&lt;</span> <span class="bu">len</span>(strip) <span class="kw">and</span> (strip[j][<span class="dv">1</span>] <span class="op">-</span> strip[i][<span class="dv">1</span>]) <span class="op">&lt;</span> min_dist:</span>
<span id="cb75-91"><a href="#cb75-91" aria-hidden="true" tabindex="-1"></a>            min_dist <span class="op">=</span> <span class="bu">min</span>(min_dist, distance(strip[i], strip[j]))</span>
<span id="cb75-92"><a href="#cb75-92" aria-hidden="true" tabindex="-1"></a>            j <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb75-93"><a href="#cb75-93" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb75-94"><a href="#cb75-94" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_dist</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Key insight:</strong> In the strip, each point only needs to check ~7 neighbors!</p>
<p><strong>Geometric proof:</strong> Given a point p in the strip and distance d:</p>
<ul>
<li>Points must be within d vertically from p</li>
<li>Points must be within d horizontally from dividing line</li>
<li>This creates a 2d × d rectangle</li>
<li>Both halves have no points closer than d</li>
<li>At most 8 points can fit in this region (pigeon-hole principle)</li>
</ul>
<p><strong>Analysis:</strong></p>
<pre><code>Recurrence: T(n) = 2T(n/2) + O(n)
            (sorting strip takes O(n))

Master Theorem Case 2:
T(n) = Θ(n log n) ✓</code></pre>
</section>
<section id="application-3-matrix-multiplication-strassens-algorithm" class="level3" data-number="3.7.4">
<h3 data-number="3.7.4" class="anchored" data-anchor-id="application-3-matrix-multiplication-strassens-algorithm"><span class="header-section-number">3.7.4</span> Application 3: Matrix Multiplication (Strassen’s Algorithm)</h3>
<p><strong>Problem:</strong> Multiply two n×n matrices</p>
<p><strong>Naive approach:</strong> Three nested loops</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> naive_matrix_multiply(A, B):</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Standard matrix multiplication - O(n³)"""</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>                C[i][j] <span class="op">+=</span> A[i][k] <span class="op">*</span> B[k][j]</span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> C</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Divide and conquer (naive):</strong></p>
<p>Split each matrix into 4 quadrants:</p>
<pre><code>[A B] × [E F] = [AE+BG  AF+BH]
[C D]   [G H]   [CE+DG  CF+DH]

Requires 8 multiplications!
T(n) = 8T(n/2) + O(n²)
     = Θ(n³) - no improvement! ❌</code></pre>
<p><strong>Strassen’s algorithm (1969):</strong> Use only 7 multiplications!</p>
<pre><code>Define 7 products:
M₁ = (A + D)(E + H)
M₂ = (C + D)E
M₃ = A(F - H)
M₄ = D(G - E)
M₅ = (A + B)H
M₆ = (C - A)(E + F)
M₇ = (B - D)(G + H)

Result:
[M₁ + M₄ - M₅ + M₇    M₃ + M₅]
[M₂ + M₄              M₁ + M₃ - M₂ + M₆]

Recurrence: T(n) = 7T(n/2) + O(n²)
Solution: T(n) = Θ(n^log₂(7)) ≈ Θ(n^2.807) ✓</code></pre>
<p><strong>Better than O(n³)!</strong></p>
<p><strong>Modern developments:</strong></p>
<ul>
<li>Coppersmith-Winograd (1990): O(n^2.376)</li>
<li>Le Gall (2014): O(n^2.3728639)</li>
<li>Williams (2024): O(n^2.371552)</li>
<li>Theoretical limit: O(n²+ε)? Still unknown!</li>
</ul>
</section>
<section id="application-4-fast-fourier-transform-fft" class="level3" data-number="3.7.5">
<h3 data-number="3.7.5" class="anchored" data-anchor-id="application-4-fast-fourier-transform-fft"><span class="header-section-number">3.7.5</span> Application 4: Fast Fourier Transform (FFT)</h3>
<p><strong>Problem:</strong> Compute discrete Fourier transform of n points</p>
<p><strong>Applications:</strong></p>
<ul>
<li>Signal processing</li>
<li>Image compression</li>
<li>Audio analysis</li>
<li>Solving polynomial multiplication</li>
<li>Communication systems</li>
</ul>
<p><strong>Naive DFT:</strong> O(n²) <strong>FFT (divide and conquer):</strong> O(n log n)</p>
<p>This <strong>revolutionized digital signal processing</strong> in the 1960s!</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fft(x):</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Fast Fourier Transform using divide and conquer.</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Time Complexity: O(n log n)</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a><span class="co">        x: Array of n complex numbers (n must be power of 2)</span></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a><span class="co">        DFT of x</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-21"><a href="#cb80-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Divide: split into even and odd indices</span></span>
<span id="cb80-22"><a href="#cb80-22" aria-hidden="true" tabindex="-1"></a>    even <span class="op">=</span> fft(x[<span class="dv">0</span>::<span class="dv">2</span>])</span>
<span id="cb80-23"><a href="#cb80-23" aria-hidden="true" tabindex="-1"></a>    odd <span class="op">=</span> fft(x[<span class="dv">1</span>::<span class="dv">2</span>])</span>
<span id="cb80-24"><a href="#cb80-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-25"><a href="#cb80-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Conquer and combine</span></span>
<span id="cb80-26"><a href="#cb80-26" aria-hidden="true" tabindex="-1"></a>    T <span class="op">=</span> []</span>
<span id="cb80-27"><a href="#cb80-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">//</span><span class="dv">2</span>):</span>
<span id="cb80-28"><a href="#cb80-28" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> np.exp(<span class="op">-</span><span class="ot">2j</span> <span class="op">*</span> np.pi <span class="op">*</span> k <span class="op">/</span> n) <span class="op">*</span> odd[k]</span>
<span id="cb80-29"><a href="#cb80-29" aria-hidden="true" tabindex="-1"></a>        T.append(t)</span>
<span id="cb80-30"><a href="#cb80-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-31"><a href="#cb80-31" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb80-32"><a href="#cb80-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">//</span><span class="dv">2</span>):</span>
<span id="cb80-33"><a href="#cb80-33" aria-hidden="true" tabindex="-1"></a>        result.append(even[k] <span class="op">+</span> T[k])</span>
<span id="cb80-34"><a href="#cb80-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">//</span><span class="dv">2</span>):</span>
<span id="cb80-35"><a href="#cb80-35" aria-hidden="true" tabindex="-1"></a>        result.append(even[k] <span class="op">-</span> T[k])</span>
<span id="cb80-36"><a href="#cb80-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb80-37"><a href="#cb80-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(result)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Recurrence:</strong></p>
<pre><code>T(n) = 2T(n/2) + O(n)
T(n) = Θ(n log n) ✓</code></pre>
<p><strong>Impact:</strong> Made real-time audio/video processing possible!</p>
<hr>
</section>
</section>
<section id="section-2.6-implementation-and-optimization" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="section-2.6-implementation-and-optimization"><span class="header-section-number">3.8</span> Section 2.6: Implementation and Optimization</h2>
<section id="building-a-production-quality-sorting-library" class="level3" data-number="3.8.1">
<h3 data-number="3.8.1" class="anchored" data-anchor-id="building-a-production-quality-sorting-library"><span class="header-section-number">3.8.1</span> Building a Production-Quality Sorting Library</h3>
<p>Let’s bring everything together and build a practical sorting implementation that combines the best techniques we’ve learned.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="co">production_sort.py - High-performance sorting implementation</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="co">Combines multiple algorithms for optimal performance:</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="co">- QuickSort for general cases</span></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="co">- Insertion sort for small arrays</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="co">- Three-way partitioning for duplicates</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a><span class="co">- Randomized pivot selection</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> List, TypeVar, Callable</span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> TypeVar(<span class="st">'T'</span>)</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Configuration constants</span></span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>INSERTION_THRESHOLD <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>USE_MEDIAN_OF_THREE <span class="op">=</span> <span class="va">True</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a>USE_THREE_WAY_PARTITION <span class="op">=</span> <span class="va">True</span></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sort(arr: List[T], key: Callable <span class="op">=</span> <span class="va">None</span>, reverse: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span>) <span class="op">-&gt;</span> List[T]:</span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a><span class="co">    High-performance sorting function.</span></span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a><span class="co">    Features:</span></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a><span class="co">    - Hybrid algorithm (QuickSort + Insertion Sort)</span></span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a><span class="co">    - Randomized pivot selection</span></span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a><span class="co">    - Three-way partitioning for duplicates</span></span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a><span class="co">    - Custom comparison support</span></span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true" tabindex="-1"></a><span class="co">    Time Complexity: O(n log n) expected</span></span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true" tabindex="-1"></a><span class="co">    Space Complexity: O(log n)</span></span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true" tabindex="-1"></a><span class="co">        arr: List to sort</span></span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true" tabindex="-1"></a><span class="co">        key: Optional key function for comparisons</span></span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true" tabindex="-1"></a><span class="co">        reverse: Sort in descending order if True</span></span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true" tabindex="-1"></a><span class="co">        New sorted list</span></span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true" tabindex="-1"></a><span class="co">        &gt;&gt;&gt; sort([3, 1, 4, 1, 5, 9, 2, 6])</span></span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true" tabindex="-1"></a><span class="co">        [1, 1, 2, 3, 4, 5, 6, 9]</span></span>
<span id="cb82-46"><a href="#cb82-46" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb82-47"><a href="#cb82-47" aria-hidden="true" tabindex="-1"></a><span class="co">        &gt;&gt;&gt; sort(['apple', 'pie', 'a'], key=len)</span></span>
<span id="cb82-48"><a href="#cb82-48" aria-hidden="true" tabindex="-1"></a><span class="co">        ['a', 'pie', 'apple']</span></span>
<span id="cb82-49"><a href="#cb82-49" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb82-50"><a href="#cb82-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create copy to avoid modifying original</span></span>
<span id="cb82-51"><a href="#cb82-51" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> arr.copy()</span>
<span id="cb82-52"><a href="#cb82-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-53"><a href="#cb82-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply key function if provided</span></span>
<span id="cb82-54"><a href="#cb82-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> key <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb82-55"><a href="#cb82-55" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sort indices by key function</span></span>
<span id="cb82-56"><a href="#cb82-56" aria-hidden="true" tabindex="-1"></a>        indices <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(result)))</span>
<span id="cb82-57"><a href="#cb82-57" aria-hidden="true" tabindex="-1"></a>        _quicksort_with_key(result, indices, <span class="dv">0</span>, <span class="bu">len</span>(result) <span class="op">-</span> <span class="dv">1</span>, key)</span>
<span id="cb82-58"><a href="#cb82-58" aria-hidden="true" tabindex="-1"></a>        result <span class="op">=</span> [result[i] <span class="cf">for</span> i <span class="kw">in</span> indices]</span>
<span id="cb82-59"><a href="#cb82-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb82-60"><a href="#cb82-60" aria-hidden="true" tabindex="-1"></a>        _quicksort(result, <span class="dv">0</span>, <span class="bu">len</span>(result) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb82-61"><a href="#cb82-61" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-62"><a href="#cb82-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reverse if requested</span></span>
<span id="cb82-63"><a href="#cb82-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> reverse:</span>
<span id="cb82-64"><a href="#cb82-64" aria-hidden="true" tabindex="-1"></a>        result.reverse()</span>
<span id="cb82-65"><a href="#cb82-65" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-66"><a href="#cb82-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span>
<span id="cb82-67"><a href="#cb82-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-68"><a href="#cb82-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-69"><a href="#cb82-69" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _quicksort(arr: List[T], low: <span class="bu">int</span>, high: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb82-70"><a href="#cb82-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Internal quicksort with optimizations."""</span></span>
<span id="cb82-71"><a href="#cb82-71" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> low <span class="op">&lt;</span> high:</span>
<span id="cb82-72"><a href="#cb82-72" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use insertion sort for small subarrays</span></span>
<span id="cb82-73"><a href="#cb82-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> high <span class="op">-</span> low <span class="op">&lt;</span> INSERTION_THRESHOLD:</span>
<span id="cb82-74"><a href="#cb82-74" aria-hidden="true" tabindex="-1"></a>            _insertion_sort_range(arr, low, high)</span>
<span id="cb82-75"><a href="#cb82-75" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb82-76"><a href="#cb82-76" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb82-77"><a href="#cb82-77" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Partition</span></span>
<span id="cb82-78"><a href="#cb82-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> USE_THREE_WAY_PARTITION:</span>
<span id="cb82-79"><a href="#cb82-79" aria-hidden="true" tabindex="-1"></a>            lt, gt <span class="op">=</span> _three_way_partition(arr, low, high)</span>
<span id="cb82-80"><a href="#cb82-80" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Recurse on smaller partition, iterate on larger</span></span>
<span id="cb82-81"><a href="#cb82-81" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> lt <span class="op">-</span> low <span class="op">&lt;</span> high <span class="op">-</span> gt:</span>
<span id="cb82-82"><a href="#cb82-82" aria-hidden="true" tabindex="-1"></a>                _quicksort(arr, low, lt <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb82-83"><a href="#cb82-83" aria-hidden="true" tabindex="-1"></a>                low <span class="op">=</span> gt <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb82-84"><a href="#cb82-84" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb82-85"><a href="#cb82-85" aria-hidden="true" tabindex="-1"></a>                _quicksort(arr, gt <span class="op">+</span> <span class="dv">1</span>, high)</span>
<span id="cb82-86"><a href="#cb82-86" aria-hidden="true" tabindex="-1"></a>                high <span class="op">=</span> lt <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb82-87"><a href="#cb82-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb82-88"><a href="#cb82-88" aria-hidden="true" tabindex="-1"></a>            pivot_pos <span class="op">=</span> _partition(arr, low, high)</span>
<span id="cb82-89"><a href="#cb82-89" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pivot_pos <span class="op">-</span> low <span class="op">&lt;</span> high <span class="op">-</span> pivot_pos:</span>
<span id="cb82-90"><a href="#cb82-90" aria-hidden="true" tabindex="-1"></a>                _quicksort(arr, low, pivot_pos <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb82-91"><a href="#cb82-91" aria-hidden="true" tabindex="-1"></a>                low <span class="op">=</span> pivot_pos <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb82-92"><a href="#cb82-92" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb82-93"><a href="#cb82-93" aria-hidden="true" tabindex="-1"></a>                _quicksort(arr, pivot_pos <span class="op">+</span> <span class="dv">1</span>, high)</span>
<span id="cb82-94"><a href="#cb82-94" aria-hidden="true" tabindex="-1"></a>                high <span class="op">=</span> pivot_pos <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb82-95"><a href="#cb82-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-96"><a href="#cb82-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-97"><a href="#cb82-97" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _partition(arr: List[T], low: <span class="bu">int</span>, high: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb82-98"><a href="#cb82-98" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb82-99"><a href="#cb82-99" aria-hidden="true" tabindex="-1"></a><span class="co">    Lomuto partition with median-of-three pivot selection.</span></span>
<span id="cb82-100"><a href="#cb82-100" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb82-101"><a href="#cb82-101" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Choose pivot using median-of-three</span></span>
<span id="cb82-102"><a href="#cb82-102" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> USE_MEDIAN_OF_THREE <span class="kw">and</span> high <span class="op">-</span> low <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb82-103"><a href="#cb82-103" aria-hidden="true" tabindex="-1"></a>        _median_of_three(arr, low, high)</span>
<span id="cb82-104"><a href="#cb82-104" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb82-105"><a href="#cb82-105" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Random pivot</span></span>
<span id="cb82-106"><a href="#cb82-106" aria-hidden="true" tabindex="-1"></a>        random_idx <span class="op">=</span> random.randint(low, high)</span>
<span id="cb82-107"><a href="#cb82-107" aria-hidden="true" tabindex="-1"></a>        arr[random_idx], arr[high] <span class="op">=</span> arr[high], arr[random_idx]</span>
<span id="cb82-108"><a href="#cb82-108" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-109"><a href="#cb82-109" aria-hidden="true" tabindex="-1"></a>    pivot <span class="op">=</span> arr[high]</span>
<span id="cb82-110"><a href="#cb82-110" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> low <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb82-111"><a href="#cb82-111" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-112"><a href="#cb82-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(low, high):</span>
<span id="cb82-113"><a href="#cb82-113" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr[j] <span class="op">&lt;=</span> pivot:</span>
<span id="cb82-114"><a href="#cb82-114" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb82-115"><a href="#cb82-115" aria-hidden="true" tabindex="-1"></a>            arr[i], arr[j] <span class="op">=</span> arr[j], arr[i]</span>
<span id="cb82-116"><a href="#cb82-116" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-117"><a href="#cb82-117" aria-hidden="true" tabindex="-1"></a>    i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb82-118"><a href="#cb82-118" aria-hidden="true" tabindex="-1"></a>    arr[i], arr[high] <span class="op">=</span> arr[high], arr[i]</span>
<span id="cb82-119"><a href="#cb82-119" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i</span>
<span id="cb82-120"><a href="#cb82-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-121"><a href="#cb82-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-122"><a href="#cb82-122" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _three_way_partition(arr: List[T], low: <span class="bu">int</span>, high: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">tuple</span>:</span>
<span id="cb82-123"><a href="#cb82-123" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb82-124"><a href="#cb82-124" aria-hidden="true" tabindex="-1"></a><span class="co">    Dutch National Flag three-way partitioning.</span></span>
<span id="cb82-125"><a href="#cb82-125" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb82-126"><a href="#cb82-126" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns: (lt, gt) where:</span></span>
<span id="cb82-127"><a href="#cb82-127" aria-hidden="true" tabindex="-1"></a><span class="co">        arr[low..lt-1] &lt; pivot</span></span>
<span id="cb82-128"><a href="#cb82-128" aria-hidden="true" tabindex="-1"></a><span class="co">        arr[lt..gt] = pivot</span></span>
<span id="cb82-129"><a href="#cb82-129" aria-hidden="true" tabindex="-1"></a><span class="co">        arr[gt+1..high] &gt; pivot</span></span>
<span id="cb82-130"><a href="#cb82-130" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb82-131"><a href="#cb82-131" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Choose pivot</span></span>
<span id="cb82-132"><a href="#cb82-132" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> USE_MEDIAN_OF_THREE <span class="kw">and</span> high <span class="op">-</span> low <span class="op">&gt;</span> <span class="dv">2</span>:</span>
<span id="cb82-133"><a href="#cb82-133" aria-hidden="true" tabindex="-1"></a>        _median_of_three(arr, low, high)</span>
<span id="cb82-134"><a href="#cb82-134" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-135"><a href="#cb82-135" aria-hidden="true" tabindex="-1"></a>    pivot <span class="op">=</span> arr[low]</span>
<span id="cb82-136"><a href="#cb82-136" aria-hidden="true" tabindex="-1"></a>    lt <span class="op">=</span> low</span>
<span id="cb82-137"><a href="#cb82-137" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> low <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb82-138"><a href="#cb82-138" aria-hidden="true" tabindex="-1"></a>    gt <span class="op">=</span> high</span>
<span id="cb82-139"><a href="#cb82-139" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-140"><a href="#cb82-140" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;=</span> gt:</span>
<span id="cb82-141"><a href="#cb82-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr[i] <span class="op">&lt;</span> pivot:</span>
<span id="cb82-142"><a href="#cb82-142" aria-hidden="true" tabindex="-1"></a>            arr[lt], arr[i] <span class="op">=</span> arr[i], arr[lt]</span>
<span id="cb82-143"><a href="#cb82-143" aria-hidden="true" tabindex="-1"></a>            lt <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb82-144"><a href="#cb82-144" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb82-145"><a href="#cb82-145" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> arr[i] <span class="op">&gt;</span> pivot:</span>
<span id="cb82-146"><a href="#cb82-146" aria-hidden="true" tabindex="-1"></a>            arr[i], arr[gt] <span class="op">=</span> arr[gt], arr[i]</span>
<span id="cb82-147"><a href="#cb82-147" aria-hidden="true" tabindex="-1"></a>            gt <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb82-148"><a href="#cb82-148" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb82-149"><a href="#cb82-149" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb82-150"><a href="#cb82-150" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-151"><a href="#cb82-151" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lt, gt</span>
<span id="cb82-152"><a href="#cb82-152" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-153"><a href="#cb82-153" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-154"><a href="#cb82-154" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _median_of_three(arr: List[T], low: <span class="bu">int</span>, high: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb82-155"><a href="#cb82-155" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb82-156"><a href="#cb82-156" aria-hidden="true" tabindex="-1"></a><span class="co">    Choose median of first, middle, and last elements as pivot.</span></span>
<span id="cb82-157"><a href="#cb82-157" aria-hidden="true" tabindex="-1"></a><span class="co">    Places median at arr[high] position.</span></span>
<span id="cb82-158"><a href="#cb82-158" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb82-159"><a href="#cb82-159" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> (low <span class="op">+</span> high) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb82-160"><a href="#cb82-160" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-161"><a href="#cb82-161" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort low, mid, high</span></span>
<span id="cb82-162"><a href="#cb82-162" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> arr[mid] <span class="op">&lt;</span> arr[low]:</span>
<span id="cb82-163"><a href="#cb82-163" aria-hidden="true" tabindex="-1"></a>        arr[low], arr[mid] <span class="op">=</span> arr[mid], arr[low]</span>
<span id="cb82-164"><a href="#cb82-164" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> arr[high] <span class="op">&lt;</span> arr[low]:</span>
<span id="cb82-165"><a href="#cb82-165" aria-hidden="true" tabindex="-1"></a>        arr[low], arr[high] <span class="op">=</span> arr[high], arr[low]</span>
<span id="cb82-166"><a href="#cb82-166" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> arr[high] <span class="op">&lt;</span> arr[mid]:</span>
<span id="cb82-167"><a href="#cb82-167" aria-hidden="true" tabindex="-1"></a>        arr[mid], arr[high] <span class="op">=</span> arr[high], arr[mid]</span>
<span id="cb82-168"><a href="#cb82-168" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb82-169"><a href="#cb82-169" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Place median at high position</span></span>
<span id="cb82-170"><a href="#cb82-170" aria-hidden="true" tabindex="-1"></a>    arr[mid], arr[high] <span class="op">=</span> arr[high], arr[mid]</span>
<span id="cb82-171"><a href="#cb82-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-172"><a href="#cb82-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-173"><a href="#cb82-173" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _insertion_sort_range(arr: List[T], low: <span class="bu">int</span>, high: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb82-174"><a href="#cb82-174" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb82-175"><a href="#cb82-175" aria-hidden="true" tabindex="-1"></a><span class="co">    Insertion sort for arr[low..high].</span></span>
<span id="cb82-176"><a href="#cb82-176" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb82-177"><a href="#cb82-177" aria-hidden="true" tabindex="-1"></a><span class="co">    Efficient for small arrays due to low overhead.</span></span>
<span id="cb82-178"><a href="#cb82-178" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb82-179"><a href="#cb82-179" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(low <span class="op">+</span> <span class="dv">1</span>, high <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb82-180"><a href="#cb82-180" aria-hidden="true" tabindex="-1"></a>        key <span class="op">=</span> arr[i]</span>
<span id="cb82-181"><a href="#cb82-181" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb82-182"><a href="#cb82-182" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> j <span class="op">&gt;=</span> low <span class="kw">and</span> arr[j] <span class="op">&gt;</span> key:</span>
<span id="cb82-183"><a href="#cb82-183" aria-hidden="true" tabindex="-1"></a>            arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> arr[j]</span>
<span id="cb82-184"><a href="#cb82-184" aria-hidden="true" tabindex="-1"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb82-185"><a href="#cb82-185" aria-hidden="true" tabindex="-1"></a>        arr[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> key</span>
<span id="cb82-186"><a href="#cb82-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-187"><a href="#cb82-187" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-188"><a href="#cb82-188" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _quicksort_with_key(arr: List[T], indices: List[<span class="bu">int</span>], </span>
<span id="cb82-189"><a href="#cb82-189" aria-hidden="true" tabindex="-1"></a>                        low: <span class="bu">int</span>, high: <span class="bu">int</span>, key: Callable) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb82-190"><a href="#cb82-190" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""QuickSort that sorts indices based on key function."""</span></span>
<span id="cb82-191"><a href="#cb82-191" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Similar to _quicksort but compares key(arr[indices[i]])</span></span>
<span id="cb82-192"><a href="#cb82-192" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Implementation left as exercise</span></span>
<span id="cb82-193"><a href="#cb82-193" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb82-194"><a href="#cb82-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-195"><a href="#cb82-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-196"><a href="#cb82-196" aria-hidden="true" tabindex="-1"></a><span class="co"># Additional utility: Check if sorted</span></span>
<span id="cb82-197"><a href="#cb82-197" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_sorted(arr: List[T], key: Callable <span class="op">=</span> <span class="va">None</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb82-198"><a href="#cb82-198" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Check if array is sorted."""</span></span>
<span id="cb82-199"><a href="#cb82-199" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> key <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb82-200"><a href="#cb82-200" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">all</span>(arr[i] <span class="op">&lt;=</span> arr[i<span class="op">+</span><span class="dv">1</span>] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(arr)<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb82-201"><a href="#cb82-201" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb82-202"><a href="#cb82-202" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">all</span>(key(arr[i]) <span class="op">&lt;=</span> key(arr[i<span class="op">+</span><span class="dv">1</span>]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(arr)<span class="op">-</span><span class="dv">1</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="performance-benchmarking" class="level3" data-number="3.8.2">
<h3 data-number="3.8.2" class="anchored" data-anchor-id="performance-benchmarking"><span class="header-section-number">3.8.2</span> Performance Benchmarking</h3>
<p>Let’s create comprehensive benchmarks:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="co">benchmark_sorting.py - Comprehensive performance analysis</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a><span class="co">"""</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> production_sort <span class="im">import</span> sort <span class="im">as</span> prod_sort</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_test_data(size: <span class="bu">int</span>, data_type: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">list</span>:</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Generate different types of test data."""</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> data_type <span class="op">==</span> <span class="st">"random"</span>:</span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [random.randint(<span class="dv">1</span>, <span class="dv">100000</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(size)]</span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> data_type <span class="op">==</span> <span class="st">"sorted"</span>:</span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">list</span>(<span class="bu">range</span>(size))</span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> data_type <span class="op">==</span> <span class="st">"reverse"</span>:</span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">list</span>(<span class="bu">range</span>(size, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> data_type <span class="op">==</span> <span class="st">"nearly_sorted"</span>:</span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true" tabindex="-1"></a>        arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(size))</span>
<span id="cb83-20"><a href="#cb83-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Swap 5% of elements</span></span>
<span id="cb83-21"><a href="#cb83-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(size <span class="op">//</span> <span class="dv">20</span>):</span>
<span id="cb83-22"><a href="#cb83-22" aria-hidden="true" tabindex="-1"></a>            i, j <span class="op">=</span> random.randint(<span class="dv">0</span>, size<span class="op">-</span><span class="dv">1</span>), random.randint(<span class="dv">0</span>, size<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb83-23"><a href="#cb83-23" aria-hidden="true" tabindex="-1"></a>            arr[i], arr[j] <span class="op">=</span> arr[j], arr[i]</span>
<span id="cb83-24"><a href="#cb83-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr</span>
<span id="cb83-25"><a href="#cb83-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> data_type <span class="op">==</span> <span class="st">"many_duplicates"</span>:</span>
<span id="cb83-26"><a href="#cb83-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [random.randint(<span class="dv">1</span>, <span class="dv">100</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(size)]</span>
<span id="cb83-27"><a href="#cb83-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> data_type <span class="op">==</span> <span class="st">"few_unique"</span>:</span>
<span id="cb83-28"><a href="#cb83-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> [random.randint(<span class="dv">1</span>, <span class="dv">10</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(size)]</span>
<span id="cb83-29"><a href="#cb83-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb83-30"><a href="#cb83-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f"Unknown data type: </span><span class="sc">{</span>data_type<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb83-31"><a href="#cb83-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-32"><a href="#cb83-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-33"><a href="#cb83-33" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> benchmark_algorithm(algorithm, data, runs<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb83-34"><a href="#cb83-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Time algorithm with multiple runs."""</span></span>
<span id="cb83-35"><a href="#cb83-35" aria-hidden="true" tabindex="-1"></a>    times <span class="op">=</span> []</span>
<span id="cb83-36"><a href="#cb83-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-37"><a href="#cb83-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(runs):</span>
<span id="cb83-38"><a href="#cb83-38" aria-hidden="true" tabindex="-1"></a>        test_data <span class="op">=</span> data.copy()</span>
<span id="cb83-39"><a href="#cb83-39" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> time.perf_counter()</span>
<span id="cb83-40"><a href="#cb83-40" aria-hidden="true" tabindex="-1"></a>        algorithm(test_data)</span>
<span id="cb83-41"><a href="#cb83-41" aria-hidden="true" tabindex="-1"></a>        end <span class="op">=</span> time.perf_counter()</span>
<span id="cb83-42"><a href="#cb83-42" aria-hidden="true" tabindex="-1"></a>        times.append(end <span class="op">-</span> start)</span>
<span id="cb83-43"><a href="#cb83-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-44"><a href="#cb83-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(times)  <span class="co"># Return best time</span></span>
<span id="cb83-45"><a href="#cb83-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-46"><a href="#cb83-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-47"><a href="#cb83-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> comprehensive_benchmark():</span>
<span id="cb83-48"><a href="#cb83-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Run comprehensive performance tests."""</span></span>
<span id="cb83-49"><a href="#cb83-49" aria-hidden="true" tabindex="-1"></a>    algorithms <span class="op">=</span> {</span>
<span id="cb83-50"><a href="#cb83-50" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Production Sort"</span>: prod_sort,</span>
<span id="cb83-51"><a href="#cb83-51" aria-hidden="true" tabindex="-1"></a>        <span class="st">"Python built-in"</span>: <span class="bu">sorted</span>,</span>
<span id="cb83-52"><a href="#cb83-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add merge_sort, quicksort from earlier implementations</span></span>
<span id="cb83-53"><a href="#cb83-53" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb83-54"><a href="#cb83-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-55"><a href="#cb83-55" aria-hidden="true" tabindex="-1"></a>    sizes <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">500</span>, <span class="dv">1000</span>, <span class="dv">5000</span>, <span class="dv">10000</span>]</span>
<span id="cb83-56"><a href="#cb83-56" aria-hidden="true" tabindex="-1"></a>    data_types <span class="op">=</span> [<span class="st">"random"</span>, <span class="st">"sorted"</span>, <span class="st">"reverse"</span>, <span class="st">"nearly_sorted"</span>, <span class="st">"many_duplicates"</span>]</span>
<span id="cb83-57"><a href="#cb83-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-58"><a href="#cb83-58" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> {name: {dt: [] <span class="cf">for</span> dt <span class="kw">in</span> data_types} <span class="cf">for</span> name <span class="kw">in</span> algorithms}</span>
<span id="cb83-59"><a href="#cb83-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-60"><a href="#cb83-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> data_type <span class="kw">in</span> data_types:</span>
<span id="cb83-61"><a href="#cb83-61" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Testing </span><span class="sc">{</span>data_type<span class="sc">}</span><span class="ss"> data:"</span>)</span>
<span id="cb83-62"><a href="#cb83-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> size <span class="kw">in</span> sizes:</span>
<span id="cb83-63"><a href="#cb83-63" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  Size </span><span class="sc">{</span>size<span class="sc">}</span><span class="ss">:"</span>)</span>
<span id="cb83-64"><a href="#cb83-64" aria-hidden="true" tabindex="-1"></a>            test_data <span class="op">=</span> generate_test_data(size, data_type)</span>
<span id="cb83-65"><a href="#cb83-65" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb83-66"><a href="#cb83-66" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> name, algorithm <span class="kw">in</span> algorithms.items():</span>
<span id="cb83-67"><a href="#cb83-67" aria-hidden="true" tabindex="-1"></a>                ```python</span>
<span id="cb83-68"><a href="#cb83-68" aria-hidden="true" tabindex="-1"></a>                time_taken <span class="op">=</span> benchmark_algorithm(algorithm, test_data)</span>
<span id="cb83-69"><a href="#cb83-69" aria-hidden="true" tabindex="-1"></a>                results[name][data_type].append(time_taken)</span>
<span id="cb83-70"><a href="#cb83-70" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f"    </span><span class="sc">{</span>name<span class="sc">:20}</span><span class="ss">: </span><span class="sc">{</span>time_taken<span class="sc">:.6f}</span><span class="ss">s"</span>)</span>
<span id="cb83-71"><a href="#cb83-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-72"><a href="#cb83-72" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Plot results</span></span>
<span id="cb83-73"><a href="#cb83-73" aria-hidden="true" tabindex="-1"></a>    plot_benchmark_results(results, sizes, data_types)</span>
<span id="cb83-74"><a href="#cb83-74" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-75"><a href="#cb83-75" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results</span>
<span id="cb83-76"><a href="#cb83-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-77"><a href="#cb83-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-78"><a href="#cb83-78" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_benchmark_results(results, sizes, data_types):</span>
<span id="cb83-79"><a href="#cb83-79" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Create comprehensive visualization of results."""</span></span>
<span id="cb83-80"><a href="#cb83-80" aria-hidden="true" tabindex="-1"></a>    fig, axes <span class="op">=</span> plt.subplots(<span class="dv">2</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">18</span>, <span class="dv">12</span>))</span>
<span id="cb83-81"><a href="#cb83-81" aria-hidden="true" tabindex="-1"></a>    fig.suptitle(<span class="st">'Sorting Algorithm Performance Comparison'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb83-82"><a href="#cb83-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-83"><a href="#cb83-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> idx, data_type <span class="kw">in</span> <span class="bu">enumerate</span>(data_types):</span>
<span id="cb83-84"><a href="#cb83-84" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> idx <span class="op">//</span> <span class="dv">3</span></span>
<span id="cb83-85"><a href="#cb83-85" aria-hidden="true" tabindex="-1"></a>        col <span class="op">=</span> idx <span class="op">%</span> <span class="dv">3</span></span>
<span id="cb83-86"><a href="#cb83-86" aria-hidden="true" tabindex="-1"></a>        ax <span class="op">=</span> axes[row, col]</span>
<span id="cb83-87"><a href="#cb83-87" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb83-88"><a href="#cb83-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> algo_name, algo_results <span class="kw">in</span> results.items():</span>
<span id="cb83-89"><a href="#cb83-89" aria-hidden="true" tabindex="-1"></a>            ax.plot(sizes, algo_results[data_type], </span>
<span id="cb83-90"><a href="#cb83-90" aria-hidden="true" tabindex="-1"></a>                   marker<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span>algo_name, linewidth<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb83-91"><a href="#cb83-91" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb83-92"><a href="#cb83-92" aria-hidden="true" tabindex="-1"></a>        ax.set_xlabel(<span class="st">'Input Size (n)'</span>)</span>
<span id="cb83-93"><a href="#cb83-93" aria-hidden="true" tabindex="-1"></a>        ax.set_ylabel(<span class="st">'Time (seconds)'</span>)</span>
<span id="cb83-94"><a href="#cb83-94" aria-hidden="true" tabindex="-1"></a>        ax.set_title(<span class="ss">f'</span><span class="sc">{</span>data_type<span class="sc">.</span>replace(<span class="st">"_"</span>, <span class="st">" "</span>)<span class="sc">.</span>title()<span class="sc">}</span><span class="ss"> Data'</span>)</span>
<span id="cb83-95"><a href="#cb83-95" aria-hidden="true" tabindex="-1"></a>        ax.legend()</span>
<span id="cb83-96"><a href="#cb83-96" aria-hidden="true" tabindex="-1"></a>        ax.grid(<span class="va">True</span>, alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb83-97"><a href="#cb83-97" aria-hidden="true" tabindex="-1"></a>        ax.set_xscale(<span class="st">'log'</span>)</span>
<span id="cb83-98"><a href="#cb83-98" aria-hidden="true" tabindex="-1"></a>        ax.set_yscale(<span class="st">'log'</span>)</span>
<span id="cb83-99"><a href="#cb83-99" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-100"><a href="#cb83-100" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Remove empty subplot if odd number of data types</span></span>
<span id="cb83-101"><a href="#cb83-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(data_types) <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb83-102"><a href="#cb83-102" aria-hidden="true" tabindex="-1"></a>        fig.delaxes(axes[<span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb83-103"><a href="#cb83-103" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-104"><a href="#cb83-104" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb83-105"><a href="#cb83-105" aria-hidden="true" tabindex="-1"></a>    plt.savefig(<span class="st">'sorting_benchmark_results.png'</span>, dpi<span class="op">=</span><span class="dv">300</span>, bbox_inches<span class="op">=</span><span class="st">'tight'</span>)</span>
<span id="cb83-106"><a href="#cb83-106" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb83-107"><a href="#cb83-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-108"><a href="#cb83-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-109"><a href="#cb83-109" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_complexity(results, sizes):</span>
<span id="cb83-110"><a href="#cb83-110" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Analyze empirical complexity."""</span></span>
<span id="cb83-111"><a href="#cb83-111" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span> <span class="op">+</span> <span class="st">"="</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb83-112"><a href="#cb83-112" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"EMPIRICAL COMPLEXITY ANALYSIS"</span>)</span>
<span id="cb83-113"><a href="#cb83-113" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">60</span>)</span>
<span id="cb83-114"><a href="#cb83-114" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb83-115"><a href="#cb83-115" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> algo_name, algo_results <span class="kw">in</span> results.items():</span>
<span id="cb83-116"><a href="#cb83-116" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="sc">{</span>algo_name<span class="sc">}</span><span class="ss">:"</span>)</span>
<span id="cb83-117"><a href="#cb83-117" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb83-118"><a href="#cb83-118" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> data_type, times <span class="kw">in</span> algo_results.items():</span>
<span id="cb83-119"><a href="#cb83-119" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(times) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb83-120"><a href="#cb83-120" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb83-121"><a href="#cb83-121" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb83-122"><a href="#cb83-122" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate doubling ratios</span></span>
<span id="cb83-123"><a href="#cb83-123" aria-hidden="true" tabindex="-1"></a>            ratios <span class="op">=</span> []</span>
<span id="cb83-124"><a href="#cb83-124" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(times)):</span>
<span id="cb83-125"><a href="#cb83-125" aria-hidden="true" tabindex="-1"></a>                size_ratio <span class="op">=</span> sizes[i] <span class="op">/</span> sizes[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb83-126"><a href="#cb83-126" aria-hidden="true" tabindex="-1"></a>                time_ratio <span class="op">=</span> times[i] <span class="op">/</span> times[i<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb83-127"><a href="#cb83-127" aria-hidden="true" tabindex="-1"></a>                normalized_ratio <span class="op">=</span> time_ratio <span class="op">/</span> size_ratio</span>
<span id="cb83-128"><a href="#cb83-128" aria-hidden="true" tabindex="-1"></a>                ratios.append(normalized_ratio)</span>
<span id="cb83-129"><a href="#cb83-129" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb83-130"><a href="#cb83-130" aria-hidden="true" tabindex="-1"></a>            avg_ratio <span class="op">=</span> <span class="bu">sum</span>(ratios) <span class="op">/</span> <span class="bu">len</span>(ratios)</span>
<span id="cb83-131"><a href="#cb83-131" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb83-132"><a href="#cb83-132" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Estimate complexity</span></span>
<span id="cb83-133"><a href="#cb83-133" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> avg_ratio <span class="op">&lt;</span> <span class="fl">1.3</span>:</span>
<span id="cb83-134"><a href="#cb83-134" aria-hidden="true" tabindex="-1"></a>                complexity <span class="op">=</span> <span class="st">"O(n)"</span></span>
<span id="cb83-135"><a href="#cb83-135" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> avg_ratio <span class="op">&lt;</span> <span class="fl">2.5</span>:</span>
<span id="cb83-136"><a href="#cb83-136" aria-hidden="true" tabindex="-1"></a>                complexity <span class="op">=</span> <span class="st">"O(n log n)"</span></span>
<span id="cb83-137"><a href="#cb83-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb83-138"><a href="#cb83-138" aria-hidden="true" tabindex="-1"></a>                complexity <span class="op">=</span> <span class="st">"O(n²) or worse"</span></span>
<span id="cb83-139"><a href="#cb83-139" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb83-140"><a href="#cb83-140" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>data_type<span class="sc">:20}</span><span class="ss">: </span><span class="sc">{</span>complexity<span class="sc">:15}</span><span class="ss"> (avg ratio: </span><span class="sc">{</span>avg_ratio<span class="sc">:.2f}</span><span class="ss">)"</span>)</span>
<span id="cb83-141"><a href="#cb83-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-142"><a href="#cb83-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-143"><a href="#cb83-143" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">"__main__"</span>:</span>
<span id="cb83-144"><a href="#cb83-144" aria-hidden="true" tabindex="-1"></a>    results <span class="op">=</span> comprehensive_benchmark()</span>
<span id="cb83-145"><a href="#cb83-145" aria-hidden="true" tabindex="-1"></a>    analyze_complexity(results, [<span class="dv">100</span>, <span class="dv">500</span>, <span class="dv">1000</span>, <span class="dv">5000</span>, <span class="dv">10000</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="real-world-performance-tips" class="level3" data-number="3.8.3">
<h3 data-number="3.8.3" class="anchored" data-anchor-id="real-world-performance-tips"><span class="header-section-number">3.8.3</span> Real-World Performance Tips</h3>
<p>Based on extensive testing, here are practical insights:</p>
<p><strong>🎯 Algorithm Selection Guidelines:</strong></p>
<p><strong>Use QuickSort when:</strong></p>
<ul>
<li>General-purpose sorting needed</li>
<li>Working with arrays (random access)</li>
<li>Space is limited</li>
<li>Average-case performance is priority</li>
<li>Data has few duplicates</li>
</ul>
<p><strong>Use Merge Sort when:</strong></p>
<ul>
<li>Guaranteed O(n log n) required</li>
<li>Stability is needed</li>
<li>Sorting linked lists</li>
<li>External sorting (disk-based)</li>
<li>Parallel processing available</li>
</ul>
<p><strong>Use Insertion Sort when:</strong></p>
<ul>
<li>Arrays are small (&lt; 50 elements)</li>
<li>Data is nearly sorted</li>
<li>Simplicity is priority</li>
<li>In hybrid algorithms as base case</li>
</ul>
<p><strong>Use Three-Way QuickSort when:</strong></p>
<ul>
<li>Many duplicate values expected</li>
<li>Sorting categorical data</li>
<li>Enum or flag values</li>
<li>Can provide 10-100× speedup!</li>
</ul>
</section>
<section id="common-implementation-pitfalls" class="level3" data-number="3.8.4">
<h3 data-number="3.8.4" class="anchored" data-anchor-id="common-implementation-pitfalls"><span class="header-section-number">3.8.4</span> Common Implementation Pitfalls</h3>
<p><strong>❌ Pitfall 1: Not handling duplicates well</strong></p>
<div class="sourceCode" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Bad: Standard partition performs poorly with many duplicates</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bad_partition(arr, low, high):</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>    pivot <span class="op">=</span> arr[high]</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> low <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(low, high):</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> arr[j] <span class="op">&lt;</span> pivot:  <span class="co"># Only &lt; not &lt;=</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>            arr[i], arr[j] <span class="op">=</span> arr[j], arr[i]</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Many equal elements end up on one side!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>✅ Solution: Use three-way partitioning</strong></p>
<p><strong>❌ Pitfall 2: Deep recursion on sorted data</strong></p>
<div class="sourceCode" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Bad: Always picking last element as pivot</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bad_quicksort(arr, low, high):</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> low <span class="op">&lt;</span> high:</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>        pivot <span class="op">=</span> partition(arr, low, high)  <span class="co"># Always uses arr[high]</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>        bad_quicksort(arr, low, pivot <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>        bad_quicksort(arr, pivot <span class="op">+</span> <span class="dv">1</span>, high)</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a><span class="co"># O(n²) on sorted arrays! Stack overflow risk!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>✅ Solution: Randomize pivot or use median-of-three</strong></p>
<p><strong>❌ Pitfall 3: Unnecessary copying in merge sort</strong></p>
<div class="sourceCode" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Bad: Creating many temporary arrays</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bad_merge_sort(arr):</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(arr) <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> <span class="bu">len</span>(arr) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    left <span class="op">=</span> bad_merge_sort(arr[:mid])      <span class="co"># Copy!</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>    right <span class="op">=</span> bad_merge_sort(arr[mid:])     <span class="co"># Copy!</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merge(left, right)              <span class="co"># Another copy!</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Excessive memory allocation slows things down</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>✅ Solution: Sort in-place with index ranges</strong></p>
<p><strong>❌ Pitfall 4: Not tail-call optimizing</strong></p>
<div class="sourceCode" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Bad: Both recursive calls can cause deep stack</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> bad_quicksort(arr, low, high):</span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> low <span class="op">&lt;</span> high:</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>        pivot <span class="op">=</span> partition(arr, low, high)</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>        bad_quicksort(arr, low, pivot <span class="op">-</span> <span class="dv">1</span>)    <span class="co"># Could be large</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>        bad_quicksort(arr, pivot <span class="op">+</span> <span class="dv">1</span>, high)   <span class="co"># Could be large</span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Can use O(n) stack space in worst case!</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>✅ Solution: Recurse on smaller half, iterate on larger</strong></p>
<hr>
</section>
</section>
<section id="section-2.7-advanced-topics-and-extensions" class="level2" data-number="3.9">
<h2 data-number="3.9" class="anchored" data-anchor-id="section-2.7-advanced-topics-and-extensions"><span class="header-section-number">3.9</span> Section 2.7: Advanced Topics and Extensions</h2>
<section id="parallel-divide-and-conquer" class="level3" data-number="3.9.1">
<h3 data-number="3.9.1" class="anchored" data-anchor-id="parallel-divide-and-conquer"><span class="header-section-number">3.9.1</span> Parallel Divide and Conquer</h3>
<p>Modern computers have multiple cores. Divide and conquer is naturally parallelizable!</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> concurrent.futures <span class="im">import</span> ThreadPoolExecutor</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> threading</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parallel_merge_sort(arr, max_depth<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Merge sort that uses parallel processing.</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a><span class="co">        arr: List to sort</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a><span class="co">        max_depth: How deep to parallelize (avoid overhead)</span></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> _parallel_merge_sort_helper(arr, <span class="dv">0</span>, max_depth)</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _parallel_merge_sort_helper(arr, depth, max_depth):</span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Helper with depth tracking."""</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(arr) <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr</span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> <span class="bu">len</span>(arr) <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Parallelize top levels only (avoid thread overhead)</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> depth <span class="op">&lt;</span> max_depth:</span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">with</span> ThreadPoolExecutor(max_workers<span class="op">=</span><span class="dv">2</span>) <span class="im">as</span> executor:</span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Sort both halves in parallel</span></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>            future_left <span class="op">=</span> executor.submit(</span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a>                _parallel_merge_sort_helper, arr[:mid], depth <span class="op">+</span> <span class="dv">1</span>, max_depth</span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a>            future_right <span class="op">=</span> executor.submit(</span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a>                _parallel_merge_sort_helper, arr[mid:], depth <span class="op">+</span> <span class="dv">1</span>, max_depth</span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a>            left <span class="op">=</span> future_left.result()</span>
<span id="cb88-34"><a href="#cb88-34" aria-hidden="true" tabindex="-1"></a>            right <span class="op">=</span> future_right.result()</span>
<span id="cb88-35"><a href="#cb88-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb88-36"><a href="#cb88-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sequential for deeper levels</span></span>
<span id="cb88-37"><a href="#cb88-37" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> _parallel_merge_sort_helper(arr[:mid], depth <span class="op">+</span> <span class="dv">1</span>, max_depth)</span>
<span id="cb88-38"><a href="#cb88-38" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> _parallel_merge_sort_helper(arr[mid:], depth <span class="op">+</span> <span class="dv">1</span>, max_depth)</span>
<span id="cb88-39"><a href="#cb88-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb88-40"><a href="#cb88-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merge(left, right)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Theoretical speedup:</strong> Near-linear with number of cores (for large enough arrays)</p>
<p><strong>Practical considerations:</strong></p>
<ul>
<li>Thread creation overhead limits gains on small arrays</li>
<li>GIL in Python limits true parallelism (use multiprocessing instead)</li>
<li>Cache coherency issues on many-core systems</li>
<li>Best speedup typically 4-8× on modern CPUs</li>
</ul>
</section>
<section id="cache-oblivious-algorithms" class="level3" data-number="3.9.2">
<h3 data-number="3.9.2" class="anchored" data-anchor-id="cache-oblivious-algorithms"><span class="header-section-number">3.9.2</span> Cache-Oblivious Algorithms</h3>
<p>Modern CPUs have complex memory hierarchies. Cache-oblivious algorithms perform well regardless of cache size!</p>
<p><strong>Key idea:</strong> Divide recursively until data fits in cache, without knowing cache size.</p>
<p><strong>Example: Cache-oblivious matrix multiplication</strong></p>
<div class="sourceCode" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cache_oblivious_matrix_mult(A, B):</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Matrix multiplication optimized for cache performance.</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Divides recursively until submatrices fit in cache.</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(A)</span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: small enough for direct multiplication</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">32</span>:  <span class="co"># Empirically determined threshold</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> naive_matrix_mult(A, B)</span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Divide into quadrants</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>    mid <span class="op">=</span> n <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recursively multiply quadrants</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (Implementation details omitted for brevity)</span></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Key: Access memory in cache-friendly patterns</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Performance gain:</strong> 2-10× speedup on large matrices by reducing cache misses!</p>
</section>
<section id="external-memory-algorithms" class="level3" data-number="3.9.3">
<h3 data-number="3.9.3" class="anchored" data-anchor-id="external-memory-algorithms"><span class="header-section-number">3.9.3</span> External Memory Algorithms</h3>
<p>What if data doesn’t fit in RAM? External sorting handles disk-based data.</p>
<p><strong>K-way Merge Sort for External Storage:</strong></p>
<ol type="1">
<li><strong>Pass 1:</strong> Divide file into chunks that fit in memory</li>
<li>Sort each chunk using in-memory quicksort</li>
<li>Write sorted chunks to disk</li>
<li><strong>Pass 2:</strong> Merge k chunks at a time</li>
<li>Repeat until one sorted file</li>
</ol>
<p><strong>Complexity:</strong></p>
<ul>
<li>I/O operations: O((n/B) log_{M/B}(n/M))
<ul>
<li>B = block size</li>
<li>M = memory size</li>
<li>Dominates computation time!</li>
</ul></li>
</ul>
<p><strong>Applications:</strong></p>
<ul>
<li>Sorting terabyte-scale datasets</li>
<li>Database systems</li>
<li>Log file analysis</li>
<li>Big data processing</li>
</ul>
<hr>
</section>
</section>
<section id="chapter-summary-and-key-takeaways" class="level2" data-number="3.10">
<h2 data-number="3.10" class="anchored" data-anchor-id="chapter-summary-and-key-takeaways"><span class="header-section-number">3.10</span> Chapter Summary and Key Takeaways</h2>
<p>Congratulations! You’ve mastered divide and conquer—one of the most powerful algorithmic paradigms. Let’s consolidate what you’ve learned.</p>
<section id="core-concepts-mastered" class="level3" data-number="3.10.1">
<h3 data-number="3.10.1" class="anchored" data-anchor-id="core-concepts-mastered"><span class="header-section-number">3.10.1</span> Core Concepts Mastered</h3>
<p><strong>🎯 The Divide and Conquer Pattern:</strong></p>
<ol type="1">
<li><strong>Divide:</strong> Break problem into smaller subproblems</li>
<li><strong>Conquer:</strong> Solve subproblems recursively</li>
<li><strong>Combine:</strong> Merge solutions to solve original problem</li>
</ol>
<p><strong>📊 Merge Sort:</strong></p>
<ul>
<li>Guaranteed O(n log n) performance</li>
<li>Stable sorting</li>
<li>Requires O(n) extra space</li>
<li>Great for external sorting and linked lists</li>
<li>Foundation for understanding divide and conquer</li>
</ul>
<p><strong>⚡ QuickSort:</strong></p>
<ul>
<li>O(n log n) expected time with randomization</li>
<li>O(log n) space (in-place)</li>
<li>Fastest practical sorting algorithm</li>
<li>Three-way partitioning handles duplicates excellently</li>
<li>Used in most standard libraries</li>
</ul>
<p><strong>🧮 Master Theorem:</strong></p>
<ul>
<li>Instantly solve recurrences of form T(n) = aT(n/b) + f(n)</li>
<li>Three cases based on comparing f(n) with n^(log_b a)</li>
<li>Essential tool for analyzing divide and conquer algorithms</li>
</ul>
<p><strong>🚀 Advanced Applications:</strong></p>
<ul>
<li>Karatsuba multiplication: O(n^1.585) integer multiplication</li>
<li>Strassen’s algorithm: O(n^2.807) matrix multiplication</li>
<li>FFT: O(n log n) signal processing</li>
<li>Closest pair: O(n log n) geometric algorithms</li>
</ul>
</section>
<section id="performance-comparison-chart" class="level3" data-number="3.10.2">
<h3 data-number="3.10.2" class="anchored" data-anchor-id="performance-comparison-chart"><span class="header-section-number">3.10.2</span> Performance Comparison Chart</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Best Case</th>
<th>Average Case</th>
<th>Worst Case</th>
<th>Space</th>
<th>Stable</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Bubble Sort</strong></td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>Yes</td>
</tr>
<tr class="even">
<td><strong>Selection Sort</strong></td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>No</td>
</tr>
<tr class="odd">
<td><strong>Insertion Sort</strong></td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>Yes</td>
</tr>
<tr class="even">
<td><strong>Merge Sort</strong></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>Yes</td>
</tr>
<tr class="odd">
<td><strong>QuickSort</strong></td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n²)*</td>
<td>O(log n)</td>
<td>No</td>
</tr>
<tr class="even">
<td><strong>3-Way QuickSort</strong></td>
<td>O(n)</td>
<td>O(n log n)</td>
<td>O(n²)*</td>
<td>O(log n)</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>*With randomization, worst case becomes extremely unlikely</p>
</section>
<section id="when-to-use-each-algorithm" class="level3" data-number="3.10.3">
<h3 data-number="3.10.3" class="anchored" data-anchor-id="when-to-use-each-algorithm"><span class="header-section-number">3.10.3</span> When to Use Each Algorithm</h3>
<p><strong>Choose your weapon wisely:</strong></p>
<pre><code>If (need guaranteed performance):
    use Merge Sort
Else if (have many duplicates):
    use 3-Way QuickSort
Else if (space is limited):
    use QuickSort
Else if (need stability):
    use Merge Sort
Else if (array is small &lt; 50):
    use Insertion Sort
Else if (array is nearly sorted):
    use Insertion Sort
Else:
    use Randomized QuickSort  # Best general-purpose choice</code></pre>
</section>
<section id="common-mistakes-to-avoid" class="level3" data-number="3.10.4">
<h3 data-number="3.10.4" class="anchored" data-anchor-id="common-mistakes-to-avoid"><span class="header-section-number">3.10.4</span> Common Mistakes to Avoid</h3>
<p><strong>❌ Don’t:</strong></p>
<ul>
<li>Use bubble sort or selection sort for anything except teaching</li>
<li>Forget to randomize QuickSort pivot selection</li>
<li>Ignore the combine step’s complexity in analysis</li>
<li>Copy arrays unnecessarily (bad for cache performance)</li>
<li>Use divide and conquer when iterative approach is simpler</li>
</ul>
<p><strong>✅ Do:</strong></p>
<ul>
<li>Profile before optimizing</li>
<li>Use hybrid algorithms (combine multiple approaches)</li>
<li>Consider input characteristics when choosing algorithm</li>
<li>Understand the trade-offs (time vs space, average vs worst-case)</li>
<li>Test with various data types (sorted, random, duplicates)</li>
</ul>
</section>
<section id="key-insights-for-algorithm-design" class="level3" data-number="3.10.5">
<h3 data-number="3.10.5" class="anchored" data-anchor-id="key-insights-for-algorithm-design"><span class="header-section-number">3.10.5</span> Key Insights for Algorithm Design</h3>
<p><strong>Lesson 1: Recursion is Powerful</strong> Breaking problems into smaller copies of themselves often leads to elegant solutions. Once you see the recursive pattern, implementation becomes straightforward.</p>
<p><strong>Lesson 2: The Combine Step Matters</strong> The efficiency of merging or combining solutions determines whether divide and conquer helps. O(1) combine → amazing speedup. O(n²) combine → no benefit.</p>
<p><strong>Lesson 3: Base Cases Are Critical</strong></p>
<ul>
<li>Too large: Excessive recursion overhead</li>
<li>Too small: Miss optimization opportunities</li>
<li>Rule of thumb: Switch to simple algorithm around 10-50 elements</li>
</ul>
<p><strong>Lesson 4: Randomization Eliminates Worst Cases</strong> Random pivot selection transforms QuickSort from “sometimes terrible” to “always good expected performance.”</p>
<p><strong>Lesson 5: Theory Meets Practice</strong> Asymptotic analysis predicts trends accurately, but constant factors matter enormously in practice. Measure real performance!</p>
<hr>
</section>
</section>
<section id="looking-ahead-chapter-3-preview" class="level2" data-number="3.11">
<h2 data-number="3.11" class="anchored" data-anchor-id="looking-ahead-chapter-3-preview"><span class="header-section-number">3.11</span> Looking Ahead: Chapter 3 Preview</h2>
<p>Next chapter, we’ll explore <strong>Dynamic Programming</strong>—another powerful paradigm that, like divide and conquer, solves problems by breaking them into subproblems. But there’s a crucial difference:</p>
<p><strong>Divide and Conquer:</strong> Subproblems are independent <strong>Dynamic Programming:</strong> Subproblems overlap</p>
<p>This leads to a completely different approach: <strong>memorizing solutions</strong> to avoid recomputing them. You’ll learn to solve optimization problems that seem impossible at first glance:</p>
<ul>
<li><strong>Longest Common Subsequence:</strong> DNA sequence alignment, diff algorithms</li>
<li><strong>Knapsack Problem:</strong> Resource allocation, project selection</li>
<li><strong>Edit Distance:</strong> Spell checking, file comparison</li>
<li><strong>Matrix Chain Multiplication:</strong> Optimal computation order</li>
<li><strong>Shortest Paths:</strong> Navigation, network routing</li>
</ul>
<p>The techniques you’ve learned in this chapter—recursive thinking, recurrence relations, complexity analysis—will be essential foundations for dynamic programming.</p>
<hr>
</section>
<section id="chapter-2-exercises" class="level2" data-number="3.12">
<h2 data-number="3.12" class="anchored" data-anchor-id="chapter-2-exercises"><span class="header-section-number">3.12</span> Chapter 2 Exercises</h2>
<section id="theoretical-problems" class="level3" data-number="3.12.1">
<h3 data-number="3.12.1" class="anchored" data-anchor-id="theoretical-problems"><span class="header-section-number">3.12.1</span> Theoretical Problems</h3>
<p><strong>Problem 2.1: Recurrence Relations (20 points)</strong></p>
<p>Solve the following recurrences using the Master Theorem (or state why it doesn’t apply):</p>
<ol type="a">
<li>T(n) = 3T(n/4) + n log n b) T(n) = 4T(n/2) + n² log n<br>
</li>
<li>T(n) = T(n/3) + T(2n/3) + n d) T(n) = 16T(n/4) + n e) T(n) = 7T(n/3) + n²</li>
</ol>
<p>For those where Master Theorem doesn’t apply, solve using the recursion tree method.</p>
<hr>
<p><strong>Problem 2.2: Algorithm Design (25 points)</strong></p>
<p>Design a divide and conquer algorithm for the following problem:</p>
<p><strong>Problem:</strong> Find both the minimum and maximum elements in an array of n elements.</p>
<p><strong>Requirements:</strong> a) Write pseudocode for your algorithm b) Prove correctness using induction c) Write and solve the recurrence relation d) Compare with the naive approach (two separate passes) e) How many comparisons does your algorithm make? Can you prove this is optimal?</p>
<hr>
<p><strong>Problem 2.3: Merge Sort Analysis (20 points)</strong></p>
<p><strong>Part A:</strong> Modify merge sort to count the number of inversions in an array. (An inversion is a pair of indices i &lt; j where arr[i] &gt; arr[j])</p>
<p><strong>Part B:</strong> Prove that your algorithm correctly counts inversions.</p>
<p><strong>Part C:</strong> What is the time complexity of your algorithm?</p>
<p><strong>Part D:</strong> Apply your algorithm to: [8, 4, 2, 1]. Show all steps and the final inversion count.</p>
<hr>
<p><strong>Problem 2.4: QuickSort Probability (20 points)</strong></p>
<p><strong>Part A:</strong> What is the probability that QuickSort with random pivot selection chooses a “good” pivot (one that results in partitions of size at least n/4 and at most 3n/4)?</p>
<p><strong>Part B:</strong> Using this probability, argue why the expected number of “levels” of good splits is O(log n).</p>
<p><strong>Part C:</strong> Explain why this implies O(n log n) expected time.</p>
<hr>
</section>
<section id="programming-problems" class="level3" data-number="3.12.2">
<h3 data-number="3.12.2" class="anchored" data-anchor-id="programming-problems"><span class="header-section-number">3.12.2</span> Programming Problems</h3>
<p><strong>Problem 2.5: Hybrid Sorting Implementation (30 points)</strong></p>
<p>Implement a hybrid sorting algorithm that:</p>
<ul>
<li>Uses QuickSort for large partitions</li>
<li>Switches to Insertion Sort for small partitions</li>
<li>Uses median-of-three pivot selection</li>
<li>Includes three-way partitioning</li>
</ul>
<p><strong>Requirements:</strong></p>
<div class="sourceCode" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hybrid_sort(arr: List[<span class="bu">int</span>], threshold: <span class="bu">int</span> <span class="op">=</span> <span class="dv">10</span>) <span class="op">-&gt;</span> List[<span class="bu">int</span>]:</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Your implementation here.</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Must include all four features above.</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Test your implementation and compare performance against:</p>
<ul>
<li>Standard QuickSort</li>
<li>Merge Sort</li>
<li>Python’s built-in sorted()</li>
</ul>
<p>Generate performance plots for different input types and sizes.</p>
<hr>
<p><strong>Problem 2.6: Binary Search Variants (25 points)</strong></p>
<p>Implement the following binary search variants:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_first_occurrence(arr: List[<span class="bu">int</span>], target: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Find the first occurrence of target in sorted array."""</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_last_occurrence(arr: List[<span class="bu">int</span>], target: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Find the last occurrence of target in sorted array."""</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_insertion_point(arr: List[<span class="bu">int</span>], target: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Find where target should be inserted to maintain sorted order."""</span></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-13"><a href="#cb92-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_occurrences(arr: List[<span class="bu">int</span>], target: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb92-14"><a href="#cb92-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Count how many times target appears (must be O(log n))."""</span></span>
<span id="cb92-15"><a href="#cb92-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Write comprehensive tests for each function.</p>
<hr>
<p><strong>Problem 2.7: K-th Smallest Element (30 points)</strong></p>
<p>Implement QuickSelect to find the k-th smallest element in O(n) average time:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> quickselect(arr: List[<span class="bu">int</span>], k: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Find the k-th smallest element (0-indexed).</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Time Complexity: O(n) average case</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a><span class="co">        arr: Unsorted list</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a><span class="co">        k: Index of element to find (0 = smallest)</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a><span class="co">        The k-th smallest element</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Requirements:</strong> a) Implement with randomized pivot selection b) Prove the average-case O(n) time complexity c) Compare empirically with sorting the array first d) Test on arrays of size 10³, 10⁴, 10⁵, 10⁶</p>
<hr>
<p><strong>Problem 2.8: Merge K Sorted Lists (25 points)</strong></p>
<p><strong>Problem:</strong> Given k sorted lists, merge them into one sorted list efficiently.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_k_lists(lists: List[List[<span class="bu">int</span>]]) <span class="op">-&gt;</span> List[<span class="bu">int</span>]:</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Merge k sorted lists.</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="co">        [[1, 4, 7], [2, 5, 8], [3, 6, 9]]</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="co">        → [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Approach 1:</strong> Merge lists pairwise using divide and conquer <strong>Approach 2:</strong> Use a min-heap (preview of next chapter!)</p>
<p>Implement both approaches and compare:</p>
<ul>
<li>Time complexity (theoretical)</li>
<li>Actual performance</li>
<li>When is each approach better?</li>
</ul>
<hr>
</section>
<section id="challenge-problems" class="level3" data-number="3.12.3">
<h3 data-number="3.12.3" class="anchored" data-anchor-id="challenge-problems"><span class="header-section-number">3.12.3</span> Challenge Problems</h3>
<p><strong>Problem 2.9: Median of Two Sorted Arrays (35 points)</strong></p>
<p>Find the median of two sorted arrays in O(log(min(m,n))) time:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_median_sorted_arrays(arr1: List[<span class="bu">int</span>], arr2: List[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Find median of two sorted arrays.</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Must run in O(log(min(len(arr1), len(arr2)))) time.</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a><span class="co">        arr1 = [1, 3], arr2 = [2]</span></span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a><span class="co">        → 2.0 (median of [1, 2, 3])</span></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a><span class="co">        arr1 = [1, 2], arr2 = [3, 4]</span></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a><span class="co">        → 2.5 (median of [1, 2, 3, 4])</span></span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Hints:</strong></p>
<ul>
<li>Use binary search on the smaller array</li>
<li>Partition both arrays such that left halves contain smaller elements</li>
<li>Handle edge cases carefully</li>
</ul>
<hr>
<p><strong>Problem 2.10: Skyline Problem (40 points)</strong></p>
<p><strong>Problem:</strong> Given n rectangular buildings, each represented as [left, right, height], compute the “skyline” outline.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_skyline(buildings: List[List[<span class="bu">int</span>]]) <span class="op">-&gt;</span> List[List[<span class="bu">int</span>]]:</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Compute skyline using divide and conquer.</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a><span class="co">        buildings: List of [left, right, height]</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb96-8"><a href="#cb96-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb96-9"><a href="#cb96-9" aria-hidden="true" tabindex="-1"></a><span class="co">        List of [x, height] key points</span></span>
<span id="cb96-10"><a href="#cb96-10" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb96-11"><a href="#cb96-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Example:</span></span>
<span id="cb96-12"><a href="#cb96-12" aria-hidden="true" tabindex="-1"></a><span class="co">        buildings = [[2,9,10], [3,7,15], [5,12,12], [15,20,10], [19,24,8]]</span></span>
<span id="cb96-13"><a href="#cb96-13" aria-hidden="true" tabindex="-1"></a><span class="co">        → [[2,10], [3,15], [7,12], [12,0], [15,10], [20,8], [24,0]]</span></span>
<span id="cb96-14"><a href="#cb96-14" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb96-15"><a href="#cb96-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><strong>Requirements:</strong></p>
<ul>
<li>Use divide and conquer approach</li>
<li>Analyze time complexity</li>
<li>Handle overlapping buildings correctly</li>
<li>Test with complex cases</li>
</ul>
<hr>
</section>
</section>
<section id="additional-resources" class="level2" data-number="3.13">
<h2 data-number="3.13" class="anchored" data-anchor-id="additional-resources"><span class="header-section-number">3.13</span> Additional Resources</h2>
<section id="recommended-reading" class="level3" data-number="3.13.1">
<h3 data-number="3.13.1" class="anchored" data-anchor-id="recommended-reading"><span class="header-section-number">3.13.1</span> Recommended Reading</h3>
<p><strong>For Deeper Understanding:</strong></p>
<ul>
<li>CLRS Chapter 4: “Divide and Conquer”</li>
<li>Kleinberg &amp; Tardos Chapter 5: “Divide and Conquer”</li>
<li>Sedgewick &amp; Wayne: “Algorithms” Chapter 2</li>
</ul>
<p><strong>For Historical Context:</strong></p>
<ul>
<li>Hoare, C. A. R. (1962). “Quicksort” - Original paper</li>
<li>Strassen, V. (1969). “Gaussian Elimination is not Optimal”</li>
</ul>
<p><strong>For Advanced Topics:</strong></p>
<ul>
<li>Cormen, T. H. “Parallel Algorithms for Divide-and-Conquer”</li>
<li>Cache-Oblivious Algorithms by Frigo et al.</li>
</ul>
</section>
<section id="video-lectures" class="level3" data-number="3.13.2">
<h3 data-number="3.13.2" class="anchored" data-anchor-id="video-lectures"><span class="header-section-number">3.13.2</span> Video Lectures</h3>
<ul>
<li>MIT OCW 6.006: Lectures 3-4 (Sorting and Divide &amp; Conquer)</li>
<li>Stanford CS161: Lectures on QuickSort and Master Theorem</li>
<li>Sedgewick’s Coursera: “Mergesort” and “Quicksort” modules</li>
</ul>
</section>
<section id="practice-platforms" class="level3" data-number="3.13.3">
<h3 data-number="3.13.3" class="anchored" data-anchor-id="practice-platforms"><span class="header-section-number">3.13.3</span> Practice Platforms</h3>
<ul>
<li>LeetCode: Divide and Conquer tag</li>
<li>HackerRank: Sorting section</li>
<li>Codeforces: Problems tagged “divide and conquer”</li>
</ul>
<hr>
<p><strong>Next Chapter:</strong> Dynamic Programming - When Subproblems Overlap</p>
<p><em>“In recursion, you solve the big problem by solving smaller versions. In dynamic programming, you solve the small problems once and remember the answers.” - Preparing for Chapter 3</em></p>
<hr>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/01-introduction.html" class="pagination-link" aria-label="Advanced Algorithms: A Journey Through Computational Problem Solving">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Advanced Algorithms: A Journey Through Computational Problem Solving</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>