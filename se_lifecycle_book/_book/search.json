[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Introduction",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Complete Software Engineering Lifecycle</span>"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "Welcome",
    "text": "Welcome\nWelcome to The Complete Software Engineering Lifecycle!\nThis open textbook is designed for graduate students, practitioners, and educators who want a modern, practical, and project-driven exploration of software engineering.\nThe book follows the full lifecycle of software development—from requirements gathering to deployment and long-term maintenance—integrating both industry best practices and academic rigor.\nIt is written to accompany a 16-week graduate course but can also be used independently by teams and self-learners.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Complete Software Engineering Lifecycle</span>"
    ]
  },
  {
    "objectID": "index.html#abstract",
    "href": "index.html#abstract",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "Abstract",
    "text": "Abstract\nSoftware engineering is more than just writing code—it is a disciplined approach to designing, building, testing, deploying, and evolving complex software systems.\nThis book blends technical foundations, architectural patterns, and hands-on exercises that mirror the workflows used by professional engineering teams.\nWe explore:\n\nRequirements engineering and documentation\n\nUML and systems modeling\n\nSoftware architecture and design patterns\n\nVersion control and collaborative development\n\nTesting methodologies & quality assurance\n\nDevOps, CI/CD, and cloud deployment strategies\n\nSecurity, maintainability, and long-term evolution\n\nBy the end, you will have both the knowledge and the applied experience to engineer robust, scalable, and maintainable software systems—supported by a semester-long project that builds from chapter to chapter.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Complete Software Engineering Lifecycle</span>"
    ]
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy working through this book, you will be able to:\n\nAnalyze user needs and translate them into actionable software requirements\n\nModel systems using UML and architectural design principles\n\nApply software design patterns to build modular, extensible codebases\n\nUse Git and GitHub effectively for collaborative development\n\nImplement testing strategies across unit, integration, and acceptance levels\n\nDeploy applications using modern DevOps and cloud technologies\n\nIntegrate security, maintainability, and quality assurance into every stage of development\n\nDeliver a complete, professional software project—from concept to deployment",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Complete Software Engineering Lifecycle</span>"
    ]
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "License",
    "text": "License\nThis book is published by Global Data Science Institute (GDSI) as an\nOpen Educational Resource (OER).\nIt is licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) license.\nYou are free to share, adapt, and build upon this material for any purpose—even commercially—so long as proper attribution is provided.\n\n\n\nCC BY 4.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Complete Software Engineering Lifecycle</span>"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "How to Use This Book",
    "text": "How to Use This Book\n\nThe HTML edition is recommended for the best interactive reading experience.\n\nPDF and EPUB versions are available for offline reading.\n\nCode examples and templates are included in the /assets/code/ directory.\n\nEach chapter includes a project milestone, allowing you to build a complete software system as you progress.\n\nThis book pairs seamlessly with GitHub Classroom, GitHub Projects, and modern DevOps workflows.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>The Complete Software Engineering Lifecycle</span>"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for preface.qmd",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>preface.html</span>"
    ]
  },
  {
    "objectID": "acknowledgments.html",
    "href": "acknowledgments.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for acknowledgments.qmd",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>acknowledgments.html</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html",
    "href": "chapters/01-introduction.html",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "",
    "text": "4.1 Learning Objectives\nBy the end of this chapter, you will be able to:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#learning-objectives",
    "href": "chapters/01-introduction.html#learning-objectives",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "",
    "text": "Define software engineering and explain its significance in modern technology\nDescribe the evolution of software engineering as a discipline\nCompare and contrast major software development lifecycle (SDLC) models\nUnderstand the fundamentals of version control using Git and GitHub\nApply collaborative workflows for team-based software development\nSet up a project repository with proper structure and documentation",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#what-is-software-engineering",
    "href": "chapters/01-introduction.html#what-is-software-engineering",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.2 1.1 What Is Software Engineering?",
    "text": "4.2 1.1 What Is Software Engineering?\nImagine you’re building a house. You wouldn’t just start stacking bricks randomly and hope for the best, would you? You’d need blueprints, a foundation plan, electrical and plumbing designs, a construction schedule, quality inspections, and a team of specialists working together. Building software is remarkably similar—except instead of bricks and mortar, we work with code, data, and digital infrastructure.\nSoftware engineering is the systematic application of engineering principles to the design, development, testing, deployment, and maintenance of software systems. It’s not just about writing code that works; it’s about writing code that works reliably, efficiently, and maintainably over time.\nThe IEEE (Institute of Electrical and Electronics Engineers) defines software engineering as:\n\n“The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software.”\n\nThis definition highlights several key aspects:\n\nSystematic: Following organized methods and processes\nDisciplined: Adhering to standards and best practices\nQuantifiable: Measuring progress, quality, and outcomes\nComprehensive: Covering the entire lifecycle, not just coding\n\n\n1.1.1 Software Engineering vs. Programming\nA common misconception among newcomers is that software engineering and programming are the same thing. While programming is certainly a core skill within software engineering, the discipline encompasses much more.\n\n\n\n\n\n\n\n\nAspect\nProgramming\nSoftware Engineering\n\n\n\n\nFocus\nWriting code to solve specific problems\nDesigning and building complete systems\n\n\nScope\nIndividual tasks or features\nEntire product lifecycle\n\n\nTimeline\nShort-term\nLong-term (years of maintenance)\n\n\nTeam Size\nOften individual\nUsually collaborative\n\n\nDocumentation\nOptional or minimal\nEssential and comprehensive\n\n\nQuality Assurance\nAd-hoc testing\nSystematic testing strategies\n\n\nProcess\nFlexible, informal\nStructured methodologies\n\n\n\nThink of it this way: a programmer might write an excellent function to sort a list of names. A software engineer asks questions like: How will this sorting function integrate with the rest of the system? What happens when the list contains millions of names? How will we test it? Who will maintain it? How do we deploy updates without breaking existing functionality?\n\n\n1.1.2 A Brief History of Software Engineering\nThe term “software engineering” was first coined at the 1968 NATO Software Engineering Conference in Garmisch, Germany. This conference was convened in response to what was then called the software crisis—a period when software projects were consistently failing, running over budget, delivering late, and producing unreliable results.\nIn the early days of computing (1940s-1960s), software was often an afterthought. Hardware was expensive and precious; software was seen as a minor component. Programs were small, written by individuals, and often tied to specific machines. Documentation was rare, and the concept of “maintenance” barely existed—if a program didn’t work, you wrote a new one.\nAs computers became more powerful and widespread, software grew in complexity. The 1960s saw ambitious projects like IBM’s OS/360 operating system, which employed thousands of programmers and took years longer than planned. Frederick Brooks, who managed that project, later wrote “The Mythical Man-Month,” a seminal book that observed:\n\n“Adding manpower to a late software project makes it later.”\n\nThis counterintuitive insight—that you can’t just throw more programmers at a problem to solve it faster—underscored the need for better engineering practices.\nThe decades that followed brought waves of innovation in how we approach software development:\n\n1970s: Structured programming and the Waterfall model emerged\n1980s: Object-oriented programming and CASE (Computer-Aided Software Engineering) tools\n1990s: Component-based development, the rise of the internet, and early Agile ideas\n2000s: Agile Manifesto (2001), widespread adoption of iterative methods\n2010s: DevOps culture, continuous delivery, cloud computing\n2020s: AI-assisted development, platform engineering, and infrastructure as code\n\nToday, software engineering continues to evolve rapidly. The principles you’ll learn in this course represent decades of accumulated wisdom from millions of projects—both successful and failed.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#the-role-of-software-engineering-in-modern-systems",
    "href": "chapters/01-introduction.html#the-role-of-software-engineering-in-modern-systems",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.3 1.2 The Role of Software Engineering in Modern Systems",
    "text": "4.3 1.2 The Role of Software Engineering in Modern Systems\nSoftware has become the invisible infrastructure of modern civilization. Consider a typical morning: your smartphone alarm wakes you (software), you check the weather app (software connecting to distributed systems), your smart thermostat adjusts the temperature (embedded software), you drive to work with GPS navigation (software integrating satellite data), and you buy coffee with a tap of your phone (financial software processing transactions across multiple systems).\n\n1.2.1 Software Is Everywhere\nThe scale of software’s presence in our world is staggering:\nTransportation: Modern vehicles contain 100+ million lines of code. The Boeing 787 Dreamliner runs on approximately 6.5 million lines of code. Self-driving cars process terabytes of sensor data through sophisticated software systems.\nHealthcare: Electronic health records, diagnostic imaging systems, robotic surgery equipment, drug interaction databases, and pandemic tracking systems all depend on reliable software engineering.\nFinance: High-frequency trading systems execute millions of transactions per second. Banking apps handle trillions of dollars in transfers. Cryptocurrencies run on complex distributed software systems.\nCommunication: Social media platforms serve billions of users simultaneously. Video conferencing software enables global collaboration. Messaging apps deliver hundreds of billions of messages daily.\nInfrastructure: Power grids, water treatment plants, air traffic control systems, and emergency services all rely on software that must work correctly, all the time.\n\n\n1.2.2 The Cost of Software Failures\nWhen software fails, the consequences can range from minor inconveniences to catastrophic disasters. Understanding these failures helps us appreciate why rigorous software engineering practices matter.\nThe Therac-25 Accidents (1985-1987): A radiation therapy machine’s software bugs caused massive overdoses, killing at least three patients and seriously injuring others. The failures resulted from poor software design, inadequate testing, and the removal of hardware safety interlocks that had been present in earlier models.\nAriane 5 Explosion (1996): The European Space Agency’s rocket exploded 37 seconds after launch, resulting in a $370 million loss. The cause? A software error—specifically, an integer overflow when 64-bit floating-point data was converted to a 16-bit signed integer. Code reused from the Ariane 4 hadn’t been tested for the new rocket’s different flight parameters.\nKnight Capital Glitch (2012): A software deployment error caused a trading firm to lose $440 million in just 45 minutes. Old, deprecated code was accidentally activated, executing millions of unintended trades. The company nearly went bankrupt overnight.\nHealthcare.gov Launch (2013): The U.S. government’s health insurance marketplace website failed spectacularly at launch, unable to handle user traffic and plagued with bugs. The problems stemmed from inadequate testing, poor project management, and insufficient integration between components built by different contractors.\nThese examples share common themes: inadequate testing, poor communication, rushed timelines, and insufficient attention to software engineering principles. They demonstrate that software engineering isn’t just an academic exercise—it’s a matter of safety, economics, and public trust.\n\n\n1.2.3 The Value of Good Software Engineering\nConversely, excellent software engineering creates enormous value:\nReliability: Well-engineered systems work correctly, consistently, over time. Users trust them.\nScalability: Properly architected systems can grow to serve millions or billions of users without fundamental redesigns.\nMaintainability: Good engineering practices make it possible to fix bugs, add features, and adapt to changing requirements efficiently.\nSecurity: Systematic approaches to security protect users’ data and privacy.\nCost Efficiency: While good engineering requires upfront investment, it dramatically reduces long-term costs by preventing bugs, reducing technical debt, and enabling faster development of new features.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#the-software-development-life-cycle-sdlc",
    "href": "chapters/01-introduction.html#the-software-development-life-cycle-sdlc",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.4 1.3 The Software Development Life Cycle (SDLC)",
    "text": "4.4 1.3 The Software Development Life Cycle (SDLC)\nThe Software Development Life Cycle (SDLC) is a framework that describes the stages involved in building software, from initial concept through deployment and maintenance. Think of it as a roadmap for transforming an idea into a working system.\nWhile different methodologies organize these stages differently, most include some version of:\n\nRequirements: What should the system do?\nDesign: How will the system be structured?\nImplementation: Writing the actual code\nTesting: Verifying the system works correctly\nDeployment: Releasing the system to users\nMaintenance: Ongoing updates, fixes, and improvements\n\nDifferent SDLC models arrange these stages in different ways, with different philosophies about planning, flexibility, and iteration. Let’s explore the major models you’ll encounter in professional practice.\n\n1.3.1 The Waterfall Model\nThe Waterfall model is the oldest and most traditional approach to software development. Introduced by Winston Royce in 1970 (though he actually presented it as an example of a flawed approach!), it organizes development into sequential phases that flow downward, like a waterfall.\n┌─────────────────┐\n│   Requirements  │\n└────────┬────────┘\n         ▼\n┌─────────────────┐\n│     Design      │\n└────────┬────────┘\n         ▼\n┌─────────────────┐\n│ Implementation  │\n└────────┬────────┘\n         ▼\n┌─────────────────┐\n│    Testing      │\n└────────┬────────┘\n         ▼\n┌─────────────────┐\n│   Deployment    │\n└────────┬────────┘\n         ▼\n┌─────────────────┐\n│   Maintenance   │\n└─────────────────┘\nKey Characteristics:\n\nEach phase must be completed before the next begins\nExtensive documentation at each stage\nFormal reviews and sign-offs between phases\nChanges are difficult and expensive once a phase is complete\nTesting occurs late in the process\n\nWhen Waterfall Works Well:\n\nRequirements are well-understood and unlikely to change\nThe technology is mature and well-known\nThe project is relatively short\nRegulatory compliance requires extensive documentation\nThe customer can articulate complete requirements upfront\n\nWhen Waterfall Struggles:\n\nRequirements are unclear or likely to evolve\nThe project is long-term (requirements will change)\nRapid feedback is needed\nInnovation or experimentation is involved\nThe customer wants to see working software early\n\nExample Scenario: Developing software for a medical device that must meet FDA regulations might use Waterfall. The requirements are clear (based on medical standards), extensive documentation is mandatory, and changes after approval are extremely costly.\n\n\n1.3.2 Agile Methodology\nAgile is not a single methodology but a family of approaches that share common values and principles. The Agile Manifesto, published in 2001, articulates four core values:\n\nIndividuals and interactions over processes and tools\nWorking software over comprehensive documentation\nCustomer collaboration over contract negotiation\nResponding to change over following a plan\n\nThis doesn’t mean Agile ignores processes, documentation, contracts, or plans—but it prioritizes the items on the left when trade-offs must be made.\nThe Twelve Principles of Agile Software:\n\nSatisfy the customer through early and continuous delivery of valuable software\nWelcome changing requirements, even late in development\nDeliver working software frequently (weeks rather than months)\nBusiness people and developers must work together daily\nBuild projects around motivated individuals; give them support and trust\nFace-to-face conversation is the most effective communication method\nWorking software is the primary measure of progress\nMaintain a sustainable pace indefinitely\nContinuous attention to technical excellence and good design\nSimplicity—maximizing work not done—is essential\nSelf-organizing teams produce the best architectures and designs\nRegular reflection on how to become more effective\n\nCommon Agile Frameworks:\nScrum is the most popular Agile framework. It organizes work into fixed-length iterations called sprints (typically 2-4 weeks). Key elements include:\n\nProduct Backlog: Prioritized list of features and requirements\nSprint Planning: Team commits to work for the upcoming sprint\nDaily Standups: Brief daily meetings to synchronize the team\nSprint Review: Demonstration of completed work to stakeholders\nSprint Retrospective: Team reflects on process improvements\nRoles: Product Owner, Scrum Master, Development Team\n\nKanban focuses on visualizing workflow and limiting work in progress. Work items move across a board through stages (e.g., To Do → In Progress → Review → Done). Unlike Scrum, Kanban doesn’t use fixed-length iterations.\nExtreme Programming (XP) emphasizes technical practices like pair programming, test-driven development, continuous integration, and frequent releases.\nWhen Agile Works Well:\n\nRequirements are expected to change\nCustomer feedback is available regularly\nThe team is co-located or has good communication tools\nThe organization supports iterative delivery\nInnovation and adaptation are valued\n\nWhen Agile Struggles:\n\nFixed-price contracts with rigid specifications\nDistributed teams with poor communication\nRegulatory environments requiring extensive upfront documentation\nCustomers unwilling or unable to participate actively\nVery large-scale projects without proper scaling frameworks\n\n\n\n1.3.3 The Spiral Model\nThe Spiral model, proposed by Barry Boehm in 1986, emphasizes risk management. Development proceeds through multiple iterations, each passing through four phases:\n\nPlanning: Determine objectives, alternatives, and constraints\nRisk Analysis: Identify and evaluate risks; create prototypes\nEngineering: Develop and verify the product\nEvaluation: Review results and plan the next iteration\n\n                    Planning\n                       │\n           ┌──────────►│◄──────────┐\n           │           │           │\n           │           ▼           │\n    Evaluation ◄───────────► Risk Analysis\n           │           │           │\n           │           ▼           │\n           └──────────►│◄──────────┘\n                   Engineering\n                       │\n                    (repeat)\nEach loop around the spiral represents a more complete version of the software. Early iterations might produce paper prototypes or proof-of-concept code; later iterations produce the actual system.\nKey Characteristics:\n\nExplicit focus on identifying and mitigating risks\nCombines iterative development with systematic aspects of Waterfall\nPrototyping used to reduce uncertainty\nFlexibility to adapt the process to project needs\n\nWhen Spiral Works Well:\n\nLarge, complex projects\nHigh-risk systems where failure would be catastrophic\nProjects with uncertain or evolving requirements\nSituations requiring significant prototyping\n\n\n\n1.3.4 DevOps\nDevOps represents a cultural and technical movement that bridges the traditional gap between development (Dev) and operations (Ops) teams. Rather than a distinct SDLC model, DevOps is a set of practices that can be combined with other methodologies.\nTraditionally, developers wrote code and “threw it over the wall” to operations teams, who were responsible for deploying and maintaining it in production. This separation created friction: developers optimized for features and speed; operations optimized for stability and reliability. The result was slow deployments, finger-pointing when problems occurred, and systems that worked in development but failed in production.\nDevOps breaks down these silos through:\nCultural Practices:\n\nShared responsibility for the entire lifecycle\nBlameless post-mortems when things go wrong\nContinuous learning and improvement\nCollaboration between all roles\n\nTechnical Practices:\n\nContinuous Integration (CI): Automatically building and testing code whenever changes are committed\nContinuous Delivery (CD): Keeping software in a deployable state at all times\nContinuous Deployment: Automatically deploying every change that passes tests\nInfrastructure as Code: Managing servers and environments through version-controlled scripts\nMonitoring and Logging: Comprehensive visibility into system behavior\nAutomated Testing: Extensive test suites that run automatically\n\nThe DevOps Lifecycle:\n    ┌───────────────────────────────────────────────────┐\n    │                                                   │\n    ▼                                                   │\n┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐│\n│ Plan │───►│ Code │───►│Build │───►│ Test │───►│Release│\n└──────┘    └──────┘    └──────┘    └──────┘    └──────┘│\n                                                   │    │\n    ┌───────────────────────────────────────────────    │\n    │                                                   │\n    ▼                                                   │\n┌──────┐    ┌──────┐    ┌──────┐                       │\n│Deploy│───►│Operate│───►│Monitor│───────────────────────┘\n└──────┘    └──────┘    └──────┘\nThe cycle is continuous—monitoring in production feeds back into planning for the next iteration.\nKey DevOps Metrics:\n\nDeployment Frequency: How often you release to production\nLead Time for Changes: Time from commit to production\nMean Time to Recovery (MTTR): How quickly you recover from failures\nChange Failure Rate: Percentage of deployments causing problems\n\nHigh-performing DevOps organizations deploy multiple times per day, with lead times measured in hours, recover from failures in minutes, and have change failure rates below 15%.\n\n\n1.3.5 Choosing an SDLC Model\nNo single model is universally best. The right choice depends on your project’s characteristics:\n\n\n\nFactor\nWaterfall\nAgile\nSpiral\nDevOps\n\n\n\n\nRequirement stability\nHigh\nLow\nVariable\nVariable\n\n\nProject size\nAny\nSmall-Medium\nLarge\nAny\n\n\nRisk level\nLow\nLow-Medium\nHigh\nVariable\n\n\nCustomer involvement\nLow\nHigh\nMedium\nMedium\n\n\nDocumentation needs\nHigh\nLow-Medium\nHigh\nMedium\n\n\nDelivery frequency\nEnd\nFrequent\nIterative\nContinuous\n\n\nTeam experience\nAny\nExperienced\nExperienced\nExperienced\n\n\n\nIn practice, many organizations use hybrid approaches. For example, a team might use Scrum for iteration planning while implementing DevOps practices for CI/CD, or use a Spiral approach at the program level while individual teams work in Agile sprints.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#version-control-with-git-and-github",
    "href": "chapters/01-introduction.html#version-control-with-git-and-github",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.5 1.4 Version Control with Git and GitHub",
    "text": "4.5 1.4 Version Control with Git and GitHub\nVersion control is one of the most fundamental tools in a software engineer’s toolkit. It solves a problem you’ve probably encountered even outside of programming: how do you track changes to documents over time, collaborate with others, and recover from mistakes?\n\n1.4.1 Why Version Control Matters\nWithout version control, teams resort to chaotic practices:\n\nFiles named project_final.doc, project_final_v2.doc, project_REALLY_final.doc\nEmailing files back and forth\nCopying entire folders as “backups”\nOverwriting each other’s changes\nNo way to see what changed, when, or why\n\nVersion control systems solve these problems by:\n\nTracking every change to every file\nRecording who made each change and why\nEnabling multiple people to work simultaneously\nAllowing you to revert to any previous state\nSupporting parallel lines of development (branches)\nFacilitating code review and collaboration\n\n\n\n1.4.2 Understanding Git\nGit is the dominant version control system in software development today. Created by Linus Torvalds in 2005 (yes, the same person who created Linux), Git is distributed, fast, and powerful.\nKey Concepts:\nRepository (Repo): A repository is a directory containing your project files plus a hidden .git folder that stores the complete history of all changes. Every team member has a complete copy of the repository.\nCommit: A commit is a snapshot of your project at a specific point in time. Each commit has a unique identifier (SHA hash), a message describing the change, and metadata about the author and timestamp.\ncommit 7f4e8d2 (HEAD -&gt; main)\nAuthor: Jane Developer &lt;jane@example.com&gt;\nDate:   Mon Jan 15 10:30:00 2025 -0500\n\n    Add user authentication module\n    \n    - Implement login/logout functionality\n    - Add password hashing with bcrypt\n    - Create session management\nBranch: A branch is an independent line of development. You might create a branch to work on a new feature without affecting the main codebase. Once the feature is complete and tested, you merge it back.\n         feature-auth\n            ┌──●──●──●\n           ╱           ╲\n●──●──●──●──────────────●──●  main\n       ↑                 ↑\n   branch point        merge\nStaging Area (Index): Before committing, you add changes to the staging area. This lets you control exactly what goes into each commit—you might have modified five files but only want to commit three.\nRemote: A remote is a copy of your repository hosted on a server (like GitHub). You push your local commits to the remote and pull others’ commits from it.\n\n\n1.4.3 Essential Git Commands\nLet’s walk through the fundamental Git operations you’ll use daily.\nInitial Setup:\n# Configure your identity (do this once)\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\nCreating a Repository:\n# Initialize a new repository\ngit init\n\n# Or clone an existing one\ngit clone https://github.com/username/repository.git\nBasic Workflow:\n# Check status of your working directory\ngit status\n\n# Add files to staging area\ngit add filename.py        # Add specific file\ngit add .                  # Add all changes\n\n# Commit staged changes\ngit commit -m \"Describe what this commit does\"\n\n# View commit history\ngit log\ngit log --oneline          # Compact view\nWorking with Remotes:\n# Add a remote (usually done once)\ngit remote add origin https://github.com/username/repo.git\n\n# Push commits to remote\ngit push origin main\n\n# Pull commits from remote\ngit pull origin main\n\n# Fetch without merging\ngit fetch origin\nBranching:\n# Create a new branch\ngit branch feature-name\n\n# Switch to a branch\ngit checkout feature-name\n\n# Create and switch in one command\ngit checkout -b feature-name\n\n# List all branches\ngit branch -a\n\n# Merge a branch into current branch\ngit merge feature-name\n\n# Delete a branch\ngit branch -d feature-name\n\n\n1.4.4 GitHub and Remote Collaboration\nGitHub is a web-based platform that hosts Git repositories and adds collaboration features. While Git handles version control, GitHub provides:\n\nRemote Hosting: Store your repositories in the cloud\nPull Requests: Propose changes for review before merging\nIssues: Track bugs, features, and tasks\nProjects: Kanban-style project management boards\nActions: Automated workflows (CI/CD)\nWikis: Project documentation\nSocial Features: Stars, forks, followers\n\nThe GitHub Flow:\nThe most common collaborative workflow on GitHub follows these steps:\n\nCreate a Branch: Start from main with a descriptive branch name\n\ngit checkout -b feature/user-authentication\n\nMake Changes: Write code, commit frequently with clear messages\n\ngit add .\ngit commit -m \"Add login form component\"\ngit commit -m \"Implement authentication API endpoint\"\ngit commit -m \"Add input validation\"\n\nPush to GitHub: Upload your branch to the remote\n\ngit push origin feature/user-authentication\n\nOpen a Pull Request: On GitHub, create a PR to merge your branch into main. Describe what you’ve done and why.\nCode Review: Team members review your changes, leave comments, and request modifications if needed.\nAddress Feedback: Make additional commits to address review comments.\nMerge: Once approved, merge the PR into main. Delete the feature branch.\nDeploy: The merge to main may trigger automated deployment.\n\n\n\n1.4.5 Writing Good Commit Messages\nCommit messages are documentation for your future self and your team. Good messages make it easy to understand the project history and find specific changes.\nStructure of a Good Commit Message:\nShort summary (50 chars or less)\n\nMore detailed explanation if necessary. Wrap at 72 characters.\nExplain the what and why, not the how (the code shows how).\n\n- Bullet points are okay\n- Use the imperative mood: \"Add feature\" not \"Added feature\"\n\nFixes #123\nExamples of Good Commit Messages:\nAdd password strength indicator to registration form\n\nUsers were creating weak passwords. This adds a visual indicator\nshowing password strength in real-time, using the zxcvbn library\nfor strength estimation.\n\nCloses #456\nFix memory leak in image processing module\n\nThe image processor wasn't releasing buffer memory after use,\ncausing memory consumption to grow unbounded during batch processing.\nAdded explicit cleanup in the finally block.\nExamples of Poor Commit Messages:\nfix bug\nUpdates\nWIP\nasdfasdf\n\n\n1.4.6 Repository Structure and Documentation\nA well-organized repository helps team members navigate the codebase and understand the project. Here’s a typical structure:\nmy-project/\n├── .github/\n│   ├── workflows/          # CI/CD workflow definitions\n│   └── ISSUE_TEMPLATE.md   # Template for bug reports\n├── docs/                   # Documentation\n├── src/                    # Source code\n│   ├── components/\n│   ├── services/\n│   └── utils/\n├── tests/                  # Test files\n├── .gitignore              # Files Git should ignore\n├── LICENSE                 # Software license\n├── README.md               # Project overview\n├── CONTRIBUTING.md         # Contribution guidelines\n└── package.json            # Dependencies (for Node.js projects)\nThe README File:\nThe README is often the first thing visitors see. A good README includes:\n\nProject Title and Description: What does this project do?\nInstallation Instructions: How do I set this up?\nUsage Examples: How do I use it?\nConfiguration: What can I customize?\nContributing: How can I help?\nLicense: What are the terms of use?\n\nThe .gitignore File:\nThis file tells Git which files and directories to ignore. You typically ignore:\n\nBuild outputs and compiled files\nDependencies (which can be reinstalled)\nIDE configuration files\nEnvironment files with secrets\nLog files\n\nExample .gitignore:\n# Dependencies\nnode_modules/\nvenv/\n\n# Build outputs\ndist/\nbuild/\n*.pyc\n\n# Environment files\n.env\n.env.local\n\n# IDE files\n.vscode/\n.idea/\n\n# Logs\n*.log",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#collaborative-workflows",
    "href": "chapters/01-introduction.html#collaborative-workflows",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.6 1.5 Collaborative Workflows",
    "text": "4.6 1.5 Collaborative Workflows\nSoftware development is inherently collaborative. Even if you’re the only developer on a project, you’re collaborating with your future self (who will have forgotten why you wrote that code) and potentially with future maintainers.\n\n1.5.1 Branching Strategies\nTeams adopt branching strategies to coordinate work and maintain code quality. Here are the most common approaches:\nGitHub Flow:\nThe simplest strategy, ideal for continuous deployment:\n\nmain is always deployable\nCreate feature branches from main\nOpen pull requests for review\nMerge back to main after approval\nDeploy from main\n\n●──●──●──●──●──●──●──●  main\n   │     │        │\n   └─●───┘        └──●──●─┘  feature branches\nGitflow:\nA more structured approach for projects with scheduled releases:\n\nmain: Production-ready code\ndevelop: Integration branch for features\nfeature/*: Individual features\nrelease/*: Preparation for release\nhotfix/*: Emergency production fixes\n\n●─────────────────●───────────●  main\n ╲               ╱           ╱\n  ●──●──●──●──●──●──●──●────●   develop\n     │     │           │\n     └─●───┘           └──●──●─┘  features\nTrunk-Based Development:\nOptimized for continuous integration:\n\nEveryone commits to main (trunk) frequently\nFeature flags hide incomplete work\nShort-lived branches (&lt; 1 day) if any\nRequires strong CI/CD and testing\n\n\n\n1.5.2 Code Reviews\nCode review is the practice of having team members examine each other’s code before it’s merged. Benefits include:\n\nQuality: Catching bugs, design issues, and edge cases\nKnowledge Sharing: Team members learn from each other\nConsistency: Maintaining code style and architectural decisions\nMentorship: Senior developers guide junior developers\n\nEffective Code Reviews:\nAs a reviewer:\n\nBe constructive and kind—critique code, not people\nExplain why something should change, not just what\nDistinguish between requirements and suggestions\nApprove promptly when issues are addressed\nLook for logic errors, security issues, and maintainability\n\nAs an author:\n\nKeep pull requests small and focused\nWrite clear descriptions explaining context\nRespond to feedback professionally\nDon’t take criticism personally\n\n\n\n1.5.3 Communication Tools\nModern software teams use various tools to collaborate:\n\nIssue Trackers (GitHub Issues, Jira): Track bugs and features\nDocumentation Platforms (Confluence, Notion): Share knowledge\nChat (Slack, Discord): Real-time communication\nVideo Conferencing (Zoom, Meet): Face-to-face meetings\nDesign Tools (Figma, Miro): Visual collaboration",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#your-semester-project",
    "href": "chapters/01-introduction.html#your-semester-project",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.7 1.6 Your Semester Project",
    "text": "4.7 1.6 Your Semester Project\nThis course is organized around a semester-long project where you’ll apply everything you learn. By the end, you’ll have built a complete software system from requirements through deployment.\n\n1.6.1 Project Overview\nYou (or your team) will develop a software system of your choice. Examples include:\n\nAn appointment scheduling system\nA small e-commerce platform\nAn inventory management tool\nA classroom collaboration tool\nAn API service for a specific domain\nA task management application\nA personal finance tracker\n\nThe specific application matters less than demonstrating mastery of software engineering practices. A simple, well-engineered system is better than an ambitious, poorly executed one.\n\n\n1.6.2 Weekly Milestones\nEach week, you’ll complete a milestone that builds toward the final product:\n\n\n\nWeek\nMilestone\n\n\n\n\n1\nProject proposal and repository setup\n\n\n2\nSoftware Requirements Specification\n\n\n3\nUML diagrams\n\n\n4\nArchitecture and design document\n\n\n5\nUI/UX prototype\n\n\n6\nAgile sprint plan\n\n\n7\nFeature branch and pull request\n\n\n8\nWorking prototype (midterm)\n\n\n9\nTest suite\n\n\n10\nCI pipeline and QA report\n\n\n11\nDatabase and API documentation\n\n\n12\nDeployed application\n\n\n13\nSecurity enhancements\n\n\n14\nDocumentation package\n\n\n15\nRelease candidate\n\n\n16\nFinal presentation\n\n\n\n\n\n1.6.3 This Week’s Deliverables\nFor Week 1, you need to:\n\nCreate a GitHub Repository\n\nInitialize with a README\nAdd a .gitignore appropriate for your technology stack\nSet up initial folder structure\n\nWrite a Project Proposal including:\n\nProblem statement: What problem does your system solve?\nTarget users: Who will use this system?\nHigh-level features: What will the system do?\nTechnology choices: What languages/frameworks/tools will you use?\nSuccess criteria: How will you know if the project succeeds?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#chapter-summary",
    "href": "chapters/01-introduction.html#chapter-summary",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.8 1.7 Chapter Summary",
    "text": "4.8 1.7 Chapter Summary\nSoftware engineering is the disciplined application of engineering principles to software development. Unlike ad-hoc programming, it encompasses the entire lifecycle of software systems, from initial conception through years of maintenance and evolution.\nKey takeaways from this chapter:\n\nSoftware engineering emerged from the software crisis of the 1960s, when projects consistently failed due to lack of systematic approaches.\nModern systems depend on software in virtually every domain. Failures can cost lives and billions of dollars; good engineering creates enormous value.\nThe SDLC provides a framework for organizing development activities. Different models—Waterfall, Agile, Spiral, DevOps—suit different project characteristics.\nWaterfall works well for stable requirements and regulated environments but struggles with change.\nAgile embraces change and delivers working software frequently through iterative development.\nSpiral emphasizes risk management through prototyping and iteration.\nDevOps bridges development and operations, enabling continuous delivery and rapid feedback.\nGit provides version control, tracking every change to your codebase and enabling collaboration.\nGitHub adds collaboration features like pull requests, issues, and project management tools.\nEffective collaboration requires good branching strategies, code reviews, and communication.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#key-terms",
    "href": "chapters/01-introduction.html#key-terms",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.9 1.8 Key Terms",
    "text": "4.9 1.8 Key Terms\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nSoftware Engineering\nSystematic application of engineering principles to software development\n\n\nSDLC\nSoftware Development Life Cycle; framework for development stages\n\n\nWaterfall\nSequential SDLC model with distinct phases\n\n\nAgile\nIterative approach emphasizing flexibility and customer collaboration\n\n\nScrum\nAgile framework using sprints and defined roles\n\n\nDevOps\nCultural and technical practices bridging development and operations\n\n\nCI/CD\nContinuous Integration and Continuous Delivery/Deployment\n\n\nRepository\nA directory tracked by version control containing project files and history\n\n\nCommit\nA snapshot of changes in a version control system\n\n\nBranch\nAn independent line of development\n\n\nPull Request\nA proposal to merge changes, enabling code review\n\n\nMerge\nCombining changes from one branch into another",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#review-questions",
    "href": "chapters/01-introduction.html#review-questions",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.10 1.9 Review Questions",
    "text": "4.10 1.9 Review Questions\n\nHow does software engineering differ from programming? Give three specific examples of activities that are part of software engineering but not typically part of programming.\nDescribe the software crisis that led to the term “software engineering.” What characteristics of software projects during this period prompted the need for engineering discipline?\nCompare and contrast the Waterfall and Agile approaches. For each, describe a project scenario where that approach would be most appropriate.\nWhat are the four core values of the Agile Manifesto? In your own words, explain what each value means in practice.\nExplain the relationship between DevOps culture and CI/CD practices. How do they reinforce each other?\nWhat is the difference between git add and git commit? Why does Git have a staging area?\nDescribe the GitHub Flow workflow. What are the key steps, and why is each important?\nWhat makes a good commit message? Write an example of a good commit message for adding a search feature to a web application.\nWhy is code review valuable? List at least three benefits for the team and three things to look for when reviewing someone else’s code.\nConsider the software running an ATM machine. What SDLC model(s) might be appropriate for developing and maintaining this system? Justify your answer.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#hands-on-exercises",
    "href": "chapters/01-introduction.html#hands-on-exercises",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.11 1.10 Hands-On Exercises",
    "text": "4.11 1.10 Hands-On Exercises\n\nExercise 1.1: Git Basics\nPractice the fundamental Git commands:\n# Create a new directory and initialize a repository\nmkdir git-practice\ncd git-practice\ngit init\n\n# Create a file and make your first commit\necho \"# Git Practice\" &gt; README.md\ngit add README.md\ngit commit -m \"Initial commit: Add README\"\n\n# Make changes and commit again\necho \"This is a practice repository.\" &gt;&gt; README.md\ngit add README.md\ngit commit -m \"Add description to README\"\n\n# View your history\ngit log --oneline\n\n\nExercise 1.2: Branching Practice\nCreate and merge a feature branch:\n# Create and switch to a new branch\ngit checkout -b feature/add-gitignore\n\n# Create a .gitignore file\necho \"*.log\" &gt; .gitignore\necho \"node_modules/\" &gt;&gt; .gitignore\ngit add .gitignore\ngit commit -m \"Add .gitignore file\"\n\n# Switch back to main and merge\ngit checkout main\ngit merge feature/add-gitignore\n\n# Delete the feature branch\ngit branch -d feature/add-gitignore\n\n\nExercise 1.3: Repository Setup\nSet up your semester project repository:\n\nCreate a new repository on GitHub\nClone it to your local machine\nCreate an appropriate folder structure\nAdd a comprehensive README with project description\nCreate a .gitignore for your technology stack\nMake your initial commit and push to GitHub\n\n\n\nExercise 1.4: Project Proposal\nWrite a one-page project proposal including:\n\nProject title\nProblem statement (2-3 paragraphs)\nTarget users\nKey features (5-10 bullet points)\nProposed technology stack\nAnticipated challenges\nSuccess criteria",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#further-reading",
    "href": "chapters/01-introduction.html#further-reading",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.12 1.11 Further Reading",
    "text": "4.12 1.11 Further Reading\nBooks:\n\nBrooks, F. P. (1995). The Mythical Man-Month: Essays on Software Engineering (Anniversary Edition). Addison-Wesley.\nSommerville, I. (2015). Software Engineering (10th Edition). Pearson.\nBeck, K. et al. (2001). Manifesto for Agile Software Development. agilemanifesto.org\n\nOnline Resources:\n\nPro Git Book (free online): https://git-scm.com/book\nGitHub Guides: https://guides.github.com\nAtlassian Git Tutorials: https://www.atlassian.com/git/tutorials\nThe Twelve-Factor App: https://12factor.net",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/01-introduction.html#references",
    "href": "chapters/01-introduction.html#references",
    "title": "4  Chapter 1: Introduction to Software Engineering",
    "section": "4.13 References",
    "text": "4.13 References\nBeck, K., Beedle, M., van Bennekum, A., Cockburn, A., Cunningham, W., Fowler, M., … & Thomas, D. (2001). Manifesto for Agile Software Development. Retrieved from https://agilemanifesto.org/\nBoehm, B. W. (1988). A spiral model of software development and enhancement. Computer, 21(5), 61-72.\nBrooks, F. P. (1995). The Mythical Man-Month: Essays on Software Engineering (Anniversary Edition). Addison-Wesley.\nIEEE. (1990). IEEE Standard Glossary of Software Engineering Terminology (IEEE Std 610.12-1990).\nKim, G., Humble, J., Debois, P., & Willis, J. (2016). The DevOps Handbook. IT Revolution Press.\nRoyce, W. W. (1970). Managing the development of large software systems. Proceedings of IEEE WESCON, 26(8), 1-9.\nSchwaber, K., & Sutherland, J. (2020). The Scrum Guide. Scrum.org.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 1: Introduction to Software Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html",
    "href": "chapters/02-requirements-engineering.html",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "",
    "text": "5.1 Learning Objectives\nBy the end of this chapter, you will be able to:",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#learning-objectives",
    "href": "chapters/02-requirements-engineering.html#learning-objectives",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "",
    "text": "Explain the importance of requirements engineering in software projects\nDistinguish between functional and non-functional requirements\nApply various requirements elicitation techniques to gather stakeholder needs\nWrite effective user stories with clear acceptance criteria\nCreate a comprehensive Software Requirements Specification (SRS) document\nDevelop and maintain a Requirements Traceability Matrix (RTM)\nIdentify and manage common requirements engineering challenges",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#the-foundation-of-software-projects",
    "href": "chapters/02-requirements-engineering.html#the-foundation-of-software-projects",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.2 2.1 The Foundation of Software Projects",
    "text": "5.2 2.1 The Foundation of Software Projects\nPicture this scenario: A client approaches your development team with an exciting idea. “I want an app,” they say, “that helps people manage their tasks. You know, like a to-do list, but better.” Your team gets to work immediately, spending three months building what you believe is an excellent task management application. You present the finished product, and the client’s face falls. “This isn’t what I meant at all. I needed something for teams to collaborate on projects, not a personal to-do list. And where’s the integration with our existing calendar system?”\nThis scenario plays out in software projects far more often than anyone would like to admit. Studies consistently show that a significant percentage of software project failures can be traced back to poor requirements—requirements that were incomplete, ambiguous, misunderstood, or simply wrong.\nRequirements engineering is the systematic process of discovering, documenting, validating, and managing the requirements for a software system. It answers the fundamental question: What should this system do?\n\n2.1.1 Why Requirements Matter\nRequirements engineering might seem like overhead—time spent not writing code. But consider the economics of software defects. The cost of fixing a bug increases dramatically depending on when it’s discovered:\n\n\n\nPhase Discovered\nRelative Cost to Fix\n\n\n\n\nRequirements\n1x\n\n\nDesign\n5x\n\n\nImplementation\n10x\n\n\nTesting\n20x\n\n\nAfter Release\n50-200x\n\n\n\nA requirement error caught during the requirements phase might take an hour to fix—a conversation to clarify what the customer actually needs. That same error, if it survives into production code, might require redesigning components, rewriting thousands of lines of code, updating tests, redeploying, and dealing with unhappy users.\nThe Standish Group’s research on software projects has consistently found that the top factors in project success include:\n\nClear statement of requirements\nUser involvement throughout the project\nRealistic expectations\nClear vision and objectives\n\nNotice that three of these four factors relate directly to requirements engineering.\n\n\n2.1.2 The Requirements Engineering Process\nRequirements engineering is not a one-time activity but an ongoing process throughout the project lifecycle. It typically involves four main activities:\n1. Elicitation: Discovering requirements from stakeholders, documents, existing systems, and domain knowledge. This is often the most challenging phase because stakeholders may not know what they want, may disagree with each other, or may have difficulty articulating their needs.\n2. Analysis: Examining requirements for conflicts, ambiguities, and incompleteness. This phase involves prioritization, negotiation between stakeholders, and feasibility assessment.\n3. Specification: Documenting requirements in a clear, precise, and verifiable form. The output is typically a Software Requirements Specification (SRS) document.\n4. Validation: Ensuring that the documented requirements actually reflect stakeholder needs and that they are achievable within project constraints.\n┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n│ Elicitation │────►│  Analysis   │────►│Specification│────►│ Validation  │\n└─────────────┘     └─────────────┘     └─────────────┘     └─────────────┘\n       ▲                   │                   │                   │\n       │                   │                   │                   │\n       └───────────────────┴───────────────────┴───────────────────┘\n                         (Iterative Process)\nThese activities are iterative and often overlap. As you document requirements (specification), you’ll discover gaps that require more elicitation. Validation might reveal conflicts that require additional analysis. Requirements engineering continues throughout the project as understanding deepens and circumstances change.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#types-of-requirements",
    "href": "chapters/02-requirements-engineering.html#types-of-requirements",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.3 2.2 Types of Requirements",
    "text": "5.3 2.2 Types of Requirements\nRequirements come in different forms, each serving a different purpose. Understanding these categories helps ensure comprehensive coverage of what a system must do and how well it must do it.\n\n2.2.1 Functional Requirements\nFunctional requirements describe what the system should do—the specific behaviors, features, and functions it must provide. They define the system’s capabilities and how it should respond to particular inputs or situations.\nFunctional requirements typically follow this pattern: The system shall [perform some action] when [some condition occurs].\nExamples of Functional Requirements:\nFor an e-commerce system:\n\nThe system shall allow users to search for products by name, category, or price range\nThe system shall calculate shipping costs based on destination and package weight\nThe system shall send an email confirmation when an order is placed\nThe system shall allow users to save items to a wishlist\nThe system shall process payments through credit cards, debit cards, and PayPal\n\nFor a library management system:\n\nThe system shall allow librarians to add new books to the catalog\nThe system shall track which member has borrowed each book\nThe system shall calculate and display overdue fines\nThe system shall send reminder notifications three days before a book is due\nThe system shall allow members to reserve books that are currently checked out\n\nCharacteristics of Good Functional Requirements:\n\nSpecific: Precisely defines behavior without ambiguity\nMeasurable: Can be objectively verified through testing\nAchievable: Technically feasible within project constraints\nRelevant: Directly supports user or business needs\nTraceable: Can be linked to business objectives and test cases\n\n\n\n2.2.2 Non-Functional Requirements\nNon-functional requirements (NFRs) describe how well the system performs its functions—the quality attributes, constraints, and characteristics that define the system’s operational qualities. They’re sometimes called “quality requirements” or “-ilities” (because many end in “-ility”: reliability, scalability, usability, etc.).\nNon-functional requirements often have more impact on system architecture than functional requirements. You can add a search feature to an existing architecture, but retrofitting a system to handle millions of concurrent users requires fundamental architectural decisions.\nCategories of Non-Functional Requirements:\nPerformance Requirements specify response times, throughput, and capacity:\n\nThe system shall respond to search queries within 2 seconds\nThe system shall support 10,000 concurrent users\nThe system shall process at least 100 transactions per second\nPage load time shall not exceed 3 seconds on a 4G mobile connection\n\nReliability Requirements specify uptime, availability, and fault tolerance:\n\nThe system shall maintain 99.9% uptime (less than 8.76 hours downtime per year)\nThe system shall recover from failures within 5 minutes\nNo data loss shall occur during system crashes\nThe system shall maintain full functionality when one database server fails\n\nSecurity Requirements specify protection against threats:\n\nAll passwords shall be stored using bcrypt with a minimum cost factor of 12\nThe system shall lock accounts after 5 failed login attempts\nAll data transmission shall use TLS 1.3 or higher\nUser sessions shall expire after 30 minutes of inactivity\nThe system shall log all access to sensitive data\n\nUsability Requirements specify ease of use and user experience:\n\nNew users shall be able to complete a purchase within 5 minutes without training\nThe system shall be accessible according to WCAG 2.1 Level AA guidelines\nError messages shall clearly explain what went wrong and how to fix it\nThe system shall work on screens from 320px to 4K resolution\n\nScalability Requirements specify growth capacity:\n\nThe system architecture shall support horizontal scaling to 10x current load\nDatabase design shall accommodate 100 million records without performance degradation\nThe system shall support adding new geographic regions within 2 weeks\n\nMaintainability Requirements specify ease of modification:\n\nCode shall achieve a minimum of 80% test coverage\nAll public APIs shall include documentation\nThe system shall support zero-downtime deployments\nConfiguration changes shall not require code redeployment\n\nCompliance Requirements specify regulatory and legal constraints:\n\nThe system shall comply with GDPR data protection requirements\nPayment processing shall comply with PCI DSS Level 1\nMedical records handling shall comply with HIPAA regulations\nThe system shall maintain audit logs for 7 years\n\n\n\n2.2.3 The Relationship Between Functional and Non-Functional Requirements\nFunctional and non-functional requirements are deeply intertwined. Consider a simple requirement: “The system shall allow users to search for products.”\nThis functional requirement raises many non-functional questions:\n\nHow fast should search results appear? (Performance)\nHow many products should the search handle? (Scalability)\nWhat happens if the search service fails? (Reliability)\nHow intuitive should the search interface be? (Usability)\nShould search queries be logged? For how long? (Compliance)\n\nA complete specification addresses both what the system does and how well it does it.\n\n\n2.2.4 Constraints and Assumptions\nBeyond functional and non-functional requirements, specifications often include:\nConstraints are restrictions on how the system can be built:\n\nThe system must be developed using Java 17\nThe database must be PostgreSQL (existing enterprise license)\nDevelopment must be completed within 6 months\nThe budget cannot exceed $500,000\nThe system must integrate with the existing SAP installation\n\nAssumptions are conditions believed to be true but not verified:\n\nUsers will have modern web browsers (released within the last 2 years)\nNetwork connectivity between offices is reliable\nThe client will provide access to subject matter experts during development\nCurrent server infrastructure has capacity for the new system\n\nDocumenting constraints and assumptions is crucial because they can significantly impact design decisions, and invalid assumptions are a common source of project problems.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#requirements-elicitation-techniques",
    "href": "chapters/02-requirements-engineering.html#requirements-elicitation-techniques",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.4 2.3 Requirements Elicitation Techniques",
    "text": "5.4 2.3 Requirements Elicitation Techniques\nElicitation—discovering what stakeholders actually need—is often the most challenging aspect of requirements engineering. Stakeholders may not know what they want, may have conflicting needs, or may have difficulty expressing their requirements in terms developers can use.\nEffective elicitation requires multiple techniques, as different approaches work better for different types of requirements and different stakeholders.\n\n2.3.1 Stakeholder Interviews\nInterviews are one-on-one or small group conversations with stakeholders to understand their needs, expectations, and concerns. They’re particularly useful for understanding the context, goals, and priorities behind requirements.\nTypes of Interviews:\nStructured interviews follow a predetermined set of questions asked in a specific order. They ensure consistency across multiple interviews and are useful when you need to compare responses from different stakeholders.\nUnstructured interviews are open-ended conversations that follow wherever the discussion leads. They’re useful early in the project when you’re still discovering the problem domain.\nSemi-structured interviews combine elements of both: a prepared set of questions with flexibility to explore interesting tangents.\nInterview Best Practices:\nBefore the interview:\n\nResearch the stakeholder’s role and background\nPrepare questions but be ready to deviate\nSchedule appropriate time (typically 45-60 minutes)\nClarify the interview’s purpose with the stakeholder\n\nDuring the interview:\n\nStart with open-ended questions (“Tell me about your current workflow…”)\nListen more than you talk (aim for 80/20)\nAsk follow-up questions to dig deeper\nAvoid leading questions that suggest answers\nTake notes, but maintain eye contact\nUse active listening techniques (paraphrasing, summarizing)\n\nAfter the interview:\n\nWrite up notes immediately while details are fresh\nIdentify follow-up questions for future sessions\nShare notes with the stakeholder for validation\nLook for patterns across multiple interviews\n\nSample Interview Questions:\n\nWhat are your main responsibilities related to this system?\nWalk me through a typical day using the current system/process.\nWhat are the biggest challenges you face?\nIf you could change one thing about the current system, what would it be?\nWhat would make your job easier?\nWhat absolutely must the new system do?\nWhat would be nice to have but isn’t essential?\nWhat concerns do you have about the new system?\nWho else should I talk to about this?\n\n\n\n2.3.2 Questionnaires and Surveys\nQuestionnaires allow you to gather information from many stakeholders efficiently. They’re useful when you need quantitative data or when stakeholders are geographically distributed.\nWhen to Use Questionnaires:\n\nLarge number of stakeholders\nNeed for statistical analysis\nFollow-up to validate interview findings\nDistributed or remote stakeholders\nStandardized information needed across groups\n\nQuestionnaire Design Tips:\n\nKeep it short (15-20 minutes maximum)\nUse clear, unambiguous language\nMix question types (multiple choice, rating scales, open-ended)\nOrder questions logically\nPilot test with a small group first\nProvide context for why you’re asking\n\nExample Questions:\nRating scale: How satisfied are you with the current system’s performance? [ ] Very Dissatisfied [ ] Dissatisfied [ ] Neutral [ ] Satisfied [ ] Very Satisfied\nMultiple choice: How often do you use the reporting feature? [ ] Daily [ ] Weekly [ ] Monthly [ ] Rarely [ ] Never\nOpen-ended: What features would you most like to see in the new system?\n\n\n2.3.3 Observation and Ethnography\nSometimes the best way to understand requirements is to watch users in their natural environment. Observation involves watching stakeholders perform their actual work to understand workflows, pain points, and unspoken needs.\nBenefits of Observation:\n\nReveals tacit knowledge users can’t articulate\nUncovers workarounds and unofficial processes\nShows actual behavior vs. reported behavior\nProvides context for requirements\nIdentifies environmental factors\n\nObservation Techniques:\nPassive observation: Watch without interfering, taking notes on what you see. Users may behave differently when watched (the Hawthorne effect), but this diminishes over time.\nActive observation (contextual inquiry): Ask questions while observing. “I noticed you copied that data into a spreadsheet—can you tell me why?”\nApprenticing: Have the user teach you their job. This builds rapport and surfaces knowledge that might not emerge otherwise.\nA Day in the Life: Shadow a user through an entire workday to understand the full context of their activities.\nWhat to Look For:\n\nSteps in workflows that seem cumbersome\nWorkarounds users have developed\nFrequent interruptions or context switches\nInformation users need but don’t have easy access to\nPaper notes, sticky notes, or personal tracking systems\nFrustration points\nCollaboration patterns\n\n\n\n2.3.4 Workshops and Focus Groups\nWorkshops bring multiple stakeholders together to collaboratively explore requirements. They’re particularly useful for building consensus, identifying conflicts, and generating ideas.\nTypes of Workshops:\nRequirements workshops gather stakeholders to jointly define requirements. A facilitator guides the group through structured activities.\nJoint Application Development (JAD) is a specific workshop methodology that brings together users, managers, and developers for intensive collaborative sessions.\nFocus groups explore attitudes, opinions, and preferences with a group of representative users.\nWorkshop Best Practices:\n\nLimit group size (6-12 participants)\nInclude diverse stakeholder perspectives\nUse a skilled facilitator (often external)\nSet clear objectives and agenda\nUse visual aids and collaborative tools\nDocument outcomes in real-time\nManage dominant personalities\nAllow for individual input before group discussion\n\nWorkshop Activities:\nBrainstorming: Generate ideas without criticism, then consolidate and prioritize.\nAffinity diagrams: Write ideas on sticky notes, then group related items to identify themes.\nDot voting: Give participants dots to vote on priorities; reveals group preferences quickly.\nUse case walkthrough: Walk through scenarios step by step, identifying required functionality.\nCard sorting: Have participants organize features or concepts into categories to understand mental models.\n\n\n2.3.5 Document Analysis\nDocument analysis involves reviewing existing documentation to understand the current system, business rules, and context. It’s particularly useful when working with established organizations or regulated industries.\nDocuments to Review:\n\nCurrent system documentation and user manuals\nBusiness process documentation\nOrganizational charts\nPolicy and procedure manuals\nRegulatory and compliance documents\nPrevious project documentation\nTraining materials\nReports and forms currently in use\nIndustry standards and benchmarks\n\nWhat to Extract:\n\nBusiness rules and logic\nData definitions and relationships\nWorkflow steps\nRoles and responsibilities\nCompliance requirements\nTerminology and vocabulary\n\n\n\n2.3.6 Prototyping\nPrototyping involves building preliminary versions of the system to explore requirements. Users often find it easier to react to something concrete than to describe abstract needs.\nTypes of Prototypes:\nPaper prototypes: Hand-drawn sketches of screens and interfaces. Quick to create, easy to modify, and effective for early exploration.\nWireframes: Low-fidelity digital mockups showing layout and navigation without visual design.\nClickable prototypes: Interactive mockups that simulate user flows without real functionality.\nProof of concept: Technical prototypes that test feasibility of specific features.\nEvolutionary prototypes: Prototypes that evolve into the final system (requires disciplined development).\nThrowaway prototypes: Built solely for learning, then discarded. Allows for quick, dirty experimentation.\nWhen to Use Prototyping:\n\nRequirements are unclear or hard to articulate\nUser interface is critical\nStakeholders need to “see it to believe it”\nTechnical feasibility is uncertain\nNovel or innovative features\n\nPrototyping Risks:\n\nUsers may expect the prototype to be the final product\nPressure to ship the prototype as-is\nTime invested in throwaway prototypes\nCan focus too heavily on UI at expense of other requirements\n\n\n\n2.3.7 Analyzing Existing Systems\nIf replacing or enhancing an existing system, that system is a valuable source of requirements. Understanding current functionality provides a baseline for the new system.\nAnalysis Approaches:\n\nUse the existing system yourself\nReview system documentation\nStudy the database schema\nExamine reports and outputs\nInterview users about what works and what doesn’t\nAnalyze support tickets and bug reports\nReview change request history\n\nImportant Considerations:\nNot everything in the current system needs to be in the new system. Some features may be unused, obsolete, or present only due to historical accidents. Ask users which features they actually use and value.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#user-stories-and-acceptance-criteria",
    "href": "chapters/02-requirements-engineering.html#user-stories-and-acceptance-criteria",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.5 2.4 User Stories and Acceptance Criteria",
    "text": "5.5 2.4 User Stories and Acceptance Criteria\nUser stories are a popular format for expressing requirements in Agile development. They capture requirements from the user’s perspective, focusing on value delivered rather than technical implementation.\n\n2.4.1 The User Story Format\nThe classic user story format is:\n\nAs a [type of user], I want [some capability] so that [some benefit].\n\nThis format emphasizes three key elements:\n\nWho wants the capability (the persona or role)\nWhat they want to accomplish\nWhy it matters to them (the value or benefit)\n\nExamples:\n\nAs a customer, I want to save my shopping cart so that I can continue shopping later from a different device.\n\n\nAs a librarian, I want to see overdue books for a specific member so that I can contact them about returns.\n\n\nAs a sales manager, I want to view my team’s performance dashboard so that I can identify who needs coaching.\n\n\nAs a visually impaired user, I want to navigate the site using only my keyboard so that I can use the application without a mouse.\n\n\n\n2.4.2 Writing Effective User Stories\nThe INVEST Criteria:\nGood user stories follow the INVEST principles:\nI - Independent: Stories should be self-contained, without inherent dependencies on other stories. This allows them to be prioritized and scheduled flexibly.\nN - Negotiable: Stories are not contracts. They’re placeholders for conversations about requirements. Details emerge through discussion.\nV - Valuable: Each story should deliver value to users or the business. Technical tasks that don’t directly deliver value (like “refactor the database”) aren’t user stories.\nE - Estimable: The team should be able to estimate the effort required. If a story is too vague to estimate, it needs clarification or splitting.\nS - Small: Stories should be completable within a single sprint. Large stories (epics) should be broken down into smaller stories.\nT - Testable: It must be possible to write tests that verify the story is complete. If you can’t test it, you can’t confirm it’s done.\nCommon Mistakes:\nToo vague:\n\nAs a user, I want the system to be fast. ❌\n\nBetter:\n\nAs a customer, I want search results to appear within 2 seconds so that I can quickly find products. ✓\n\nToo technical:\n\nAs a developer, I want to implement caching using Redis. ❌\n\nBetter:\n\nAs a customer, I want previously viewed products to load instantly so that I can quickly review items I’ve already seen. ✓\n\nMissing the “why”:\n\nAs an admin, I want to export data to CSV. ❌\n\nBetter:\n\nAs an admin, I want to export user data to CSV so that I can analyze trends in spreadsheet software I’m familiar with. ✓\n\n\n\n2.4.3 Acceptance Criteria\nAcceptance criteria define the conditions that must be met for a user story to be considered complete. They provide clarity about scope and serve as the basis for testing.\nFormat Options:\nScenario format (Given-When-Then):\nGiven [precondition/context]\nWhen [action occurs]\nThen [expected outcome]\nExample:\nStory: As a customer, I want to reset my password so that I can \n       regain access to my account if I forget it.\n\nAcceptance Criteria:\n\nScenario 1: Requesting password reset\nGiven I am on the login page\nWhen I click \"Forgot Password\" and enter my email address\nThen I should receive a password reset email within 5 minutes\n\nScenario 2: Valid reset link\nGiven I have received a password reset email\nWhen I click the reset link within 24 hours\nThen I should see a form to enter a new password\n\nScenario 3: Expired reset link\nGiven I have received a password reset email\nWhen I click the reset link after 24 hours\nThen I should see a message that the link has expired\nAnd I should see an option to request a new reset link\n\nScenario 4: Password requirements\nGiven I am on the password reset form\nWhen I enter a new password\nThen the password must be at least 8 characters\nAnd contain at least one uppercase letter\nAnd contain at least one number\nAnd contain at least one special character\nChecklist format:\nStory: As a customer, I want to filter search results so that I can \n       find products that match my specific needs.\n\nAcceptance Criteria:\n□ Users can filter by price range (min and max)\n□ Users can filter by category\n□ Users can filter by customer rating (1-5 stars)\n□ Users can apply multiple filters simultaneously\n□ Filters update results without page reload\n□ Active filters are clearly displayed\n□ Users can remove individual filters or clear all\n□ Filter state is preserved when navigating back to results\n\n\n2.4.4 Epics, Stories, and Tasks\nUser stories exist within a hierarchy:\n┌─────────────────────────────────────────────────────────────────┐\n│                           EPIC                                  │\n│  Large body of work that can be broken into smaller pieces      │\n│  Example: \"User Account Management\"                             │\n│                                                                 │\n│  ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐ │\n│  │   USER STORY 1   │ │   USER STORY 2   │ │   USER STORY 3   │ │\n│  │  User registration│ │  Password reset  │ │ Profile editing  │ │\n│  │                  │ │                  │ │                  │ │\n│  │  ┌────┐ ┌────┐   │ │  ┌────┐ ┌────┐   │ │  ┌────┐ ┌────┐   │ │\n│  │  │Task│ │Task│   │ │  │Task│ │Task│   │ │  │Task│ │Task│   │ │\n│  │  └────┘ └────┘   │ │  └────┘ └────┘   │ │  └────┘ └────┘   │ │\n│  └──────────────────┘ └──────────────────┘ └──────────────────┘ │\n└─────────────────────────────────────────────────────────────────┘\nEpics are large bodies of work that span multiple sprints. They represent major features or capabilities but are too big to complete in one iteration.\nUser Stories are the primary unit of work in Agile. Each story delivers a specific piece of value and can be completed within a sprint.\nTasks are the technical activities required to complete a story. Unlike stories, tasks describe implementation details.\nExample Breakdown:\nEPIC: Shopping Cart\n\nUser Story 1: Add items to cart\n  Task: Create cart database schema\n  Task: Implement add-to-cart API endpoint\n  Task: Build cart UI component\n  Task: Write unit tests for cart service\n  Task: Write integration tests for cart API\n\nUser Story 2: Update cart quantities\n  Task: Implement quantity update API\n  Task: Add quantity controls to cart UI\n  Task: Handle inventory validation\n  Task: Write tests\n\nUser Story 3: Remove items from cart\n  ...\n\nUser Story 4: Apply discount codes\n  ...\n\n\n2.4.5 Story Mapping\nUser story mapping is a technique for organizing user stories to understand the full picture of user experience. Created by Jeff Patton, it arranges stories in a two-dimensional map.\nUser Activities (left to right = user journey)\n─────────────────────────────────────────────────────────────►\n\n│    Browse      Search      View         Add to      Checkout\n│   Products    Products    Product        Cart\n│\n│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐\n│  │ View    │ │ Search  │ │ View    │ │ Add     │ │ Enter   │\n│  │ catalog │ │ by name │ │ details │ │ item    │ │shipping │  ◄── MVP\n│  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘     Release 1\nP  ─────────────────────────────────────────────────────────────\nr  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐\ni  │ Filter  │ │ Search  │ │ View    │ │ Update  │ │ Choose  │\no  │ by      │ │ by      │ │ reviews │ │quantity │ │ payment │  ◄── Release 2\nr  │ category│ │ category│ │         │ │         │ │         │\ni  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘\nt  ─────────────────────────────────────────────────────────────\ny  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐\n│  │ View    │ │ Save    │ │ Zoom    │ │ Save    │ │ Apply   │\n│  │ featured│ │ search  │ │ images  │ │ for     │ │ coupon  │  ◄── Release 3\n│  │ items   │ │         │ │         │ │ later   │ │         │\n▼  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘\nThe horizontal axis shows the user’s journey through the system—the activities they perform from left to right. The vertical axis shows priority, with the most essential stories at the top.\nStory mapping helps teams:\n\nSee the big picture of user experience\nIdentify gaps in functionality\nPlan releases by drawing horizontal lines\nUnderstand dependencies between stories\nCommunicate the product vision",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#the-software-requirements-specification-srs",
    "href": "chapters/02-requirements-engineering.html#the-software-requirements-specification-srs",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.6 2.5 The Software Requirements Specification (SRS)",
    "text": "5.6 2.5 The Software Requirements Specification (SRS)\nThe Software Requirements Specification (SRS) is the primary document produced by requirements engineering. It serves as a contract between stakeholders about what the system will do and as a reference for designers, developers, and testers.\n\n2.5.1 Purpose of the SRS\nThe SRS serves multiple audiences and purposes:\nFor customers and stakeholders:\n\nConfirms understanding of their needs\nServes as basis for acceptance testing\nDocuments agreed-upon scope\n\nFor project managers:\n\nBasis for estimating effort and cost\nDefines project scope\nReference for change management\n\nFor designers and developers:\n\nInput for system design\nReference during implementation\nClarifies expected behavior\n\nFor testers:\n\nBasis for test planning\nDefines what to test\nSpecifies expected results\n\n\n\n2.5.2 SRS Structure (IEEE 830)\nWhile formats vary, the IEEE 830 standard provides a widely-used template. Here’s a typical structure:\n1. Introduction\n   1.1 Purpose\n   1.2 Scope\n   1.3 Definitions, Acronyms, and Abbreviations\n   1.4 References\n   1.5 Overview\n\n2. Overall Description\n   2.1 Product Perspective\n   2.2 Product Functions\n   2.3 User Classes and Characteristics\n   2.4 Operating Environment\n   2.5 Design and Implementation Constraints\n   2.6 Assumptions and Dependencies\n\n3. Specific Requirements\n   3.1 Functional Requirements\n   3.2 External Interface Requirements\n       3.2.1 User Interfaces\n       3.2.2 Hardware Interfaces\n       3.2.3 Software Interfaces\n       3.2.4 Communication Interfaces\n   3.3 Non-Functional Requirements\n       3.3.1 Performance Requirements\n       3.3.2 Security Requirements\n       3.3.3 Reliability Requirements\n       3.3.4 Availability Requirements\n   3.4 System Features\n\n4. Appendices\n   4.1 Glossary\n   4.2 Analysis Models\n   4.3 To Be Determined List\n\n\n2.5.3 Writing an SRS: Section by Section\nLet’s walk through each section with guidance and examples.\n1. Introduction\n1.1 Purpose\nDescribe the purpose of this SRS document and its intended audience.\n\nThis document specifies the software requirements for TaskFlow, a team task management application. It is intended for the development team, project stakeholders, and quality assurance personnel.\n\n1.2 Scope\nDescribe the software being specified, its purpose, benefits, and objectives.\n\nTaskFlow is a web-based application that enables teams to create, assign, track, and collaborate on tasks and projects. The system will improve team productivity by centralizing task management, providing visibility into project progress, and facilitating collaboration through comments and notifications.\nThe system will NOT include: time tracking functionality, billing/invoicing, or integration with version control systems. These features are planned for future releases.\n\n1.3 Definitions, Acronyms, and Abbreviations\nDefine terms used throughout the document.\n\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nTask\nA single unit of work with a title, description, assignee, and due date\n\n\nProject\nA collection of related tasks\n\n\nSprint\nA fixed time period (typically 2 weeks) for completing tasks\n\n\nBoard\nA visual representation of tasks organized by status\n\n\n\n\n1.4 References\nList any documents referenced in the SRS.\n1.5 Overview\nDescribe how the rest of the SRS is organized.\n2. Overall Description\n2.1 Product Perspective\nDescribe how the system fits into the broader environment. Is it standalone? Does it replace an existing system? What external systems does it interact with?\n\nTaskFlow is a new, standalone system that will replace the team’s current use of spreadsheets and email for task tracking. The system will integrate with:\n\nGoogle Workspace for user authentication\nSlack for notifications\nEmail services for user communications\n\n\nInclude a context diagram showing the system and its external interfaces:\n                    ┌─────────────────┐\n                    │  Google OAuth   │\n                    └────────┬────────┘\n                             │\n┌─────────────┐    ┌─────────▼─────────┐    ┌─────────────┐\n│    User     │◄───►│                   │◄───►│    Slack    │\n│  (Browser)  │    │     TaskFlow      │    │             │\n└─────────────┘    │                   │    └─────────────┘\n                   └─────────┬─────────┘\n                             │\n                    ┌────────▼────────┐\n                    │  Email Service  │\n                    └─────────────────┘\n2.2 Product Functions\nProvide a summary of major functions (detailed in Section 3).\n\nMajor functions include:\n\nUser management: Registration, authentication, profile management\nProject management: Create, configure, and archive projects\nTask management: Create, assign, update, and complete tasks\nCollaboration: Comments, mentions, and activity feeds\nNotifications: Email and Slack notifications for relevant events\nReporting: Project progress, team velocity, overdue tasks\n\n\n2.3 User Classes and Characteristics\nDescribe the different types of users and their characteristics.\n\n\n\n\n\n\n\n\n\nUser Class\nDescription\nTechnical Expertise\n\n\n\n\nTeam Member\nCreates and completes tasks\nBasic\n\n\nProject Manager\nCreates projects, assigns tasks, monitors progress\nBasic\n\n\nTeam Admin\nManages team membership and permissions\nIntermediate\n\n\nSystem Admin\nConfigures system settings, manages integrations\nAdvanced\n\n\n\n\n2.4 Operating Environment\nDescribe the environment in which the software will operate.\n\n\nServer: Linux (Ubuntu 22.04 LTS), Docker containers\nDatabase: PostgreSQL 15\nWeb Server: Nginx\nClient browsers: Chrome, Firefox, Safari, Edge (latest 2 versions)\nMobile: Responsive design supporting iOS and Android devices\n\n\n2.5 Design and Implementation Constraints\nList any constraints that limit developer options.\n\n\nThe system must be developed using React for the frontend and Node.js for the backend\nAll data must be stored in the United States to comply with data residency requirements\nThe system must use the existing corporate design system for UI components\nDevelopment must be complete by [date] to coincide with team restructuring\n\n\n2.6 Assumptions and Dependencies\nDocument assumptions that, if wrong, could affect requirements.\n\nAssumptions:\n\nUsers have reliable internet connectivity\nUsers have accounts in Google Workspace for authentication\nTeam sizes will not exceed 500 members\n\nDependencies:\n\nGoogle OAuth service availability\nSlack API stability\nCorporate design system components\n\n\n3. Specific Requirements\nThis is the core of the SRS, containing detailed, testable requirements.\n3.1 Functional Requirements\nOrganize by feature area or use case. Each requirement should have a unique identifier.\n3.1.1 User Management\n\nFR-UM-001: User Registration\nThe system shall allow new users to register using their Google Workspace account.\n\nFR-UM-002: User Profile\nThe system shall allow users to view and edit their profile information, including:\n- Display name\n- Profile photo\n- Notification preferences\n\nFR-UM-003: Role Assignment\nThe system shall allow Team Admins to assign roles (Team Member, Project Manager, \nTeam Admin) to users.\n\n3.1.2 Project Management\n\nFR-PM-001: Project Creation\nThe system shall allow Project Managers to create new projects with the following \nattributes:\n- Project name (required, max 100 characters)\n- Description (optional, max 500 characters)\n- Start date (optional)\n- Target completion date (optional)\n- Team members (at least one required)\n\nFR-PM-002: Project Status\nThe system shall allow projects to have one of the following statuses:\n- Active (default)\n- On Hold\n- Completed\n- Archived\n\nFR-PM-003: Project Templates\nThe system shall allow Project Managers to create projects from templates that \npre-populate tasks and settings.\n3.2 External Interface Requirements\n3.2.1 User Interfaces\n\nUI-001: The system shall provide a web-based interface accessible via modern browsers.\nUI-002: The interface shall be responsive, supporting screen widths from 320px to 2560px.\nUI-003: The system shall conform to WCAG 2.1 Level AA accessibility guidelines.\nUI-004: The primary navigation shall include access to: Dashboard, Projects, My Tasks, Team, and Settings.\n\n3.2.2 Software Interfaces\n\nSI-001: The system shall authenticate users via Google OAuth 2.0.\nSI-002: The system shall send notifications to Slack using the Slack Web API.\nSI-003: The system shall expose a REST API for potential future integrations.\n\n3.3 Non-Functional Requirements\n3.3.1 Performance Requirements\n\nNFR-PERF-001: Page load time shall not exceed 3 seconds on a 4G connection.\nNFR-PERF-002: API responses shall return within 500ms for 95% of requests.\nNFR-PERF-003: The system shall support 100 concurrent users without degradation.\n\n3.3.2 Security Requirements\n\nNFR-SEC-001: All data transmission shall use TLS 1.3.\nNFR-SEC-002: User sessions shall expire after 8 hours of inactivity.\nNFR-SEC-003: The system shall log all authentication events.\nNFR-SEC-004: Passwords shall never be stored; only Google OAuth shall be used.\n\n3.3.3 Reliability Requirements\n\nNFR-REL-001: The system shall maintain 99.5% uptime, excluding scheduled maintenance.\nNFR-REL-002: In the event of server failure, the system shall recover within 10 minutes.\nNFR-REL-003: No user data shall be lost due to system failures.\n\n\n\n2.5.4 Characteristics of Good Requirements\nIndividual requirements should be:\nClear: Unambiguous, meaning the same thing to all readers. Avoid vague terms like “user-friendly,” “fast,” or “intuitive” without specific definitions.\nComplete: Contains all necessary information. A reader should be able to understand and implement the requirement without asking for clarification.\nConsistent: Doesn’t contradict other requirements in the document.\nVerifiable: Can be tested or measured. If you can’t write a test for a requirement, it’s not verifiable.\nTraceable: Has a unique identifier and can be linked to its source and to downstream artifacts (design, code, tests).\nFeasible: Technically achievable within project constraints.\nNecessary: Supports a documented need. Requirements without clear justification should be questioned.\nPrioritized: Stakeholders understand relative importance.\nBad Examples and Improvements:\n\n\n\n\n\n\n\n\nPoor Requirement\nProblem\nImproved Requirement\n\n\n\n\nThe system shall be fast\nVague, not measurable\nThe system shall respond to user actions within 2 seconds\n\n\nThe system shall handle many users\n“Many” is undefined\nThe system shall support 1,000 concurrent users\n\n\nThe system shall be easy to use\nSubjective\nNew users shall complete the registration process in under 3 minutes without assistance\n\n\nThe system should have a login feature\nAmbiguous (“should” vs “shall”)\nThe system shall require users to authenticate before accessing any features\n\n\nThe interface shall be attractive\nSubjective, not testable\nThe interface shall conform to the corporate style guide (reference: design-system.company.com)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#requirements-traceability",
    "href": "chapters/02-requirements-engineering.html#requirements-traceability",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.7 2.6 Requirements Traceability",
    "text": "5.7 2.6 Requirements Traceability\nRequirements traceability is the ability to follow a requirement from its origin through design, implementation, and testing. It ensures that every requirement is addressed and that all development work serves a documented need.\n\n2.6.1 Why Traceability Matters\nTraceability helps answer critical questions:\n\nCompleteness: Is every requirement implemented and tested?\nImpact Analysis: If a requirement changes, what’s affected?\nCoverage: Are there any gaps in testing?\nJustification: Why does this code exist? What requirement does it satisfy?\nCompliance: Can we prove that regulatory requirements are met?\n\nWithout traceability, teams face significant risks:\n\nRequirements silently dropped during development\nFeatures implemented that nobody asked for\nChanges made without understanding full impact\nTesting gaps leading to defects\nCompliance audit failures\n\n\n\n2.6.2 The Requirements Traceability Matrix (RTM)\nA Requirements Traceability Matrix (RTM) is a document that maps requirements to other project artifacts. It creates explicit links between requirements and their downstream implementations.\nBasic RTM Structure:\n\n\n\n\n\n\n\n\n\n\n\nReq ID\nRequirement Description\nDesign Reference\nCode Module\nTest Case ID\nStatus\n\n\n\n\nFR-UM-001\nUser registration via Google OAuth\nDES-AUTH-001\nauth/google.js\nTC-AUTH-001, TC-AUTH-002\nComplete\n\n\nFR-UM-002\nUser profile management\nDES-USER-001\nusers/profile.js\nTC-USER-001\nIn Progress\n\n\nFR-PM-001\nProject creation\nDES-PROJ-001\nprojects/create.js\nTC-PROJ-001\nComplete\n\n\nNFR-PERF-001\nPage load &lt; 3 seconds\nDES-PERF-001\nN/A\nTC-PERF-001\nTesting\n\n\n\nExtended RTM with Additional Fields:\n\n\n\n\n\n\n\n\n\n\n\n\nReq ID\nSource\nPriority\nRisk\nStakeholder\nSprint\nNotes\n\n\n\n\nFR-UM-001\nInterview-012\nHigh\nLow\nProduct Owner\nSprint 1\nCore feature\n\n\nFR-UM-002\nWorkshop-003\nMedium\nLow\nUsers\nSprint 2\nMay defer some fields\n\n\nFR-PM-001\nSRS v1.0\nHigh\nMedium\nPM Team\nSprint 1\nComplex validation\n\n\nNFR-PERF-001\nNFR Workshop\nHigh\nHigh\nAll Users\nSprint 3\nRequires perf testing\n\n\n\n\n\n2.6.3 Types of Traceability\nForward Traceability: From requirements to implementation\n\nRequirement → Design\nRequirement → Code\nRequirement → Test Cases\n\nForward traceability ensures every requirement is implemented and tested.\nBackward Traceability: From implementation back to requirements\n\nCode → Requirement\nTest Case → Requirement\nDesign → Requirement\n\nBackward traceability ensures all development work serves a documented need—no “gold plating” or undocumented features.\nBi-directional Traceability: Both directions combined, providing complete coverage.\n                Forward Traceability\n        ────────────────────────────────────►\n\n┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐\n│Business │     │Software │     │  Design │     │  Test   │\n│  Needs  │────►│   Req   │────►│         │────►│  Cases  │\n└─────────┘     └─────────┘     └─────────┘     └─────────┘\n\n        ◄────────────────────────────────────\n                Backward Traceability\n\n\n2.6.4 Maintaining the RTM\nThe RTM is a living document that must be updated throughout the project. Best practices include:\nUpdate triggers:\n\nNew requirement added\nRequirement modified or deleted\nDesign decision made\nCode module completed\nTest case created or executed\nStatus changes\n\nReview cadence:\n\nWeekly reviews during development\nMilestone reviews before releases\nFull audit before final delivery\n\nTooling options:\n\nSpreadsheets (simple projects)\nRequirements management tools (Jama, DOORS, Helix RM)\nIssue trackers with linking (Jira, GitHub Issues)\nCustom databases\n\n\n\n2.6.5 Traceability in Agile Projects\nIn Agile environments, formal RTMs may seem heavyweight. However, traceability remains important. Agile approaches include:\nLinking in issue trackers: User stories linked to epics (backward to business need), linked to tasks (forward to implementation), linked to test cases.\nDefinition of Done: Including “acceptance criteria verified” and “tests written” in the definition of done ensures traceability.\nLiving documentation: Tools like Cucumber connect executable specifications directly to tests, creating automatic traceability.\nEpic: E-001 User Authentication\n├── Story: US-001 User Login\n│   ├── Task: T-001 Implement login API\n│   ├── Task: T-002 Build login form component\n│   └── Test: TC-001 Verify successful login\n│   └── Test: TC-002 Verify invalid credentials\n├── Story: US-002 Password Reset\n│   └── ...",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#managing-requirements-challenges",
    "href": "chapters/02-requirements-engineering.html#managing-requirements-challenges",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.8 2.7 Managing Requirements Challenges",
    "text": "5.8 2.7 Managing Requirements Challenges\nRequirements engineering faces several common challenges. Recognizing and addressing these challenges is key to project success.\n\n2.7.1 Scope Creep\nScope creep is the uncontrolled expansion of project scope—new requirements added without corresponding increases in time or budget. It’s one of the most common causes of project overruns.\nCauses:\n\nUnclear or incomplete initial requirements\nStakeholders adding “just one more feature”\nGold plating by developers\nPoor change management\nLack of clear project boundaries\n\nPrevention and Management:\nClear scope statements: Document what’s in scope AND what’s out of scope explicitly.\nChange control process: All changes go through a formal review:\n\nDocument the change request\nAssess impact on schedule, budget, and other requirements\nDecide: approve, reject, or defer\nUpdate documentation if approved\n\nBaseline requirements: Freeze requirements at a specific point; changes after baseline require formal approval.\nMoSCoW prioritization: Categorize requirements as:\n\nMust have: Essential, non-negotiable\nShould have: Important but not critical\nCould have: Nice to have if time permits\nWon’t have: Explicitly out of scope (this time)\n\n\n\n2.7.2 Ambiguous Requirements\nAmbiguous requirements mean different things to different readers, leading to incorrect implementations and costly rework.\nCommon Sources of Ambiguity:\nVague adjectives: “fast,” “user-friendly,” “secure,” “reliable”\nUnbounded lists: “including but not limited to,” “such as,” “etc.”\nAmbiguous pronouns: “The system sends a notification to the user when they submit the form. It should be formatted as HTML.” (What does “it” refer to?)\nMissing conditions: “The system displays an error message.” (When? Under what conditions?)\nUnclear quantities: “The system supports multiple users.” (How many? 10? 10,000?)\nStrategies for Clarity:\nSpecific numbers: Replace “fast” with “within 2 seconds”\nComplete lists: If the list is exhaustive, say so: “The system shall support exactly these payment methods: credit card, debit card, and PayPal”\nExamples: Include concrete examples to illustrate requirements\nGlossary: Define terms precisely in a glossary\nReviews: Multiple reviewers from different backgrounds catch different ambiguities\n\n\n2.7.3 Conflicting Requirements\nDifferent stakeholders often have different—sometimes contradictory—needs.\nExamples:\n\nMarketing wants maximum features; development wants a sustainable pace\nSecurity wants strong authentication; UX wants minimal friction\nSales wants customization for each client; architecture wants standardization\n\nResolution Strategies:\nIdentify conflicts early: Requirements analysis should explicitly look for conflicts.\nUnderstand underlying needs: Often conflicts arise from different solutions to the same underlying need. Find the root cause.\nNegotiate and prioritize: Bring stakeholders together to discuss trade-offs and agree on priorities.\nDocument decisions: Record what was decided and why, so the decision isn’t relitigated later.\nEscalate when necessary: Some conflicts require executive decision-making.\n\n\n2.7.4 Changing Requirements\nRequirements will change. Users learn what they actually need by seeing early versions. Market conditions shift. Technology evolves. Regulations change.\nThe question isn’t whether requirements will change, but how you’ll manage change.\nAgile Approach: Embrace change. Short iterations deliver working software frequently. Requirements emerge and evolve based on feedback. The backlog is continuously refined.\nPlan-Driven Approach: Manage change formally. Establish baselines. Evaluate change requests for impact. Maintain version control of requirements documents.\nHybrid Approach: Most real projects use a combination. Core requirements are stable (plan-driven), while details emerge iteratively (Agile).\nBest Practices:\n\nAccept that change is inevitable\nBuild processes to handle change efficiently\nCommunicate the cost of late changes (not to prevent change, but to inform decisions)\nKeep requirements documentation up to date\nMaintain traceability so impacts are visible",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#requirements-in-practice-tools-and-techniques",
    "href": "chapters/02-requirements-engineering.html#requirements-in-practice-tools-and-techniques",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.9 2.8 Requirements in Practice: Tools and Techniques",
    "text": "5.9 2.8 Requirements in Practice: Tools and Techniques\n\n2.8.1 Requirements Management Tools\nVarious tools support requirements engineering:\nDocument-based tools:\n\nMicrosoft Word/Google Docs with templates\nConfluence\nNotion\n\nDedicated requirements tools:\n\nJama Connect\nIBM DOORS\nHelix RM\nModern Requirements\n\nAgile tools with requirements support:\n\nJira\nAzure DevOps\nGitHub Issues + Projects\nLinear\nShortcut\n\nChoosing a tool:\n\nTeam size and distribution\nProject complexity\nRegulatory requirements\nBudget\nIntegration with other tools\nLearning curve\n\nFor your course project, GitHub Issues and Projects provide adequate requirements management while learning fundamental concepts.\n\n\n2.8.2 Using GitHub for Requirements\nGitHub provides several features useful for requirements management:\nIssues for user stories and requirements:\nTitle: As a customer, I want to reset my password\n\nDescription:\n**User Story:**\nAs a customer, I want to reset my password so that I can \nregain access if I forget it.\n\n**Acceptance Criteria:**\n- [ ] Reset link sent via email within 5 minutes\n- [ ] Link expires after 24 hours\n- [ ] New password must meet security requirements\n- [ ] Confirmation shown after successful reset\n\n**Priority:** High\n**Sprint:** Sprint 2\nLabels for categorization:\n\ntype: feature\ntype: bug\npriority: high\nstatus: in-progress\narea: authentication\n\nMilestones for releases or sprints\nProjects for Kanban boards and tracking\nLinking issues to pull requests for traceability",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#chapter-summary",
    "href": "chapters/02-requirements-engineering.html#chapter-summary",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.10 2.9 Chapter Summary",
    "text": "5.10 2.9 Chapter Summary\nRequirements engineering is the foundation of successful software projects. Investing time in understanding and documenting what the system should do—before writing code—dramatically reduces the risk of building the wrong thing.\nKey takeaways from this chapter:\n\nRequirements engineering is the systematic process of discovering, documenting, validating, and managing requirements. It’s iterative and continues throughout the project.\nFunctional requirements describe what the system should do; non-functional requirements describe how well it should do it (performance, security, usability, etc.).\nMultiple elicitation techniques are needed: interviews, questionnaires, observation, workshops, document analysis, and prototyping each reveal different types of requirements.\nUser stories capture requirements from the user’s perspective (“As a… I want… so that…”) and include acceptance criteria that define when the story is complete.\nThe SRS document serves as a contract and reference for all project stakeholders. Good requirements are clear, complete, consistent, verifiable, traceable, feasible, and necessary.\nRequirements traceability links requirements to their sources and to downstream artifacts (design, code, tests), ensuring nothing falls through the cracks.\nCommon challenges include scope creep, ambiguity, conflicts, and change. Each requires specific management strategies.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#key-terms",
    "href": "chapters/02-requirements-engineering.html#key-terms",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.11 2.10 Key Terms",
    "text": "5.11 2.10 Key Terms\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nRequirements Engineering\nThe process of discovering, documenting, validating, and managing software requirements\n\n\nFunctional Requirement\nA specification of what the system should do\n\n\nNon-Functional Requirement\nA specification of how well the system should perform (quality attributes)\n\n\nElicitation\nThe process of gathering requirements from stakeholders and other sources\n\n\nUser Story\nA brief description of a feature from the perspective of a user\n\n\nAcceptance Criteria\nConditions that must be met for a user story to be considered complete\n\n\nEpic\nA large body of work that can be broken down into smaller user stories\n\n\nSRS\nSoftware Requirements Specification; the primary requirements document\n\n\nRTM\nRequirements Traceability Matrix; a document linking requirements to other artifacts\n\n\nScope Creep\nUncontrolled expansion of project scope\n\n\nMoSCoW\nPrioritization method: Must have, Should have, Could have, Won’t have\n\n\nINVEST\nCriteria for good user stories: Independent, Negotiable, Valuable, Estimable, Small, Testable",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#review-questions",
    "href": "chapters/02-requirements-engineering.html#review-questions",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.12 2.11 Review Questions",
    "text": "5.12 2.11 Review Questions\n\nExplain the difference between functional and non-functional requirements. Why are both important? Give two examples of each for a mobile banking application.\nDescribe three different requirements elicitation techniques. For each, explain when it would be most appropriate and what types of requirements it’s best suited to discover.\nWhat makes a good user story according to the INVEST criteria? Write a user story for an online food ordering system and evaluate it against INVEST.\nWhy is the “so that” clause important in user stories? What happens when it’s omitted?\nCompare acceptance criteria written in Given-When-Then format versus checklist format. What are the advantages of each?\nWhat are the key sections of an SRS document? Who are the different audiences for the SRS, and how does each use it?\nExplain forward and backward traceability. Why is bi-directional traceability valuable?\nWhat is scope creep? Describe three strategies for preventing or managing it.\nYou’re reviewing a requirements document and find this requirement: “The system shall be secure.” What’s wrong with this requirement? How would you improve it?\nA stakeholder says, “We don’t have time for all this requirements documentation. Just start coding and we’ll figure it out as we go.” How would you respond?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#hands-on-exercises",
    "href": "chapters/02-requirements-engineering.html#hands-on-exercises",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.13 2.12 Hands-On Exercises",
    "text": "5.13 2.12 Hands-On Exercises\n\nExercise 2.1: Elicitation Practice\nSelect a system you use regularly (a mobile app, website, or desktop application). Imagine you’re replacing it with a new system.\n\nWrite 10 interview questions you would ask users of the current system.\nIdentify 5 things you would look for if you were observing users.\nList 5 documents you would want to review.\n\n\n\nExercise 2.2: Writing User Stories\nFor your semester project, write 10 user stories following the “As a… I want… so that…” format. For each story:\n\nIdentify the user role\nWrite the story\nAdd 3-5 acceptance criteria\nEvaluate against INVEST criteria\n\n\n\nExercise 2.3: Requirement Analysis\nReview the following requirements and identify problems (ambiguity, incompleteness, conflicts, etc.). Rewrite each to improve it.\n\n“The system should load quickly.”\n“Users can search for products.”\n“The system shall support all major browsers.”\n“The interface shall be intuitive.”\n“Reports should be generated daily, weekly, or on-demand.”\n“The system must be reliable.”\n\n\n\nExercise 2.4: Software Requirements Specification\nCreate an SRS document for your semester project using the IEEE 830 structure as a guide. Include:\n\nIntroduction (purpose, scope, definitions)\nOverall description (product perspective, user classes, constraints)\nAt least 15 functional requirements with unique IDs\nAt least 5 non-functional requirements covering different categories\nInitial traceability to user stories\n\n\n\nExercise 2.5: Requirements Traceability Matrix\nCreate an RTM for your project that includes:\n\nRequirement ID and description\nPriority (MoSCoW)\nSource (which elicitation activity or stakeholder)\nStatus (Not Started, In Progress, Complete)\nPlaceholder columns for Design, Code Module, and Test Case (to be filled in later)\n\n\n\nExercise 2.6: GitHub Project Setup\nSet up requirements management for your project in GitHub:\n\nCreate issues for at least 10 user stories\nAdd appropriate labels (priority, type, area)\nCreate a milestone for your first release\nSet up a project board with columns: Backlog, Ready, In Progress, Review, Done\nAdd acceptance criteria as checkboxes in each issue",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#further-reading",
    "href": "chapters/02-requirements-engineering.html#further-reading",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.14 2.13 Further Reading",
    "text": "5.14 2.13 Further Reading\nBooks:\n\nWiegers, K. & Beatty, J. (2013). Software Requirements (3rd Edition). Microsoft Press.\nRobertson, S. & Robertson, J. (2012). Mastering the Requirements Process (3rd Edition). Addison-Wesley.\nCohn, M. (2004). User Stories Applied. Addison-Wesley.\nPatton, J. (2014). User Story Mapping. O’Reilly Media.\n\nStandards:\n\nIEEE 830-1998: Recommended Practice for Software Requirements Specifications\nISO/IEC/IEEE 29148:2018: Systems and software engineering — Life cycle processes — Requirements engineering\n\nOnline Resources:\n\nAtlassian Agile Coach: User Stories (https://www.atlassian.com/agile/project-management/user-stories)\nMountain Goat Software: User Stories (https://www.mountaingoatsoftware.com/agile/user-stories)\nRequirements Engineering Magazine (https://re-magazine.ireb.org/)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/02-requirements-engineering.html#references",
    "href": "chapters/02-requirements-engineering.html#references",
    "title": "5  Chapter 2: Requirements Engineering",
    "section": "5.15 References",
    "text": "5.15 References\nCohn, M. (2004). User Stories Applied: For Agile Software Development. Addison-Wesley.\nIEEE. (1998). IEEE Recommended Practice for Software Requirements Specifications (IEEE Std 830-1998).\nPatton, J. (2014). User Story Mapping: Discover the Whole Story, Build the Right Product. O’Reilly Media.\nPohl, K. (2010). Requirements Engineering: Fundamentals, Principles, and Techniques. Springer.\nRobertson, S., & Robertson, J. (2012). Mastering the Requirements Process: Getting Requirements Right (3rd Edition). Addison-Wesley.\nStandish Group. (2020). CHAOS Report 2020. The Standish Group International.\nWake, B. (2003). INVEST in Good Stories, and SMART Tasks. Retrieved from https://xp123.com/articles/invest-in-good-stories-and-smart-tasks/\nWiegers, K., & Beatty, J. (2013). Software Requirements (3rd Edition). Microsoft Press.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 2: Requirements Engineering</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html",
    "href": "chapters/03-systems-modeling.html",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "",
    "text": "6.1 Learning Objectives\nBy the end of this chapter, you will be able to:",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#learning-objectives",
    "href": "chapters/03-systems-modeling.html#learning-objectives",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "",
    "text": "Explain the purpose and value of systems modeling in software engineering\nRead and create Use Case diagrams to capture system functionality\nModel workflows and processes using Activity diagrams\nRepresent object interactions over time with Sequence diagrams\nDesign system structure using Class diagrams and domain models\nSelect appropriate diagram types for different modeling needs\nApply UML notation correctly and consistently\nUse modeling tools to create professional diagrams",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#why-model-software-systems",
    "href": "chapters/03-systems-modeling.html#why-model-software-systems",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.2 3.1 Why Model Software Systems?",
    "text": "6.2 3.1 Why Model Software Systems?\nImagine trying to build a house by describing it only in words. “There’s a living room connected to a kitchen, and upstairs there are three bedrooms…” You could write pages of description, but a single floor plan communicates the layout instantly and unambiguously. Architects don’t just describe buildings—they draw them.\nSoftware systems are far more complex than houses, yet we often try to describe them using only text: requirements documents, code comments, and verbal explanations. Systems modeling provides the visual blueprints that help us understand, communicate, and reason about software before and during its construction.\n\n3.1.1 The Purpose of Models\nA model is a simplified representation of reality that helps us understand complex systems. Models deliberately omit details to focus on what matters for a particular purpose.\nConsider a map. A road map shows highways and cities but omits elevation, vegetation, and building footprints. A topographic map shows terrain but omits road numbers. A subway map distorts geography entirely to emphasize connections between stations. Each map serves a different purpose by including different information and making different simplifications.\nSoftware models work the same way. Different diagrams serve different purposes:\n\nUse Case diagrams show what the system does from the user’s perspective\nActivity diagrams show how processes flow through steps and decisions\nSequence diagrams show how objects interact over time\nClass diagrams show the structure of the system’s code\n\nNo single diagram captures everything. A complete understanding requires multiple views, each revealing different aspects of the system.\n\n\n3.1.2 Benefits of Modeling\nCommunication: Models provide a common language between stakeholders. A business analyst, a developer, and a tester can all look at the same diagram and understand what the system should do. Visual representations often communicate more effectively than pages of text.\nUnderstanding: The act of creating a model forces you to think through the system carefully. You can’t draw a sequence diagram without understanding which objects interact and in what order. Modeling reveals gaps in your understanding early, when they’re cheap to address.\nDocumentation: Models serve as documentation that remains useful throughout the project lifecycle. Unlike code comments that often become outdated, well-maintained models provide a high-level view that helps new team members understand the system.\nAnalysis: Models allow you to analyze designs before implementation. You can identify potential problems, evaluate alternatives, and make architectural decisions when changes are still inexpensive.\nAbstraction: Models let you work at the right level of detail. When discussing system architecture with executives, you don’t need to show individual methods and parameters. When designing a specific component, you don’t need the entire system context.\n\n\n3.1.3 Modeling in Different Contexts\nThe role of modeling varies across development methodologies:\nTraditional/Waterfall approaches often emphasize extensive upfront modeling. Detailed models are created during the design phase before coding begins. Changes to models require formal reviews.\nAgile approaches favor “just enough” modeling. Models are created as needed, often informally on whiteboards. The emphasis is on models as communication tools rather than formal documentation. “Working software over comprehensive documentation” doesn’t mean no documentation—it means documentation that adds value.\nThe right balance depends on your context:\n\nRegulated industries may require formal models for compliance\nDistributed teams benefit from documented models for asynchronous communication\nComplex systems need more modeling than simple ones\nNovel designs require more exploration than familiar patterns\n\nFor most projects, a pragmatic middle ground works best: model enough to understand and communicate the design, but don’t over-invest in documentation that won’t be maintained.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#introduction-to-uml",
    "href": "chapters/03-systems-modeling.html#introduction-to-uml",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.3 3.2 Introduction to UML",
    "text": "6.3 3.2 Introduction to UML\nThe Unified Modeling Language (UML) is a standardized visual language for specifying, constructing, and documenting software systems. Developed in the 1990s by Grady Booch, James Rumbaugh, and Ivar Jacobson (the “Three Amigos”), UML unified several competing notations into a single standard, now maintained by the Object Management Group (OMG).\n\n3.2.1 UML Diagram Types\nUML 2.5 defines 14 diagram types, organized into two main categories:\nStructural Diagrams show the static structure of the system—what exists and how it’s organized:\n\n\n\nDiagram\nPurpose\n\n\n\n\nClass Diagram\nClasses, attributes, methods, and relationships\n\n\nObject Diagram\nInstances of classes at a specific moment\n\n\nComponent Diagram\nHigh-level software components and dependencies\n\n\nDeployment Diagram\nPhysical deployment of software to hardware\n\n\nPackage Diagram\nOrganization of model elements into packages\n\n\nComposite Structure Diagram\nInternal structure of a class\n\n\nProfile Diagram\nExtensions to UML itself\n\n\n\nBehavioral Diagrams show the dynamic behavior of the system—what happens over time:\n\n\n\n\n\n\n\nDiagram\nPurpose\n\n\n\n\nUse Case Diagram\nSystem functionality from user perspective\n\n\nActivity Diagram\nWorkflows and process flows\n\n\nSequence Diagram\nObject interactions over time\n\n\nCommunication Diagram\nObject interactions emphasizing structure\n\n\nState Machine Diagram\nStates and transitions of an object\n\n\nTiming Diagram\nTiming constraints on behavior\n\n\nInteraction Overview Diagram\nHigh-level view of interaction flows\n\n\n\nIn practice, four diagrams cover most modeling needs:\n\nUse Case diagrams for requirements\nActivity diagrams for processes\nSequence diagrams for interactions\nClass diagrams for structure\n\nThis chapter focuses on these four essential diagram types.\n\n\n3.2.2 UML Notation Basics\nBefore diving into specific diagrams, let’s understand some notation conventions that apply across UML:\nNaming conventions:\n\nClass names: PascalCase (e.g., ShoppingCart, UserAccount)\nAttributes and operations: camelCase (e.g., firstName, calculateTotal())\nConstants: UPPER_CASE (e.g., MAX_ITEMS)\n\nVisibility markers:\n\n+ Public: accessible from anywhere\n- Private: accessible only within the class\n# Protected: accessible within class and subclasses\n~ Package: accessible within the same package\n\nMultiplicity indicates how many instances participate in a relationship:\n\n1 Exactly one\n0..1 Zero or one (optional)\n* or 0..* Zero or more\n1..* One or more\nn..m Between n and m\n\nStereotypes extend UML with additional meaning, shown in guillemets:\n\n«interface» An interface rather than a class\n«abstract» An abstract class\n«enumeration» An enumeration type\n«actor» A user or external system",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#use-case-diagrams",
    "href": "chapters/03-systems-modeling.html#use-case-diagrams",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.4 3.3 Use Case Diagrams",
    "text": "6.4 3.3 Use Case Diagrams\nUse Case diagrams capture the functional requirements of a system from the user’s perspective. They show what the system does (use cases) and who interacts with it (actors), without detailing how the functionality is implemented.\n\n3.3.1 Use Case Diagram Elements\nActors represent anyone or anything that interacts with the system from outside. Actors can be:\n\nHuman users (Customer, Administrator, Manager)\nExternal systems (Payment Gateway, Email Service)\nHardware devices (Barcode Scanner, Printer)\nTime-based triggers (Scheduled Task, Nightly Batch)\n\nActors are drawn as stick figures with their role name below:\n    O\n   /|\\     Customer\n   / \\\nUse Cases represent discrete pieces of functionality that provide value to an actor. They’re drawn as ovals with the use case name inside:\n    ╭─────────────────────╮\n    │   Place Order       │\n    ╰─────────────────────╯\nSystem Boundary is a rectangle that defines what’s inside the system versus outside. Actors are outside; use cases are inside.\n┌─────────────────────────────────────────┐\n│           Online Store System           │\n│                                         │\n│   ╭───────────────╮  ╭───────────────╮  │\n│   │ Browse Catalog │  │  Place Order  │  │\n│   ╰───────────────╯  ╰───────────────╯  │\n│                                         │\n│   ╭───────────────╮  ╭───────────────╮  │\n│   │ Track Order   │  │ Manage Account│  │\n│   ╰───────────────╯  ╰───────────────╯  │\n│                                         │\n└─────────────────────────────────────────┘\nAssociations connect actors to the use cases they participate in, shown as solid lines:\n    O\n   /|\\─────────────╭───────────────╮\n   / \\             │  Place Order  │\n Customer          ╰───────────────╯\n\n\n3.3.2 Use Case Relationships\nUse cases can relate to each other in several ways:\nInclude Relationship («include»)\nWhen one use case always includes the behavior of another. The included use case is mandatory. This is useful for extracting common behavior shared by multiple use cases.\n╭─────────────────╮         ╭─────────────────╮\n│   Place Order   │─────────│  Verify Payment │\n╰─────────────────╯«include»╰─────────────────╯\n\n╭─────────────────╮         ╭─────────────────╮\n│   Renew Sub     │─────────│  Verify Payment │\n╰─────────────────╯«include»╰─────────────────╯\nBoth “Place Order” and “Renew Subscription” always include payment verification.\nExtend Relationship («extend»)\nWhen one use case optionally adds behavior to another under certain conditions. The extension is not always executed.\n╭─────────────────╮         ╭─────────────────╮\n│  Apply Coupon   │─────────│   Place Order   │\n╰─────────────────╯«extend» ╰─────────────────╯\n“Apply Coupon” extends “Place Order” but only when the customer has a coupon.\nGeneralization (inheritance arrow)\nWhen one actor or use case is a specialized version of another.\n      O\n     /|\\\n     / \\\n   Customer\n       △\n      ╱ ╲\n     ╱   ╲\n    O     O\n   /|\\   /|\\\n   / \\   / \\\nGuest   Registered\nCustomer Customer\n\n\n3.3.3 Complete Use Case Diagram Example\nHere’s a use case diagram for a library management system:\n┌─────────────────────────────────────────────────────────────────────┐\n│                    Library Management System                        │\n│                                                                     │\n│    ╭──────────────╮      ╭──────────────╮      ╭──────────────╮    │\n│    │Search Catalog│      │ View Book    │      │ Reserve Book │    │\n│    ╰──────────────╯      │   Details    │      ╰──────────────╯    │\n│           │              ╰──────────────╯             │            │\n│           │                     │                     │            │\n│    O      └─────────────────────┼─────────────────────┘            │\n│   /|\\─────────────────────────────────────────────────────────╮    │\n│   / \\                           │                             │    │\n│ Member                          │                             │    │\n│    │      ╭──────────────╮      │      ╭──────────────╮       │    │\n│    │      │ Borrow Book  │──────┘      │ Return Book  │       │    │\n│    │      ╰──────────────╯             ╰──────────────╯       │    │\n│    │             │                            │               │    │\n│    │             │    ╭──────────────╮        │               │    │\n│    │             └────│Update Account│────────┘               │    │\n│    │          «include»╰──────────────╯                       │    │\n│    │                                                          │    │\n│    │      ╭──────────────╮                                    │    │\n│    └──────│  Pay Fine    │                                    │    │\n│           ╰──────────────╯                                    │    │\n│                  │                                            │    │\n│                  │«extend»╭──────────────╮                    │    │\n│                  └────────│ Renew Book   │                    │    │\n│                           ╰──────────────╯                    │    │\n│                                  │                            │    │\n│    O                             │                            │    │\n│   /|\\────────────────────────────┼────────────────────────────┘    │\n│   / \\                            │                                 │\n│Librarian                         │                                 │\n│    │      ╭──────────────╮       │       ╭──────────────╮          │\n│    ├──────│  Add Book    │       │       │ Remove Book  │──────────┤\n│    │      ╰──────────────╯       │       ╰──────────────╯          │\n│    │                             │                                 │\n│    │      ╭──────────────╮       │       ╭──────────────╮          │\n│    ├──────│Manage Members│       │       │Generate Report│─────────┤\n│    │      ╰──────────────╯       │       ╰──────────────╯          │\n│    │                             │                                 │\n└────┼─────────────────────────────┼─────────────────────────────────┘\n     │                             │\n     │                    ╭────────┴────────╮\n     │                    │  Email Service  │\n     │                    │    «system»     │\n     │                    ╰─────────────────╯\n     │\n╭────┴────────╮\n│   Payment   │\n│   Gateway   │\n│  «system»   │\n╰─────────────╯\n\n\n3.3.4 Use Case Descriptions\nWhile the diagram provides an overview, each use case needs detailed documentation. A Use Case Description (or Use Case Specification) expands on what happens within a use case.\nUse Case Description Template:\nUSE CASE: Borrow Book\n\nID: UC-003\nActor(s): Member, Librarian\nPreconditions: \n  - Member is logged in\n  - Member has no overdue books\n  - Member has not exceeded borrowing limit\n\nMain Success Scenario (Basic Flow):\n  1. Member searches for a book\n  2. System displays book details and availability\n  3. Member selects \"Borrow\"\n  4. System verifies member's borrowing eligibility\n  5. System records the loan with due date (14 days)\n  6. System updates book status to \"On Loan\"\n  7. System sends confirmation email to member\n  8. System displays loan confirmation with due date\n\nAlternative Flows:\n  3a. Book is not available:\n      3a1. System displays \"Book unavailable\" message\n      3a2. System offers reservation option\n      3a3. Return to step 1 or end\n\n  4a. Member has overdue books:\n      4a1. System displays message about overdue books\n      4a2. Use case ends\n\n  4b. Member at borrowing limit:\n      4b1. System displays borrowing limit message\n      4b2. Use case ends\n\nPostconditions:\n  - Book is assigned to member\n  - Due date is set\n  - Book availability is updated\n  - Transaction is logged\n\nBusiness Rules:\n  - Maximum 5 books per member\n  - Loan period is 14 days\n  - Members with overdue books cannot borrow\n\nFrequency: ~200 times per day\n\n\n3.3.5 Best Practices for Use Case Diagrams\nNaming Use Cases:\n\nUse verb-noun format: “Place Order,” not “Order” or “Ordering”\nFocus on user goals, not system actions: “Register Account,” not “Store User Data”\nKeep names concise but descriptive\n\nChoosing Actors:\n\nName actors by their role, not their identity: “Customer,” not “John”\nIf different user types have different access, make them separate actors\nDon’t forget non-human actors (external systems, scheduled jobs)\n\nScope:\n\nKeep diagrams focused; split into multiple diagrams if needed\nShow 5-15 use cases per diagram\nEach use case should deliver value to an actor\n\nRelationships:\n\nDon’t overuse «include» and «extend»; simple is often better\n«include» for mandatory common behavior\n«extend» for optional behavior\nIf unsure, just use simple associations\n\nCommon Mistakes:\n\nDrawing implementation details (login, database operations)\nToo many use cases (every button click is not a use case)\nActors that don’t interact with any use case\nUse cases with no associated actor\nConfusing use cases with features or functions",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#activity-diagrams",
    "href": "chapters/03-systems-modeling.html#activity-diagrams",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.5 3.4 Activity Diagrams",
    "text": "6.5 3.4 Activity Diagrams\nActivity diagrams model the flow of activities in a process. They’re excellent for visualizing workflows, business processes, algorithms, and use case scenarios. Think of them as enhanced flowcharts with support for parallel activities.\n\n3.4.1 Activity Diagram Elements\nInitial Node (filled circle): Where the flow begins.\n  ●\nFinal Node (circle with inner filled circle): Where the flow ends.\n  ◉\nAction/Activity (rounded rectangle): A single step or task.\n╭─────────────────────╮\n│   Verify Payment    │\n╰─────────────────────╯\nDecision Node (diamond): A branch point where flow takes one of several paths based on a condition. Guards (conditions) are shown in brackets.\n        │\n        ▼\n       ◇\n      ╱ ╲\n[yes]╱   ╲[no]\n    ╱     ╲\n   ▼       ▼\nMerge Node (diamond): Where multiple paths come back together.\n   ╲     ╱\n    ╲   ╱\n     ◇\n     │\n     ▼\nFork (thick horizontal bar): Splits flow into parallel paths.\n        │\n   ─────┼─────\n   │    │    │\n   ▼    ▼    ▼\nJoin (thick horizontal bar): Synchronizes parallel paths; waits for all to complete.\n   │    │    │\n   ─────┼─────\n        │\n        ▼\nSwimlanes (vertical or horizontal partitions): Show who or what performs each activity.\n\n\n3.4.2 Control Flow vs. Object Flow\nControl flow (solid arrows) shows the sequence of activities:\n╭─────────────╮     ╭─────────────╮\n│  Activity A │────►│  Activity B │\n╰─────────────╯     ╰─────────────╯\nObject flow (solid arrows with object nodes) shows data passing between activities:\n╭─────────────╮     ┌─────────┐     ╭─────────────╮\n│Create Order │────►│ [Order] │────►│Process Order│\n╰─────────────╯     └─────────┘     ╰─────────────╯\n\n\n3.4.3 Complete Activity Diagram Example\nHere’s an activity diagram for an online order process with swimlanes:\n│        Customer        │         System          │       Warehouse        │\n│                        │                         │                        │\n│           ●            │                         │                        │\n│           │            │                         │                        │\n│           ▼            │                         │                        │\n│  ╭─────────────────╮   │                         │                        │\n│  │  Browse Catalog │   │                         │                        │\n│  ╰────────┬────────╯   │                         │                        │\n│           │            │                         │                        │\n│           ▼            │                         │                        │\n│  ╭─────────────────╮   │                         │                        │\n│  │ Add Items to    │   │                         │                        │\n│  │    Cart         │◄──┼──────────────┐          │                        │\n│  ╰────────┬────────╯   │              │          │                        │\n│           │            │              │          │                        │\n│           ▼            │              │          │                        │\n│          ◇             │              │          │                        │\n│         ╱ ╲            │              │          │                        │\n│ [more] ╱   ╲ [done]    │              │          │                        │\n│       ╱     ╲          │              │          │                        │\n│       │      │         │              │          │                        │\n│       │      ▼         │              │          │                        │\n│       │ ╭───────────╮  │              │          │                        │\n│       │ │  Checkout │  │              │          │                        │\n│       │ ╰─────┬─────╯  │              │          │                        │\n│       │       │        │              │          │                        │\n│       │       ▼        │              │          │                        │\n│       │ ╭───────────╮  │              │          │                        │\n│       │ │Enter Ship │  │              │          │                        │\n│       │ │  Info     │  │              │          │                        │\n│       │ ╰─────┬─────╯  │              │          │                        │\n│       │       │        │              │          │                        │\n│       │       ▼        │              │          │                        │\n│       │ ╭───────────╮  │              │          │                        │\n│       │ │Enter Pay  │  │              │          │                        │\n│       │ │  Info     │──┼─────────►    │          │                        │\n│       │ ╰───────────╯  │ ╭───────────────────╮   │                        │\n│       │                │ │  Validate Payment │   │                        │\n│       │                │ ╰─────────┬─────────╯   │                        │\n│       │                │           │             │                        │\n│       │                │           ▼             │                        │\n│       │                │          ◇              │                        │\n│       │                │         ╱ ╲             │                        │\n│       │                │[invalid]╱   ╲[valid]    │                        │\n│       │                │        ╱     ╲          │                        │\n│       └────────────────┼───────┘       │         │                        │\n│                        │               ▼         │                        │\n│                        │      ════════════════   │                        │\n│                        │      │      │      │    │                        │\n│                        │      ▼      │      ▼    │                        │\n│                        │ ╭────────╮  │ ╭────────╮│                        │\n│                        │ │ Create │  │ │ Send   ││                        │\n│                        │ │ Order  │  │ │ Email  ││                        │\n│                        │ ╰────┬───╯  │ ╰───┬────╯│                        │\n│                        │      │      │     │     │                        │\n│                        │      │      │     │     │                        │\n│                        │      ════════════════   │                        │\n│                        │             │           │                        │\n│                        │             │───────────┼──────────►             │\n│                        │             │           │  ╭─────────────────╮   │\n│                        │             │           │  │  Pick Items     │   │\n│                        │             │           │  ╰────────┬────────╯   │\n│                        │             │           │           │            │\n│                        │             │           │           ▼            │\n│                        │             │           │  ╭─────────────────╮   │\n│                        │             │           │  │  Pack Order     │   │\n│                        │             │           │  ╰────────┬────────╯   │\n│                        │             │           │           │            │\n│                        │             │           │           ▼            │\n│                        │             │           │  ╭─────────────────╮   │\n│                        │             │           │  │  Ship Order     │   │\n│                        │             │           │  ╰────────┬────────╯   │\n│                        │             │           │           │            │\n│                        │  ╭──────────┼───────────┼───────────┘            │\n│                        │  │          │           │                        │\n│                        │  ▼          │           │                        │\n│                        │╭──────────╮ │           │                        │\n│                        ││Update    │ │           │                        │\n│                        ││Tracking  │ │           │                        │\n│                        │╰────┬─────╯ │           │                        │\n│                        │     │       │           │                        │\n│                        │     ▼       │           │                        │\n│                        │     ◉       │           │                        │\n│                        │             │           │                        │\n\n\n3.4.4 Activity Diagram for Algorithm Logic\nActivity diagrams can also model algorithms. Here’s a diagram for a simple login process:\n                    ●\n                    │\n                    ▼\n          ╭─────────────────╮\n          │  Display Login  │\n          │      Form       │\n          ╰────────┬────────╯\n                   │\n                   ▼\n          ╭─────────────────╮\n          │  Enter Username │\n          │   & Password    │\n          ╰────────┬────────╯\n                   │\n                   ▼\n          ╭─────────────────╮\n          │    Validate     │\n          │   Credentials   │\n          ╰────────┬────────╯\n                   │\n                   ▼\n                  ◇\n                 ╱ ╲\n        [valid] ╱   ╲ [invalid]\n               ╱     ╲\n              │       │\n              │       ▼\n              │  ╭─────────────────╮\n              │  │   Increment     │\n              │  │ Failed Attempts │\n              │  ╰────────┬────────╯\n              │           │\n              │           ▼\n              │          ◇\n              │         ╱ ╲\n              │[&lt; 3]   ╱   ╲ [≥ 3]\n              │       ╱     ╲\n              │      │       │\n              │      │       ▼\n              │      │  ╭─────────────────╮\n              │      │  │  Lock Account   │\n              │      │  │  (30 minutes)   │\n              │      │  ╰────────┬────────╯\n              │      │           │\n              │      │           ▼\n              │      │  ╭─────────────────╮\n              │      │  │  Display Lock   │\n              │      │  │    Message      │\n              │      │  ╰────────┬────────╯\n              │      │           │\n              │      │           │\n              │      └─────┬─────┘\n              │            │\n              │            ▼\n              │   ╭─────────────────╮\n              │   │  Display Error  │\n              │   │    Message      │\n              │   ╰────────┬────────╯\n              │            │\n              │            │ (loop back to form)\n              │            │\n              ▼            │\n     ╭─────────────────╮   │\n     │  Create Session │   │\n     ╰────────┬────────╯   │\n              │            │\n              ▼            │\n     ╭─────────────────╮   │\n     │   Redirect to   │   │\n     │    Dashboard    │   │\n     ╰────────┬────────╯   │\n              │            │\n              ▼            │\n              ◉            │\n\n\n3.4.5 Best Practices for Activity Diagrams\nStructure:\n\nStart with a single initial node\nEnd with one or more final nodes (or flow nodes for ongoing processes)\nEvery path from the initial node should eventually reach a final node or loop\n\nDecisions and Merges:\n\nEvery decision needs at least two outgoing flows\nGuard conditions should be mutually exclusive and complete\nUse merges to rejoin split paths (optional but clarifies the diagram)\n\nParallelism:\n\nUse forks when activities can happen simultaneously\nUse joins to synchronize parallel paths\nAll forked paths must eventually join (or reach a final node)\n\nSwimlanes:\n\nUse when multiple actors or systems are involved\nHelps clarify responsibility for each activity\nSwimlanes can be vertical or horizontal\n\nLevel of Detail:\n\nMatch detail level to the diagram’s purpose\nHigh-level process diagrams: fewer, larger activities\nDetailed workflow diagrams: more granular steps\nAvoid mixing abstraction levels in one diagram\n\nCommon Mistakes:\n\nMissing guard conditions on decision branches\nUnbalanced forks and joins\nNo path to final node\nActivities that are too vague (“Process stuff”) or too detailed (“Set variable x to 5”)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#sequence-diagrams",
    "href": "chapters/03-systems-modeling.html#sequence-diagrams",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.6 3.5 Sequence Diagrams",
    "text": "6.6 3.5 Sequence Diagrams\nSequence diagrams show how objects interact with each other over time. They’re particularly useful for modeling the behavior of use cases, showing the messages exchanged between objects to accomplish a task.\n\n3.5.1 Sequence Diagram Elements\nLifelines represent participants in the interaction. Each lifeline has a name and optionally a type, with a dashed line extending downward representing the participant’s existence over time.\n┌────────────────┐\n│   :Customer    │\n└───────┬────────┘\n        │\n        │ (lifeline)\n        │\n        │\nMessages are communications between lifelines, shown as arrows:\nSynchronous message (solid arrow, filled head): Sender waits for response\n────────────────────►\nAsynchronous message (solid arrow, open head): Sender continues without waiting\n────────────────────▷\nReturn message (dashed arrow): Response to a synchronous call\n- - - - - - - - - - ►\nSelf-message (arrow back to same lifeline): Object calls itself\n    ┌───┐\n────┤   │\n    │   │\n◄───┘   │\n        │\nActivation bars (rectangles on lifelines) show when an object is active (executing):\n┌────────────┐                    ┌────────────┐\n│  :Client   │                    │  :Server   │\n└─────┬──────┘                    └──────┬─────┘\n      │                                  │\n      │      request()                   │\n      │─────────────────────────────────►│\n      │                                  ┃\n      │                                  ┃ (processing)\n      │                                  ┃\n      │      response                    ┃\n      │◄─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┃\n      │                                  │\n\n\n3.5.2 Combined Fragments\nCombined fragments represent control structures like loops, conditions, and alternatives:\nalt (alternatives): Conditional logic (if-else)\n    ┌──────────────────────────────────────┐\n    │ alt  [condition]                     │\n    │      ├───────────────────────────────┤\n    │      │  (messages if true)           │\n    │      ├───────────────────────────────┤\n    │      │  [else]                       │\n    │      │  (messages if false)          │\n    └──────────────────────────────────────┘\nopt (optional): Conditional execution (if without else)\n    ┌──────────────────────────────────────┐\n    │ opt  [condition]                     │\n    │      │                               │\n    │      │  (messages if condition true) │\n    │      │                               │\n    └──────────────────────────────────────┘\nloop: Repeated execution\n    ┌──────────────────────────────────────┐\n    │ loop [condition or count]            │\n    │      │                               │\n    │      │  (repeated messages)          │\n    │      │                               │\n    └──────────────────────────────────────┘\npar (parallel): Concurrent execution\n    ┌──────────────────────────────────────┐\n    │ par                                  │\n    │      │  (parallel region 1)          │\n    │      ├───────────────────────────────┤\n    │      │  (parallel region 2)          │\n    └──────────────────────────────────────┘\n\n\n3.5.3 Complete Sequence Diagram Example\nHere’s a sequence diagram for a user login process:\n┌──────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐\n│  :User   │     │:LoginController│    │:AuthService  │     │  :Database   │\n└────┬─────┘     └──────┬───────┘     └──────┬───────┘     └──────┬───────┘\n     │                  │                    │                    │\n     │  enterCredentials(username, password) │                    │\n     │─────────────────►│                    │                    │\n     │                  │                    │                    │\n     │                  │  authenticate(username, password)       │\n     │                  │───────────────────►│                    │\n     │                  │                    │                    │\n     │                  │                    │  findUser(username)│\n     │                  │                    │───────────────────►│\n     │                  │                    │                    │\n     │                  │                    │    user            │\n     │                  │                    │◄─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n     │                  │                    │                    │\n     │                  │                    │                    │\n     │    ┌─────────────────────────────────────────────────────────────┐\n     │    │ alt  [user exists]                                         │\n     │    │             │                    │                         │\n     │    │             │                    │  verifyPassword(        │\n     │    │             │                    │    password,            │\n     │    │             │                    │    user.hashedPassword) │\n     │    │             │                    │────┐                    │\n     │    │             │                    │    │                    │\n     │    │             │                    │◄───┘                    │\n     │    │             │                    │                         │\n     │    │   ┌────────────────────────────────────────────────────┐   │\n     │    │   │ alt  [password valid]                              │   │\n     │    │   │         │                    │                     │   │\n     │    │   │         │                    │  createSession(user)│   │\n     │    │   │         │                    │────┐                │   │\n     │    │   │         │                    │    │                │   │\n     │    │   │         │                    │◄───┘                │   │\n     │    │   │         │                    │                     │   │\n     │    │   │         │   sessionToken     │                     │   │\n     │    │   │         │◄─ ─ ─ ─ ─ ─ ─ ─ ─ ─│                     │   │\n     │    │   │         │                    │                     │   │\n     │    │   │  loginSuccess(token)         │                     │   │\n     │    │   │◄─ ─ ─ ─ │                    │                     │   │\n     │    │   │         │                    │                     │   │\n     │    │   ├─────────────────────────────────────────────────────   │\n     │    │   │ [else]  │                    │                     │   │\n     │    │   │         │                    │                     │   │\n     │    │   │         │  AuthException     │                     │   │\n     │    │   │         │◄─ ─ ─ ─ ─ ─ ─ ─ ─ ─│                     │   │\n     │    │   │         │                    │                     │   │\n     │    │   │  loginFailed(\"Invalid password\")                   │   │\n     │    │   │◄─ ─ ─ ─ │                    │                     │   │\n     │    │   │         │                    │                     │   │\n     │    │   └────────────────────────────────────────────────────┘   │\n     │    │             │                    │                         │\n     │    ├─────────────────────────────────────────────────────────────\n     │    │ [else]      │                    │                         │\n     │    │             │                    │                         │\n     │    │             │  AuthException     │                         │\n     │    │             │◄─ ─ ─ ─ ─ ─ ─ ─ ─ ─│                         │\n     │    │             │                    │                         │\n     │    │  loginFailed(\"User not found\")   │                         │\n     │    │◄─ ─ ─ ─ ─ ─ │                    │                         │\n     │    │             │                    │                         │\n     │    └─────────────────────────────────────────────────────────────┘\n     │                  │                    │                    │\n     │  displayResult() │                    │                    │\n     │◄─ ─ ─ ─ ─ ─ ─ ─ ─│                    │                    │\n     │                  │                    │                    │\n\n\n3.5.4 Object Creation and Destruction\nObjects can be created during the interaction:\n┌──────────┐                              \n│ :Factory │                              \n└────┬─────┘                              \n     │                                    \n     │         create()                   ┌──────────────┐\n     │───────────────────────────────────►│  :Product    │\n     │                                    └──────┬───────┘\n     │                                           │\n     │                                           │\nObjects can be destroyed (shown with an X):\n     │                                           │\n     │                                           │\n     │         destroy()                         │\n     │──────────────────────────────────────────►X\n     │                                           \n\n\n3.5.5 Best Practices for Sequence Diagrams\nFocus:\n\nOne diagram per scenario or use case\nShow the main success path; use separate diagrams for alternatives\nInclude enough detail to understand the interaction, but not implementation minutiae\n\nNaming:\n\nName lifelines with role:Type format (e.g., :Customer, cart:ShoppingCart)\nUse descriptive message names that indicate what happens\nInclude parameters when they add clarity\n\nLayout:\n\nArrange lifelines left-to-right in order of first involvement\nPlace the initiating actor on the left\nKeep crossing message lines to a minimum\n\nLevel of Detail:\n\nHigh-level diagrams: show major components and their interactions\nDetailed diagrams: show individual method calls and returns\nMatch detail level to your audience and purpose\n\nCommon Mistakes:\n\nToo many lifelines (hard to read; consider splitting the diagram)\nMissing return messages for synchronous calls\nUnclear message sequencing\nMixing abstraction levels (business actions and technical implementation)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#class-diagrams",
    "href": "chapters/03-systems-modeling.html#class-diagrams",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.7 3.6 Class Diagrams",
    "text": "6.7 3.6 Class Diagrams\nClass diagrams show the static structure of a system: the classes, their attributes and methods, and the relationships between them. They’re the most commonly used UML diagram for designing object-oriented systems.\n\n3.6.1 Class Notation\nA class is shown as a rectangle divided into three compartments:\n┌─────────────────────────────────┐\n│          ClassName              │  ← Name compartment\n├─────────────────────────────────┤\n│ - privateAttribute: Type        │  ← Attributes compartment\n│ # protectedAttribute: Type      │\n│ + publicAttribute: Type         │\n├─────────────────────────────────┤\n│ + publicMethod(): ReturnType    │  ← Operations compartment\n│ - privateMethod(param: Type)    │\n│ # protectedMethod(): void       │\n└─────────────────────────────────┘\nVisibility markers:\n\n+ Public\n- Private\n# Protected\n~ Package\n\nAttribute syntax:\nvisibility name: type [multiplicity] = defaultValue\nExamples:\n- id: int\n+ name: String\n- items: Product [0..*]\n+ status: OrderStatus = PENDING\nOperation syntax:\nvisibility name(parameters): returnType\nExamples:\n+ calculateTotal(): Decimal\n- validateInput(data: String): Boolean\n+ addItem(product: Product, quantity: int): void\n\n\n3.6.2 Relationships Between Classes\nAssociation: A general relationship between classes. Objects of one class know about objects of the other.\n┌─────────────┐                    ┌─────────────┐\n│   Student   │────────────────────│   Course    │\n└─────────────┘                    └─────────────┘\nWith role names and multiplicity:\n┌─────────────┐     enrolledIn     ┌─────────────┐\n│   Student   │──────────────────►│   Course    │\n└─────────────┘  1..*        0..*  └─────────────┘\nA student is enrolled in zero or more courses; a course has one or more students.\nNavigability: Arrows indicate which class knows about which:\n┌─────────────┐                    ┌─────────────┐\n│    Order    │───────────────────►│  Customer   │\n└─────────────┘                    └─────────────┘\nOrder knows about Customer, but Customer doesn’t have a direct reference to Order.\nAggregation (hollow diamond): “Has-a” relationship where parts can exist independently of the whole.\n┌─────────────┐                    ┌─────────────┐\n│  Department │◇───────────────────│  Employee   │\n└─────────────┘                    └─────────────┘\nA department has employees, but employees can exist without the department.\nComposition (filled diamond): “Has-a” relationship where parts cannot exist without the whole.\n┌─────────────┐                    ┌─────────────┐\n│    Order    │◆───────────────────│  OrderLine  │\n└─────────────┘                    └─────────────┘\nAn order contains order lines; order lines cannot exist without an order.\nInheritance/Generalization (hollow triangle): “Is-a” relationship; one class is a specialized version of another.\n         ┌─────────────┐\n         │   Vehicle   │\n         └──────△──────┘\n                │\n       ┌────────┼────────┐\n       │        │        │\n┌──────┴──────┐ │ ┌──────┴──────┐\n│     Car     │ │ │    Truck    │\n└─────────────┘ │ └─────────────┘\n         ┌──────┴──────┐\n         │ Motorcycle  │\n         └─────────────┘\nRealization/Implementation (dashed line, hollow triangle): A class implements an interface.\n┌─────────────────────┐\n│   «interface»       │\n│    Comparable       │\n├─────────────────────┤\n│                     │\n├─────────────────────┤\n│ + compareTo(): int  │\n└──────────△──────────┘\n           ┊\n           ┊\n┌──────────┴──────────┐\n│      Product        │\n├─────────────────────┤\n│ - name: String      │\n│ - price: Decimal    │\n├─────────────────────┤\n│ + compareTo(): int  │\n└─────────────────────┘\nDependency (dashed arrow): A weaker relationship; one class uses another temporarily.\n┌─────────────┐                    ┌─────────────┐\n│   Report    │- - - - - - - - - -►│  Formatter  │\n└─────────────┘                    └─────────────┘\nReport depends on Formatter (perhaps uses it as a parameter or local variable) but doesn’t hold a long-term reference.\n\n\n3.6.3 Association Classes\nSometimes a relationship itself has attributes. An association class captures this:\n┌─────────────┐                    ┌─────────────┐\n│   Student   │────────────────────│   Course    │\n└─────────────┘          │         └─────────────┘\n                         │\n                    ┌────┴────┐\n                    │Enrollment│\n                    ├─────────┤\n                    │- grade  │\n                    │- date   │\n                    └─────────┘\nThe Enrollment class captures attributes of the student-course relationship (grade, enrollment date).\n\n\n3.6.4 Complete Class Diagram Example\nHere’s a class diagram for a simplified e-commerce system:\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                                                                             │\n│    ┌─────────────────────┐              ┌─────────────────────┐             │\n│    │     «interface»     │              │     «abstract»      │             │\n│    │      Payable        │              │       User          │             │\n│    ├─────────────────────┤              ├─────────────────────┤             │\n│    │                     │              │ - id: int           │             │\n│    ├─────────────────────┤              │ - email: String     │             │\n│    │ + pay(): Boolean    │              │ - password: String  │             │\n│    │ + getAmount(): Dec  │              │ - createdAt: Date   │             │\n│    └──────────△──────────┘              ├─────────────────────┤             │\n│               ┊                         │ + login(): Boolean  │             │\n│               ┊                         │ + logout(): void    │             │\n│               ┊                         └──────────△──────────┘             │\n│               ┊                                    │                        │\n│               ┊                    ┌───────────────┼───────────────┐        │\n│               ┊                    │               │               │        │\n│    ┌──────────┴──────────┐  ┌──────┴──────┐ ┌──────┴──────┐ ┌──────┴──────┐ │\n│    │       Order         │  │  Customer   │ │    Admin    │ │   Vendor    │ │\n│    ├─────────────────────┤  ├─────────────┤ ├─────────────┤ ├─────────────┤ │\n│    │ - id: int           │  │- firstName  │ │- department │ │- companyName│ │\n│    │ - orderDate: Date   │  │- lastName   │ │- role       │ │- rating     │ │\n│    │ - status: Status    │  │- address    │ ├─────────────┤ ├─────────────┤ │\n│    │ - total: Decimal    │  ├─────────────┤ │+manageUsers │ │+addProduct  │ │\n│    ├─────────────────────┤  │+placeOrder()│ │+viewReports │ │+viewSales   │ │\n│    │ + pay(): Boolean    │  │+getOrders() │ └─────────────┘ └─────────────┘ │\n│    │ + getAmount(): Dec  │  └──────┬──────┘                                 │\n│    │ + cancel(): void    │         │ places                                 │\n│    │ + ship(): void      │         │ 1                                      │\n│    └─────────┬───────────┘         │                                        │\n│              │◆                    │                                        │\n│              │ contains            │                                        │\n│              │ 1..*         ┌──────┴──────────────────┐                     │\n│    ┌─────────┴───────────┐  │                         │                     │\n│    │     OrderLine       │  │                         │ 0..*                │\n│    ├─────────────────────┤  │                         │                     │\n│    │ - quantity: int     │  │  ┌─────────────────────────────────────┐      │\n│    │ - unitPrice: Decimal│  │  │              Product                │      │\n│    ├─────────────────────┤  │  ├─────────────────────────────────────┤      │\n│    │ + getSubtotal(): Dec│  │  │ - id: int                           │      │\n│    └─────────┬───────────┘  │  │ - name: String                      │      │\n│              │              │  │ - description: String               │      │\n│              │ 1            │  │ - price: Decimal                    │      │\n│              │              │  │ - stock: int                        │      │\n│              └──────────────┼─►├─────────────────────────────────────┤      │\n│                             │  │ + updateStock(qty: int): void       │      │\n│                             │  │ + isAvailable(): Boolean            │      │\n│                             │  └─────────────────┬───────────────────┘      │\n│                             │                    │                          │\n│                             │                    │ belongsTo                │\n│                             │                    │ *                        │\n│                             │         ┌──────────┴──────────┐               │\n│                             │         │      Category       │               │\n│                             │         ├─────────────────────┤               │\n│                             │         │ - id: int           │               │\n│                             │         │ - name: String      │               │\n│                             │         │ - parent: Category  │               │\n│                             │         ├─────────────────────┤               │\n│                             │         │ + getProducts(): [] │               │\n│                             │         └─────────────────────┘               │\n│                             │                                               │\n└─────────────────────────────┴───────────────────────────────────────────────┘\n\n\n3.6.5 Domain Models vs. Design Class Diagrams\nClass diagrams serve different purposes at different project stages:\nDomain Model (conceptual class diagram):\n\nCreated during requirements/analysis\nShows concepts in the problem domain\nFocuses on what exists, not implementation\nUses business terminology\nMinimal or no methods\nNo implementation-specific types\n\nDesign Class Diagram:\n\nCreated during design\nShows software classes\nIncludes implementation details\nUses programming terminology\nComplete methods with signatures\nSpecific types (String, int, List)\n\nExample: Domain Model\n┌─────────────┐        places         ┌─────────────┐\n│  Customer   │───────────────────────│    Order    │\n├─────────────┤ 1                0..* ├─────────────┤\n│ name        │                       │ date        │\n│ address     │                       │ total       │\n└─────────────┘                       │ status      │\n                                      └─────────────┘\nExample: Design Class Diagram\n┌─────────────────────────────┐        ┌─────────────────────────────┐\n│         Customer            │        │           Order             │\n├─────────────────────────────┤        ├─────────────────────────────┤\n│ - id: Long                  │        │ - id: Long                  │\n│ - firstName: String         │ 1    * │ - orderDate: LocalDate      │\n│ - lastName: String          │◄───────│ - total: BigDecimal         │\n│ - email: String             │        │ - status: OrderStatus       │\n│ - addresses: List&lt;Address&gt;  │        │ - customerId: Long          │\n├─────────────────────────────┤        ├─────────────────────────────┤\n│ + getFullName(): String     │        │ + calculateTotal(): void    │\n│ + addAddress(a: Address)    │        │ + cancel(): Boolean         │\n│ + getOrders(): List&lt;Order&gt;  │        │ + ship(): Boolean           │\n└─────────────────────────────┘        └─────────────────────────────┘\n\n\n3.6.6 Best Practices for Class Diagrams\nOrganization:\n\nGroup related classes together\nUse packages for larger diagrams\nConsider multiple diagrams for different views or subsystems\n\nDetail Level:\n\nDomain models: concepts and relationships only\nDesign diagrams: full detail for implementation\nOverview diagrams: key classes and relationships, minimal detail\n\nRelationships:\n\nChoose the right relationship type (association vs. dependency)\nInclude multiplicities for associations\nAdd role names when they add clarity\nUse navigability arrows to show direction of knowledge\n\nNaming:\n\nClasses: noun phrases (Customer, ShoppingCart)\nAttributes: noun phrases (firstName, orderTotal)\nMethods: verb phrases (calculateTotal, validateInput)\nUse consistent naming conventions\n\nCommon Mistakes:\n\nToo much detail (every attribute and method)\nToo little detail (just boxes with names)\nIncorrect relationship types\nMissing multiplicities\nConfusing domain concepts with implementation classes",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#choosing-the-right-diagram",
    "href": "chapters/03-systems-modeling.html#choosing-the-right-diagram",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.8 3.7 Choosing the Right Diagram",
    "text": "6.8 3.7 Choosing the Right Diagram\nWith multiple diagram types available, how do you decide which to use?\n\n3.7.1 Matching Diagrams to Questions\n\n\n\n\n\n\n\nQuestion You’re Answering\nDiagram Type\n\n\n\n\nWhat can the system do? Who uses it?\nUse Case Diagram\n\n\nHow does a process flow? What are the steps?\nActivity Diagram\n\n\nHow do objects interact to accomplish a task?\nSequence Diagram\n\n\nWhat classes exist? How are they related?\nClass Diagram\n\n\nWhat states can an object be in?\nState Machine Diagram\n\n\nHow is the system deployed?\nDeployment Diagram\n\n\nHow is code organized into packages?\nPackage Diagram\n\n\n\n\n\n3.7.2 Diagrams Through the Development Lifecycle\nRequirements Phase:\n\nUse Case diagrams to capture functionality\nActivity diagrams for business processes\nDomain models for key concepts\n\nDesign Phase:\n\nSequence diagrams for use case realizations\nClass diagrams for detailed design\nState diagrams for complex object behavior\nComponent and deployment diagrams for architecture\n\nImplementation Phase:\n\nClass diagrams as code reference\nSequence diagrams for complex interactions\nActivity diagrams for algorithms\n\nTesting Phase:\n\nUse cases and activity diagrams for test scenarios\nSequence diagrams for integration test design\n\n\n\n3.7.3 Diagram Selection Guide\n                        ┌─────────────────────────┐\n                        │ What do you want to     │\n                        │ model?                  │\n                        └───────────┬─────────────┘\n                                    │\n              ┌─────────────────────┼─────────────────────┐\n              │                     │                     │\n              ▼                     ▼                     ▼\n    ┌─────────────────┐   ┌─────────────────┐   ┌─────────────────┐\n    │ System          │   │ Dynamic         │   │ Static          │\n    │ Functionality   │   │ Behavior        │   │ Structure       │\n    └────────┬────────┘   └────────┬────────┘   └────────┬────────┘\n             │                     │                     │\n             ▼                     │                     ▼\n    ╭─────────────────╮            │            ╭─────────────────╮\n    │ Use Case        │            │            │ Class           │\n    │ Diagram         │            │            │ Diagram         │\n    ╰─────────────────╯            │            ╰─────────────────╯\n                                   │\n                   ┌───────────────┼───────────────┐\n                   │               │               │\n                   ▼               ▼               ▼\n         ┌─────────────┐  ┌─────────────┐  ┌─────────────┐\n         │ Process/    │  │ Object      │  │ Object      │\n         │ Workflow    │  │ Interactions│  │ Lifecycle   │\n         └──────┬──────┘  └──────┬──────┘  └──────┬──────┘\n                │                │                │\n                ▼                ▼                ▼\n       ╭─────────────────╮╭─────────────────╮╭─────────────────╮\n       │ Activity        ││ Sequence        ││ State Machine   │\n       │ Diagram         ││ Diagram         ││ Diagram         │\n       ╰─────────────────╯╰─────────────────╯╰─────────────────╯",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#modeling-tools",
    "href": "chapters/03-systems-modeling.html#modeling-tools",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.9 3.8 Modeling Tools",
    "text": "6.9 3.8 Modeling Tools\nWhile you can sketch UML diagrams on paper or whiteboards, tools provide benefits like professional appearance, easy modification, and collaboration features.\n\n3.8.1 Categories of Tools\nFull-Featured UML Tools:\n\nEnterprise Architect (commercial)\nVisual Paradigm (commercial/free community edition)\nStarUML (commercial/free)\nModelio (open source)\n\nThese tools offer complete UML support, code generation, reverse engineering, and team collaboration.\nDiagramming Tools with UML Support:\n\nLucidchart (web-based, collaborative)\nDraw.io/diagrams.net (free, web and desktop)\nMicrosoft Visio (commercial)\nMiro (web-based, collaborative)\n\nThese tools support UML shapes but aren’t specialized UML tools.\nText-Based Tools:\n\nPlantUML (text to diagram)\nMermaid (text to diagram, integrates with Markdown)\nNomnoml (text to diagram)\n\nThese tools let you write diagrams in a text format that’s version-control friendly.\n\n\n3.8.2 PlantUML Example\nPlantUML uses a simple text syntax to generate diagrams:\nUse Case Diagram:\n@startuml\nleft to right direction\nactor Customer\nactor Admin\n\nrectangle \"Online Store\" {\n    Customer --&gt; (Browse Products)\n    Customer --&gt; (Place Order)\n    Customer --&gt; (Track Order)\n    Admin --&gt; (Manage Products)\n    Admin --&gt; (Process Orders)\n    (Place Order) .&gt; (Process Payment) : include\n}\n@enduml\nSequence Diagram:\n@startuml\nactor User\nparticipant \"Login Controller\" as LC\nparticipant \"Auth Service\" as AS\ndatabase \"User DB\" as DB\n\nUser -&gt; LC: enterCredentials(user, pass)\nLC -&gt; AS: authenticate(user, pass)\nAS -&gt; DB: findUser(user)\nDB --&gt; AS: user\nAS -&gt; AS: verifyPassword()\nAS --&gt; LC: token\nLC --&gt; User: loginSuccess(token)\n@enduml\nClass Diagram:\n@startuml\nclass Customer {\n    -id: Long\n    -name: String\n    -email: String\n    +placeOrder(): Order\n}\n\nclass Order {\n    -id: Long\n    -date: Date\n    -status: OrderStatus\n    +calculateTotal(): Decimal\n    +cancel(): void\n}\n\nclass OrderLine {\n    -quantity: int\n    -unitPrice: Decimal\n    +getSubtotal(): Decimal\n}\n\nCustomer \"1\" -- \"0..*\" Order : places\nOrder \"1\" *-- \"1..*\" OrderLine : contains\n@enduml\n\n\n3.8.3 Mermaid Example\nMermaid integrates well with Markdown and is supported by GitHub, GitLab, and many documentation platforms:\nSequence Diagram:\nsequenceDiagram\n    participant U as User\n    participant L as LoginController\n    participant A as AuthService\n    participant D as Database\n    \n    U-&gt;&gt;L: enterCredentials(user, pass)\n    L-&gt;&gt;A: authenticate(user, pass)\n    A-&gt;&gt;D: findUser(user)\n    D--&gt;&gt;A: user\n    A-&gt;&gt;A: verifyPassword()\n    A--&gt;&gt;L: token\n    L--&gt;&gt;U: loginSuccess(token)\nClass Diagram:\nclassDiagram\n    class Customer {\n        -Long id\n        -String name\n        -String email\n        +placeOrder() Order\n    }\n    \n    class Order {\n        -Long id\n        -Date date\n        -OrderStatus status\n        +calculateTotal() Decimal\n        +cancel() void\n    }\n    \n    Customer \"1\" --&gt; \"0..*\" Order : places\n\n\n3.8.4 Tool Selection Considerations\nWhen choosing a modeling tool, consider:\n\nLearning curve: How quickly can you become productive?\nCollaboration: Does your team need to work together on diagrams?\nIntegration: Does it integrate with your other tools (IDE, documentation)?\nCost: Is it within budget?\nVersion control: Can diagrams be tracked in Git?\nExport options: What formats can you export to?\n\nFor your course project, Draw.io (free, easy) or PlantUML (text-based, version-control friendly) are excellent choices.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#chapter-summary",
    "href": "chapters/03-systems-modeling.html#chapter-summary",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.10 3.9 Chapter Summary",
    "text": "6.10 3.9 Chapter Summary\nSystems modeling provides visual blueprints that help us understand, communicate, and design software. UML offers a standardized notation for these models, with different diagram types serving different purposes.\nKey takeaways from this chapter:\n\nModels are simplified representations that help us understand complex systems. Different diagrams reveal different aspects of the system.\nUse Case diagrams capture system functionality from the user’s perspective. They show actors (who uses the system) and use cases (what they can do).\nActivity diagrams model workflows and processes. They’re excellent for showing the steps in a process, decision points, parallel activities, and swimlanes for responsibility.\nSequence diagrams show how objects interact over time. They’re particularly useful for modeling use case scenarios and understanding the flow of messages between components.\nClass diagrams show the static structure of the system: classes, their attributes and methods, and relationships between them. They range from conceptual domain models to detailed design specifications.\nChoosing the right diagram depends on what you’re trying to communicate. Use case diagrams for requirements, activity diagrams for processes, sequence diagrams for interactions, and class diagrams for structure.\nTools range from simple drawing applications to sophisticated modeling environments. Text-based tools like PlantUML offer version-control-friendly alternatives.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#key-terms",
    "href": "chapters/03-systems-modeling.html#key-terms",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.11 3.10 Key Terms",
    "text": "6.11 3.10 Key Terms\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nUML\nUnified Modeling Language; a standardized visual notation for software systems\n\n\nActor\nAn external entity (person, system, device) that interacts with the system\n\n\nUse Case\nA discrete piece of functionality that provides value to an actor\n\n\nActivity Diagram\nA diagram showing the flow of activities in a process\n\n\nSwimlane\nA partition in an activity diagram showing who performs each activity\n\n\nSequence Diagram\nA diagram showing object interactions over time\n\n\nLifeline\nThe representation of a participant in a sequence diagram\n\n\nClass Diagram\nA diagram showing classes, their attributes/methods, and relationships\n\n\nAssociation\nA relationship between classes indicating objects of one class know about objects of another\n\n\nAggregation\nA “has-a” relationship where parts can exist independently\n\n\nComposition\nA “has-a” relationship where parts cannot exist without the whole\n\n\nGeneralization\nAn “is-a” (inheritance) relationship between classes\n\n\nDomain Model\nA conceptual class diagram showing concepts in the problem domain\n\n\nMultiplicity\nThe number of instances that participate in a relationship",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#review-questions",
    "href": "chapters/03-systems-modeling.html#review-questions",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.12 3.11 Review Questions",
    "text": "6.12 3.11 Review Questions\n\nExplain the purpose of systems modeling in software engineering. What are three benefits of creating models before writing code?\nWhat is the difference between structural and behavioral UML diagrams? Give two examples of each.\nIn a use case diagram, what is the difference between the «include» and «extend» relationships? When would you use each?\nCreate a use case diagram for an ATM system. Include at least three actors and eight use cases with appropriate relationships.\nExplain the purpose of swimlanes in activity diagrams. When are they most useful?\nWhat is the difference between a fork and a decision in an activity diagram? How do they differ visually and semantically?\nIn a sequence diagram, what is the difference between synchronous and asynchronous messages? When would you use each?\nExplain the difference between aggregation and composition in class diagrams. Provide an example of each.\nWhat is the difference between a domain model and a design class diagram? At what project phase would you create each?\nYou’re designing a ride-sharing application. Which UML diagrams would you create, and what would each show?",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#hands-on-exercises",
    "href": "chapters/03-systems-modeling.html#hands-on-exercises",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.13 3.12 Hands-On Exercises",
    "text": "6.13 3.12 Hands-On Exercises\n\nExercise 3.1: Use Case Diagram\nCreate a use case diagram for a hotel reservation system. Include:\n\nAt least 3 actors (consider guests, staff, external systems)\nAt least 10 use cases\nAt least 2 «include» relationships\nAt least 1 «extend» relationship\nA system boundary\n\nWrite detailed use case descriptions for 2 of your use cases.\n\n\nExercise 3.2: Activity Diagram\nCreate an activity diagram for one of the following processes:\nOption A: Online food ordering (from browsing menu to delivery) Option B: Library book borrowing (including reservation if unavailable) Option C: Job application process (from submission to hire/reject)\nInclude:\n\nInitial and final nodes\nAt least 2 decision points with guards\nAt least 1 fork/join for parallel activities\nSwimlanes showing different participants\n\n\n\nExercise 3.3: Sequence Diagram\nCreate a sequence diagram for one of the following scenarios:\nOption A: User purchasing an item online (including payment processing) Option B: User posting a message to a social media platform Option C: ATM withdrawal transaction\nInclude:\n\nAt least 4 lifelines\nAt least one combined fragment (alt, opt, or loop)\nSynchronous and return messages\nActivation bars\n\n\n\nExercise 3.4: Class Diagram\nCreate a class diagram for a course registration system. Include:\n\nAt least 8 classes\nAppropriate attributes and methods for each class\nAt least one inheritance relationship\nAt least one composition relationship\nAt least one association with multiplicity\nAn interface\n\n\n\nExercise 3.5: Project UML Package\nFor your semester project, create a UML package containing:\n\nA use case diagram showing the main functionality\nAn activity diagram for a key process or workflow\nA sequence diagram for a primary use case\nA domain model (conceptual class diagram)\n\nUpload all diagrams to your GitHub repository in a docs/diagrams folder.\n\n\nExercise 3.6: Tool Exploration\nChoose one of these modeling approaches and create the class diagram from Exercise 3.4:\n\nDraw.io: Create the diagram using the web-based tool\nPlantUML: Write the diagram in text format\nMermaid: Write the diagram in Mermaid syntax in a Markdown file\n\nCompare the experience. Which do you prefer and why?",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#further-reading",
    "href": "chapters/03-systems-modeling.html#further-reading",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.14 3.13 Further Reading",
    "text": "6.14 3.13 Further Reading\nBooks:\n\nFowler, M. (2003). UML Distilled: A Brief Guide to the Standard Object Modeling Language (3rd Edition). Addison-Wesley.\nLarman, C. (2004). Applying UML and Patterns (3rd Edition). Prentice Hall.\nRumbaugh, J., Jacobson, I., & Booch, G. (2004). The Unified Modeling Language Reference Manual (2nd Edition). Addison-Wesley.\n\nOnline Resources:\n\nUML Specification (OMG): https://www.omg.org/spec/UML/\nPlantUML Documentation: https://plantuml.com/\nMermaid Documentation: https://mermaid.js.org/\nDraw.io: https://app.diagrams.net/\nVisual Paradigm UML Guides: https://www.visual-paradigm.com/guide/uml-unified-modeling-language/\n\nTutorials:\n\nUML Diagrams (Lucidchart): https://www.lucidchart.com/pages/uml\nUML Tutorial (Tutorialspoint): https://www.tutorialspoint.com/uml/",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/03-systems-modeling.html#references",
    "href": "chapters/03-systems-modeling.html#references",
    "title": "6  Chapter 3: Systems Modeling and UML",
    "section": "6.15 References",
    "text": "6.15 References\nBooch, G., Rumbaugh, J., & Jacobson, I. (2005). The Unified Modeling Language User Guide (2nd Edition). Addison-Wesley.\nFowler, M. (2003). UML Distilled: A Brief Guide to the Standard Object Modeling Language (3rd Edition). Addison-Wesley.\nLarman, C. (2004). Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development (3rd Edition). Prentice Hall.\nObject Management Group. (2017). OMG Unified Modeling Language (OMG UML) Version 2.5.1. Retrieved from https://www.omg.org/spec/UML/2.5.1/\nRumbaugh, J., Jacobson, I., & Booch, G. (2004). The Unified Modeling Language Reference Manual (2nd Edition). Addison-Wesley.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 3: Systems Modeling and UML</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html",
    "href": "chapters/04-software-architecture.html",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "",
    "text": "7.1 Learning Objectives\nBy the end of this chapter, you will be able to:",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#learning-objectives",
    "href": "chapters/04-software-architecture.html#learning-objectives",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "",
    "text": "Define software architecture and explain its importance in system development\nCompare and contrast major architectural styles and patterns\nApply the SOLID principles to create maintainable, flexible designs\nRecognize and implement common creational, structural, and behavioral design patterns\nMake informed architectural decisions based on system requirements\nCreate a Software Architecture Document (SAD) for a project\nEvaluate trade-offs between different architectural approaches",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#what-is-software-architecture",
    "href": "chapters/04-software-architecture.html#what-is-software-architecture",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.2 4.1 What Is Software Architecture?",
    "text": "7.2 4.1 What Is Software Architecture?\nWhen you look at a building, you don’t see a random pile of bricks, steel, and glass. You see structure: floors stacked upon floors, walls dividing spaces, a roof keeping out the rain. That structure isn’t accidental—an architect designed it to serve the building’s purpose while meeting constraints of physics, budget, and building codes.\nSoftware systems have architecture too. While you can’t see or touch it, the architecture profoundly affects how the system behaves, how it can be modified, and whether it will succeed or fail over its lifetime.\nSoftware architecture refers to the fundamental structures of a software system, the discipline of creating such structures, and the documentation of these structures. It encompasses the high-level decisions about how components are organized, how they communicate, and how the system achieves its quality requirements.\n\n4.1.1 Why Architecture Matters\nArchitecture decisions are among the most consequential choices in software development. They’re also among the hardest to change later.\nEarly decisions with lasting impact: Architectural choices made in the first weeks of a project constrain what’s possible for years afterward. Choosing a monolithic architecture means you can’t easily scale individual components. Choosing microservices means you need to handle distributed system complexity. Neither choice is inherently right or wrong, but both have long-lasting consequences.\nQuality attributes depend on architecture: How fast is your system? How reliable? How secure? How easy to modify? These quality attributes aren’t primarily determined by code quality—they emerge from architectural decisions. A well-designed system can be fast and reliable even with some sloppy code. A poorly architected system will struggle no matter how carefully each line is written.\nCommunication framework: Architecture provides a vocabulary for discussing the system. When you say “the payment service calls the order service,” everyone understands what you mean. Without architecture, conversations about the system devolve into discussions of individual files and functions.\nRisk management: Architectural decisions address the biggest risks in a project. If scalability is critical, the architecture must support it from the start. If security is paramount, architectural controls must be in place. Trying to add these qualities later is expensive at best, impossible at worst.\n\n\n4.1.2 Architecture vs. Design\nPeople often confuse software architecture with software design, and the boundary between them is genuinely fuzzy. Here’s a useful distinction:\nArchitecture concerns the decisions that are:\n\nHard to change later\nAffect multiple components or the entire system\nRelated to quality attributes (performance, security, maintainability)\nAbout structure at a high level of abstraction\n\nDesign concerns the decisions that are:\n\nRelatively easy to change\nAffect individual components or modules\nRelated to implementing specific functionality\nAbout structure at a lower level of abstraction\n\nConsider a house analogy: Architecture is deciding to have three stories, placing load-bearing walls, and running plumbing through certain walls. Design is choosing cabinet hardware, paint colors, and light fixtures. You can change the paint without affecting the building’s structure; you can’t easily move a load-bearing wall.\nIn software, architecture might decide that the system uses a microservices approach with an API gateway, message queues for asynchronous communication, and a separate database per service. Design might decide that a particular service uses the Repository pattern for data access, or that a specific class uses the Strategy pattern for algorithm selection.\nThe line between architecture and design shifts based on context. In a small application, the decision to use a particular database might be “just design.” In a large enterprise system, that same decision might be architectural because it affects so many components.\n\n\n4.1.3 The Role of the Software Architect\nIn some organizations, “software architect” is a formal title held by senior technical staff. In others, architecture is a responsibility shared among the team. Either way, architectural thinking involves:\nUnderstanding requirements: Both functional requirements and quality attributes (often called non-functional requirements). A system that needs to handle 100 users has different architectural needs than one serving 10 million.\nMaking trade-offs: Every architectural decision involves trade-offs. Microservices offer scalability but add complexity. Caching improves performance but risks stale data. The architect’s job is to make these trade-offs explicitly and wisely.\nCommunicating decisions: Architecture must be documented and communicated. If the team doesn’t understand the architecture, they’ll inadvertently undermine it with every coding decision.\nEvolving the architecture: Requirements change. Technology evolves. Architectures must adapt. The best architectures anticipate change and make evolution possible.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#architectural-styles-and-patterns",
    "href": "chapters/04-software-architecture.html#architectural-styles-and-patterns",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.3 4.2 Architectural Styles and Patterns",
    "text": "7.3 4.2 Architectural Styles and Patterns\nAn architectural style is a named collection of architectural decisions that are commonly applied in a given context, along with the constraints that produce certain desirable qualities. Think of architectural styles as templates or patterns that have proven effective for certain types of systems.\nLet’s explore the major architectural styles you’ll encounter in modern software development.\n\n4.2.1 Layered Architecture\nThe layered architecture (also called n-tier architecture) organizes the system into horizontal layers, each providing services to the layer above it and consuming services from the layer below.\n┌─────────────────────────────────────────────────────────────┐\n│                    Presentation Layer                        │\n│            (UI, Views, Controllers, API endpoints)           │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│                    Business Logic Layer                      │\n│              (Services, Domain logic, Rules)                 │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│                    Data Access Layer                         │\n│           (Repositories, DAOs, ORM mappings)                 │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│                      Database Layer                          │\n│              (Database, File system, External APIs)          │\n└─────────────────────────────────────────────────────────────┘\nKey Principles:\n\nEach layer has a specific responsibility\nLayers only communicate with adjacent layers (typically downward)\nHigher layers depend on lower layers, not vice versa\nEach layer can be developed and tested somewhat independently\n\nCommon Layer Configurations:\nThree-tier architecture:\n\nPresentation (UI)\nBusiness Logic\nData\n\nFour-tier architecture:\n\nPresentation\nApplication/API\nBusiness Logic\nData\n\nAdvantages:\n\nSeparation of concerns: Each layer focuses on one aspect of the system\nTestability: Layers can be tested independently with mocks for adjacent layers\nMaintainability: Changes to one layer typically don’t affect others\nTeam organization: Different teams can work on different layers\nFamiliar pattern: Well understood by most developers\n\nDisadvantages:\n\nPerformance overhead: Requests must pass through all layers\nMonolithic deployment: Usually deployed as a single unit\nRigidity: Strict layering can feel constraining\nGod classes risk: Business logic layer can become bloated\n\nWhen to Use:\n\nTraditional enterprise applications\nApplications with clear separation between presentation, logic, and data\nTeams familiar with this pattern\nSystems where simplicity is valued over flexibility\n\nExample Structure (Web Application):\nsrc/\n├── presentation/\n│   ├── controllers/\n│   │   ├── UserController.java\n│   │   └── OrderController.java\n│   └── views/\n│       └── ...\n├── business/\n│   ├── services/\n│   │   ├── UserService.java\n│   │   └── OrderService.java\n│   └── domain/\n│       ├── User.java\n│       └── Order.java\n├── data/\n│   ├── repositories/\n│   │   ├── UserRepository.java\n│   │   └── OrderRepository.java\n│   └── entities/\n│       └── ...\n└── config/\n    └── ...\n\n\n4.2.2 Model-View-Controller (MVC)\nMVC is an architectural pattern that separates an application into three interconnected components, originally developed for desktop GUIs but now ubiquitous in web applications.\n                         ┌─────────────────┐\n                         │      User       │\n                         └────────┬────────┘\n                                  │\n                         interacts with\n                                  │\n                                  ▼\n┌─────────────────────────────────────────────────────────────┐\n│                           VIEW                               │\n│                    (Displays data to user)                   │\n└─────────────────────────────────────────────────────────────┘\n         ▲                                          │\n         │                                          │\n    updates                                    user actions\n         │                                          │\n         │                                          ▼\n┌─────────────────┐                    ┌─────────────────────┐\n│                 │   manipulates      │                     │\n│      MODEL      │◄───────────────────│     CONTROLLER      │\n│   (Data and     │                    │   (Handles input,   │\n│    Logic)       │────────────────────►│    coordinates)     │\n│                 │    notifies        │                     │\n└─────────────────┘                    └─────────────────────┘\nComponents:\nModel: Manages the data, logic, and rules of the application. It’s independent of the user interface. When data changes, the model notifies observers (often the view).\nView: Presents data to the user. It receives data from the model and renders it. Multiple views can display the same model data differently.\nController: Accepts input from the user (via the view), converts it to commands for the model or view. It’s the intermediary between user interaction and system response.\nMVC Variants:\nTraditional MVC (as above): Model notifies View directly of changes.\nMVP (Model-View-Presenter): The Presenter mediates all communication between Model and View. The View is passive.\n┌─────────┐     ┌─────────────┐     ┌─────────┐\n│  View   │◄───►│  Presenter  │◄───►│  Model  │\n└─────────┘     └─────────────┘     └─────────┘\nMVVM (Model-View-ViewModel): Common in modern frontend frameworks. ViewModel exposes data streams that the View binds to.\n┌─────────┐   data binding   ┌─────────────┐     ┌─────────┐\n│  View   │◄═══════════════►│  ViewModel  │◄───►│  Model  │\n└─────────┘                  └─────────────┘     └─────────┘\nMVC in Web Frameworks:\nMost web frameworks implement a variation of MVC:\n\nRuby on Rails: Traditional MVC with ActiveRecord models\nDjango: Often called MTV (Model-Template-View)\nSpring MVC: Java-based MVC framework\nASP.NET MVC: Microsoft’s MVC implementation\nExpress.js: Flexible, but commonly structured as MVC\n\nExample Flow (Web Application):\n1. User submits login form\n   │\n   ▼\n2. Controller receives POST /login\n   │\n   ▼\n3. Controller extracts credentials, calls UserService.authenticate()\n   │\n   ▼\n4. Model (UserService) validates credentials against database\n   │\n   ▼\n5. Model returns result to Controller\n   │\n   ▼\n6. Controller selects appropriate View (dashboard or error page)\n   │\n   ▼\n7. View renders response and returns to user\nAdvantages:\n\nClear separation of concerns\nMultiple views for same data\nEasier testing (test model independently)\nParallel development (UI team and backend team)\nWell-supported by many frameworks\n\nDisadvantages:\n\nCan be complex for simple applications\nControllers can become bloated (“fat controllers”)\nTight coupling between View and Controller\nLearning curve for proper implementation\n\n\n\n4.2.3 Microservices Architecture\nMicroservices architecture structures an application as a collection of small, autonomous services that communicate over a network. Each service is independently deployable, scalable, and can be written in different programming languages.\n┌─────────────────────────────────────────────────────────────────────────┐\n│                              API Gateway                                 │\n└───────────────────────────────────┬─────────────────────────────────────┘\n                                    │\n        ┌───────────────┬───────────┼───────────┬───────────────┐\n        │               │           │           │               │\n        ▼               ▼           ▼           ▼               ▼\n┌───────────────┐ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐\n│    User       │ │    Order      │ │   Product     │ │   Payment     │\n│   Service     │ │   Service     │ │   Service     │ │   Service     │\n├───────────────┤ ├───────────────┤ ├───────────────┤ ├───────────────┤\n│   [Users DB]  │ │  [Orders DB]  │ │ [Products DB] │ │ [Payments DB] │\n└───────────────┘ └───────────────┘ └───────────────┘ └───────────────┘\n        │               │                   │               │\n        └───────────────┴─────────┬─────────┴───────────────┘\n                                  │\n                         ┌────────▼────────┐\n                         │  Message Queue  │\n                         │  (Async Comm)   │\n                         └─────────────────┘\nKey Characteristics:\n\nSingle responsibility: Each service does one thing well\nAutonomy: Services are independently deployable\nDecentralized data: Each service manages its own database\nSmart endpoints, dumb pipes: Services contain the logic; communication infrastructure is simple\nDesign for failure: Services expect other services to fail\nEvolutionary design: Easy to replace or rewrite individual services\n\nService Communication:\nSynchronous (Request-Response):\n\nREST APIs over HTTP\ngRPC for high-performance communication\nGraphQL for flexible querying\n\nAsynchronous (Event-Based):\n\nMessage queues (RabbitMQ, Amazon SQS)\nEvent streaming (Apache Kafka)\nPub/sub patterns\n\nCommon Microservices Patterns:\nAPI Gateway: Single entry point that routes requests to appropriate services, handles cross-cutting concerns (authentication, rate limiting).\nService Discovery: Services register themselves and discover other services dynamically (Consul, Eureka, Kubernetes).\nCircuit Breaker: Prevents cascade failures by stopping calls to failing services temporarily.\nSaga Pattern: Manages distributed transactions across multiple services.\nAdvantages:\n\nIndependent deployment: Update one service without deploying the entire system\nTechnology flexibility: Use different languages/frameworks for different services\nScalability: Scale individual services based on demand\nResilience: Failure in one service doesn’t bring down the whole system\nTeam autonomy: Teams own their services end-to-end\nEasier to understand: Each service is small and focused\n\nDisadvantages:\n\nDistributed system complexity: Network failures, latency, data consistency\nOperational overhead: Many services to deploy, monitor, and manage\nTesting challenges: Integration testing is complex\nData consistency: No ACID transactions across services\nInitial development speed: More infrastructure to set up\nDebugging difficulty: Requests span multiple services\n\nWhen to Use:\n\nLarge, complex applications\nSystems requiring high scalability\nOrganizations with multiple autonomous teams\nSystems with varying scalability needs across components\nWhen technology diversity is beneficial\n\nWhen to Avoid:\n\nSmall applications or startups (start with a modular monolith)\nTeams without DevOps expertise\nApplications where strong consistency is critical\nWhen operational maturity is low\n\n\n\n4.2.4 Event-Driven Architecture\nEvent-driven architecture (EDA) is built around the production, detection, consumption, and reaction to events. An event represents a significant change in state.\n┌─────────────┐     event     ┌─────────────────┐     event     ┌─────────────┐\n│   Event     │──────────────►│   Event Bus /   │──────────────►│   Event     │\n│  Producer   │               │   Message Queue │               │  Consumer   │\n└─────────────┘               └─────────────────┘               └─────────────┘\n                                      │\n                                      │ event\n                                      ▼\n                              ┌─────────────┐\n                              │   Event     │\n                              │  Consumer   │\n                              └─────────────┘\nKey Concepts:\nEvent: A record of something that happened. Events are immutable facts. “OrderPlaced,” “UserRegistered,” “PaymentReceived.”\nEvent Producer: A component that detects or creates events and publishes them.\nEvent Consumer: A component that listens for events and reacts to them.\nEvent Channel: The mechanism that transports events from producers to consumers (message queue, event stream).\nEvent-Driven Patterns:\nSimple Event Notification: Producer publishes an event; consumers react. The event contains minimal data—just that something happened.\nEvent: { type: \"OrderPlaced\", orderId: \"12345\", timestamp: \"...\" }\nEvent-Carried State Transfer: Events contain all data needed by consumers, reducing the need for callbacks.\nEvent: { \n  type: \"OrderPlaced\", \n  orderId: \"12345\",\n  customer: { id: \"789\", name: \"Alice\", email: \"...\" },\n  items: [...],\n  total: 150.00\n}\nEvent Sourcing: Instead of storing current state, store the sequence of events that led to current state. The current state is derived by replaying events.\nEvents for Account #123:\n1. AccountOpened { amount: 0 }\n2. Deposited { amount: 100 }\n3. Withdrawn { amount: 30 }\n4. Deposited { amount: 50 }\n\nCurrent balance: 0 + 100 - 30 + 50 = 120\nCQRS (Command Query Responsibility Segregation): Separate models for reading and writing data. Often combined with event sourcing.\n┌─────────────┐                           ┌─────────────┐\n│  Commands   │───────► Write Model ──────│   Events    │\n└─────────────┘              │            └──────┬──────┘\n                             │                   │\n                             ▼                   ▼\n                       Write Database      Read Database\n                                                 │\n                             ┌───────────────────┘\n                             ▼\n┌─────────────┐         Read Model\n│   Queries   │◄────────────┘\n└─────────────┘\nAdvantages:\n\nLoose coupling: Producers don’t know about consumers\nScalability: Consumers can be scaled independently\nFlexibility: Easy to add new consumers without changing producers\nResponsiveness: Asynchronous processing improves perceived performance\nAudit trail: Events provide natural logging\nTemporal decoupling: Producers and consumers don’t need to be available simultaneously\n\nDisadvantages:\n\nComplexity: Harder to trace the flow of operations\nEventual consistency: Data may be inconsistent temporarily\nDebugging difficulty: Asynchronous flows are hard to debug\nEvent ordering: Ensuring correct order across distributed systems is challenging\nEvent schema evolution: Changing event formats requires careful migration\n\nWhen to Use:\n\nSystems with many independent components\nHigh-throughput systems with varying load\nSystems requiring real-time reactions\nAudit and compliance requirements\nComplex workflows spanning multiple services\n\n\n\n4.2.5 Monolithic Architecture\nBefore moving on, let’s acknowledge the monolithic architecture—often presented as the opposite of microservices, but still a valid choice for many systems.\nA monolith is a single deployable unit containing all application functionality.\n┌─────────────────────────────────────────────────────────────┐\n│                     Monolithic Application                   │\n│                                                             │\n│  ┌───────────────┐ ┌───────────────┐ ┌───────────────┐     │\n│  │     User      │ │     Order     │ │    Product    │     │\n│  │    Module     │ │    Module     │ │    Module     │     │\n│  └───────────────┘ └───────────────┘ └───────────────┘     │\n│                                                             │\n│  ┌───────────────┐ ┌───────────────┐ ┌───────────────┐     │\n│  │    Payment    │ │   Inventory   │ │   Reporting   │     │\n│  │    Module     │ │    Module     │ │    Module     │     │\n│  └───────────────┘ └───────────────┘ └───────────────┘     │\n│                                                             │\n│                    Shared Database                          │\n└─────────────────────────────────────────────────────────────┘\nAdvantages:\n\nSimple to develop, test, deploy, and scale (initially)\nNo distributed system complexity\nEasy debugging and tracing\nACID transactions across the whole application\nLower operational overhead\n\nDisadvantages:\n\nHarder to scale specific components\nTechnology stack is uniform\nLarge codebase becomes unwieldy\nDeployment requires full redeployment\nTeam coordination becomes challenging as system grows\n\nThe Modular Monolith:\nA middle ground between monolith and microservices. The application is deployed as one unit but internally organized into well-defined, loosely-coupled modules.\n┌─────────────────────────────────────────────────────────────┐\n│                     Modular Monolith                         │\n│                                                             │\n│  ┌──────────────────────┐    ┌──────────────────────┐       │\n│  │     User Module      │    │    Order Module      │       │\n│  │  ┌───────┐ ┌──────┐  │    │  ┌───────┐ ┌──────┐  │       │\n│  │  │Public │ │Private│  │◄──►│  │Public │ │Private│  │       │\n│  │  │  API  │ │ Impl  │  │    │  │  API  │ │ Impl  │  │       │\n│  │  └───────┘ └──────┘  │    │  └───────┘ └──────┘  │       │\n│  │      [User DB]       │    │     [Order DB]       │       │\n│  └──────────────────────┘    └──────────────────────┘       │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\nEach module:\n\nHas a well-defined public API\nKeeps implementation details private\nCould have its own database schema\nCommunicates with other modules only through APIs\n\nThis approach provides many benefits of microservices (modularity, team ownership, clear boundaries) while avoiding distributed system complexity. It’s often a good starting point, with the option to extract modules into microservices later if needed.\n\n\n4.2.6 Comparing Architectural Styles\n\n\n\nAspect\nLayered\nMVC\nMicroservices\nEvent-Driven\n\n\n\n\nComplexity\nLow\nLow-Medium\nHigh\nHigh\n\n\nScalability\nLimited\nLimited\nExcellent\nExcellent\n\n\nDeployment\nMonolithic\nMonolithic\nIndependent\nVaries\n\n\nTeam Structure\nHorizontal\nBy function\nBy service\nBy domain\n\n\nTechnology Flexibility\nLow\nLow\nHigh\nHigh\n\n\nData Consistency\nStrong\nStrong\nEventual\nEventual\n\n\nBest For\nTraditional apps\nWeb apps\nLarge systems\nReactive systems",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#the-solid-principles",
    "href": "chapters/04-software-architecture.html#the-solid-principles",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.4 4.3 The SOLID Principles",
    "text": "7.4 4.3 The SOLID Principles\nThe SOLID principles are five design principles that help developers create software that is easy to maintain, understand, and extend. Introduced by Robert C. Martin (Uncle Bob), these principles apply at the class and module level but inform architectural decisions as well.\n\n4.3.1 Single Responsibility Principle (SRP)\n\nA class should have one, and only one, reason to change.\n\nThe Single Responsibility Principle states that a class should have only one job. “Reason to change” refers to the actors or stakeholders who might request changes.\nViolation Example:\npublic class Employee {\n    private String name;\n    private double salary;\n    \n    // Business logic - reason to change: business rules\n    public double calculatePay() {\n        // Calculate salary, overtime, bonuses\n        return salary * 1.0;\n    }\n    \n    // Persistence - reason to change: database schema\n    public void save() {\n        // Save to database\n        Database.execute(\"INSERT INTO employees...\");\n    }\n    \n    // Reporting - reason to change: report format requirements\n    public String generateReport() {\n        // Create performance report\n        return \"Employee Report: \" + name + \"...\";\n    }\n}\nThis class has three reasons to change: business rules, database schema changes, and reporting requirements.\nRefactored:\n// Handles employee data and business rules\npublic class Employee {\n    private String name;\n    private double salary;\n    \n    public double calculatePay() {\n        return salary * 1.0;\n    }\n    \n    // Getters and setters\n}\n\n// Handles persistence\npublic class EmployeeRepository {\n    public void save(Employee employee) {\n        Database.execute(\"INSERT INTO employees...\");\n    }\n    \n    public Employee findById(Long id) {\n        // Load from database\n    }\n}\n\n// Handles reporting\npublic class EmployeeReportGenerator {\n    public String generateReport(Employee employee) {\n        return \"Employee Report: \" + employee.getName() + \"...\";\n    }\n}\nNow each class has one reason to change.\nBenefits:\n\nClasses are smaller and more focused\nChanges are isolated to specific classes\nTesting is simplified\nCode is easier to understand\n\n\n\n4.3.2 Open/Closed Principle (OCP)\n\nSoftware entities should be open for extension but closed for modification.\n\nYou should be able to add new functionality without changing existing code. This is achieved through abstraction and polymorphism.\nViolation Example:\npublic class AreaCalculator {\n    public double calculateArea(Object shape) {\n        if (shape instanceof Rectangle) {\n            Rectangle r = (Rectangle) shape;\n            return r.width * r.height;\n        } else if (shape instanceof Circle) {\n            Circle c = (Circle) shape;\n            return Math.PI * c.radius * c.radius;\n        }\n        // Adding a new shape requires modifying this method!\n        return 0;\n    }\n}\nEvery time we add a new shape, we must modify AreaCalculator.\nRefactored:\npublic interface Shape {\n    double calculateArea();\n}\n\npublic class Rectangle implements Shape {\n    private double width;\n    private double height;\n    \n    @Override\n    public double calculateArea() {\n        return width * height;\n    }\n}\n\npublic class Circle implements Shape {\n    private double radius;\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\n// New shapes can be added without modifying this class\npublic class AreaCalculator {\n    public double calculateArea(Shape shape) {\n        return shape.calculateArea();\n    }\n}\n\n// Adding a new shape - no modification to existing code\npublic class Triangle implements Shape {\n    private double base;\n    private double height;\n    \n    @Override\n    public double calculateArea() {\n        return 0.5 * base * height;\n    }\n}\nNow we can add new shapes by creating new classes, without modifying existing code.\nBenefits:\n\nReduced risk of breaking existing functionality\nNew features can be added safely\nPromotes use of abstractions\nEasier to test new functionality in isolation\n\n\n\n4.3.3 Liskov Substitution Principle (LSP)\n\nObjects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.\n\nSubtypes must be substitutable for their base types. If class B is a subtype of class A, you should be able to use B anywhere you use A without unexpected behavior.\nViolation Example:\npublic class Rectangle {\n    protected int width;\n    protected int height;\n    \n    public void setWidth(int width) {\n        this.width = width;\n    }\n    \n    public void setHeight(int height) {\n        this.height = height;\n    }\n    \n    public int getArea() {\n        return width * height;\n    }\n}\n\npublic class Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width;  // Maintain square invariant\n    }\n    \n    @Override\n    public void setHeight(int height) {\n        this.width = height;  // Maintain square invariant\n        this.height = height;\n    }\n}\nThis seems logical—a square is a rectangle—but it violates LSP:\npublic void testRectangle(Rectangle r) {\n    r.setWidth(5);\n    r.setHeight(4);\n    assert r.getArea() == 20;  // Fails for Square! Area would be 16.\n}\nCode written for Rectangle breaks when given a Square.\nRefactored:\npublic interface Shape {\n    int getArea();\n}\n\npublic class Rectangle implements Shape {\n    private int width;\n    private int height;\n    \n    public Rectangle(int width, int height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    @Override\n    public int getArea() {\n        return width * height;\n    }\n}\n\npublic class Square implements Shape {\n    private int side;\n    \n    public Square(int side) {\n        this.side = side;\n    }\n    \n    @Override\n    public int getArea() {\n        return side * side;\n    }\n}\nNow Square and Rectangle don’t have an inheritance relationship that creates behavioral conflicts.\nSigns of LSP Violations:\n\nSubclasses that throw UnsupportedOperationException\nSubclasses that override methods to do nothing\nType checking with instanceof before calling methods\nUnexpected behavior when substituting subtypes\n\n\n\n4.3.4 Interface Segregation Principle (ISP)\n\nClients should not be forced to depend on interfaces they do not use.\n\nLarge interfaces should be split into smaller, more specific ones so that clients only need to know about methods relevant to them.\nViolation Example:\npublic interface Worker {\n    void work();\n    void eat();\n    void sleep();\n}\n\npublic class HumanWorker implements Worker {\n    @Override\n    public void work() { /* ... */ }\n    \n    @Override\n    public void eat() { /* ... */ }\n    \n    @Override\n    public void sleep() { /* ... */ }\n}\n\npublic class RobotWorker implements Worker {\n    @Override\n    public void work() { /* ... */ }\n    \n    @Override\n    public void eat() {\n        throw new UnsupportedOperationException(\"Robots don't eat\");\n    }\n    \n    @Override\n    public void sleep() {\n        throw new UnsupportedOperationException(\"Robots don't sleep\");\n    }\n}\nRobotWorker is forced to implement methods it doesn’t use.\nRefactored:\npublic interface Workable {\n    void work();\n}\n\npublic interface Eatable {\n    void eat();\n}\n\npublic interface Sleepable {\n    void sleep();\n}\n\npublic class HumanWorker implements Workable, Eatable, Sleepable {\n    @Override\n    public void work() { /* ... */ }\n    \n    @Override\n    public void eat() { /* ... */ }\n    \n    @Override\n    public void sleep() { /* ... */ }\n}\n\npublic class RobotWorker implements Workable {\n    @Override\n    public void work() { /* ... */ }\n}\nNow each class implements only the interfaces it needs.\nBenefits:\n\nClasses aren’t forced to implement unused methods\nInterfaces are more cohesive\nChanges to one interface don’t affect unrelated clients\nEasier to understand what a class does\n\n\n\n4.3.5 Dependency Inversion Principle (DIP)\n\nHigh-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.\n\nThis principle is about decoupling. High-level business logic should not directly depend on low-level implementation details like databases or file systems.\nViolation Example:\npublic class MySQLDatabase {\n    public void save(String data) {\n        // Save to MySQL\n    }\n}\n\npublic class UserService {\n    private MySQLDatabase database;  // Direct dependency on implementation\n    \n    public UserService() {\n        this.database = new MySQLDatabase();\n    }\n    \n    public void createUser(String userData) {\n        // Business logic\n        database.save(userData);\n    }\n}\nUserService (high-level) directly depends on MySQLDatabase (low-level). Changing databases requires modifying UserService.\nRefactored:\n// Abstraction\npublic interface Database {\n    void save(String data);\n}\n\n// Low-level implementation depends on abstraction\npublic class MySQLDatabase implements Database {\n    @Override\n    public void save(String data) {\n        // Save to MySQL\n    }\n}\n\npublic class MongoDatabase implements Database {\n    @Override\n    public void save(String data) {\n        // Save to MongoDB\n    }\n}\n\n// High-level module depends on abstraction\npublic class UserService {\n    private Database database;  // Depends on interface, not implementation\n    \n    public UserService(Database database) {  // Dependency injection\n        this.database = database;\n    }\n    \n    public void createUser(String userData) {\n        // Business logic\n        database.save(userData);\n    }\n}\nNow both high-level (UserService) and low-level (MySQLDatabase) depend on the abstraction (Database).\nDependency Injection:\nDIP is often implemented through dependency injection, where dependencies are provided to a class rather than created by it:\n// Constructor injection\nUserService service = new UserService(new MySQLDatabase());\n\n// Or for testing\nUserService testService = new UserService(new MockDatabase());\nBenefits:\n\nLoose coupling between components\nEasier testing (inject mocks)\nFlexibility to change implementations\nHigh-level modules are insulated from low-level changes\n\n\n\n4.3.6 SOLID Summary\n\n\n\n\n\n\n\n\nPrinciple\nFocus\nKey Benefit\n\n\n\n\nSingle Responsibility\nOne reason to change\nMaintainability\n\n\nOpen/Closed\nOpen for extension, closed for modification\nExtensibility\n\n\nLiskov Substitution\nSubtypes are substitutable\nCorrectness\n\n\nInterface Segregation\nSmall, specific interfaces\nFlexibility\n\n\nDependency Inversion\nDepend on abstractions\nLoose coupling",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#design-patterns",
    "href": "chapters/04-software-architecture.html#design-patterns",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.5 4.4 Design Patterns",
    "text": "7.5 4.4 Design Patterns\nDesign patterns are reusable solutions to common problems in software design. They’re not code you can copy directly but templates for solving problems that can be adapted to many situations.\nThe seminal book “Design Patterns: Elements of Reusable Object-Oriented Software” by the Gang of Four (GoF)—Gamma, Helm, Johnson, and Vlissides—cataloged 23 patterns in three categories: Creational, Structural, and Behavioral.\n\n4.4.1 Creational Patterns\nCreational patterns deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.\n\nSingleton Pattern\nIntent: Ensure a class has only one instance and provide a global point of access to it.\nWhen to Use:\n\nExactly one instance is needed (database connection pool, configuration manager)\nControlled access to a shared resource\nGlobal state that needs to be consistent\n\nStructure:\n┌─────────────────────────────────┐\n│           Singleton             │\n├─────────────────────────────────┤\n│ - instance: Singleton           │\n├─────────────────────────────────┤\n│ - Singleton()                   │\n│ + getInstance(): Singleton      │\n│ + operation(): void             │\n└─────────────────────────────────┘\nImplementation:\npublic class DatabaseConnection {\n    private static DatabaseConnection instance;\n    private Connection connection;\n    \n    // Private constructor prevents direct instantiation\n    private DatabaseConnection() {\n        this.connection = createConnection();\n    }\n    \n    // Thread-safe lazy initialization\n    public static synchronized DatabaseConnection getInstance() {\n        if (instance == null) {\n            instance = new DatabaseConnection();\n        }\n        return instance;\n    }\n    \n    public void query(String sql) {\n        // Execute query using connection\n    }\n    \n    private Connection createConnection() {\n        // Create database connection\n        return null;\n    }\n}\n\n// Usage\nDatabaseConnection db = DatabaseConnection.getInstance();\ndb.query(\"SELECT * FROM users\");\nCautions:\n\nSingletons introduce global state, which can make testing difficult\nThey can hide dependencies (classes use the singleton without it being in their interface)\nConsider dependency injection instead in many cases\n\n\n\nFactory Method Pattern\nIntent: Define an interface for creating an object, but let subclasses decide which class to instantiate.\nWhen to Use:\n\nA class can’t anticipate the class of objects it must create\nA class wants its subclasses to specify the objects it creates\nYou want to localize the logic of which class to instantiate\n\nStructure:\n┌─────────────────────────────────┐\n│        Creator (abstract)       │\n├─────────────────────────────────┤\n│ + factoryMethod(): Product      │\n│ + operation(): void             │\n└───────────────┬─────────────────┘\n                │\n    ┌───────────┴───────────┐\n    │                       │\n┌───┴───────────────┐  ┌────┴──────────────┐\n│ ConcreteCreatorA  │  │ ConcreteCreatorB  │\n├───────────────────┤  ├───────────────────┤\n│ + factoryMethod() │  │ + factoryMethod() │\n│   : ProductA      │  │   : ProductB      │\n└───────────────────┘  └───────────────────┘\nImplementation:\n// Product interface\npublic interface Notification {\n    void send(String message);\n}\n\n// Concrete products\npublic class EmailNotification implements Notification {\n    @Override\n    public void send(String message) {\n        System.out.println(\"Sending email: \" + message);\n    }\n}\n\npublic class SMSNotification implements Notification {\n    @Override\n    public void send(String message) {\n        System.out.println(\"Sending SMS: \" + message);\n    }\n}\n\npublic class PushNotification implements Notification {\n    @Override\n    public void send(String message) {\n        System.out.println(\"Sending push notification: \" + message);\n    }\n}\n\n// Creator with factory method\npublic class NotificationFactory {\n    public Notification createNotification(String type) {\n        switch (type.toLowerCase()) {\n            case \"email\":\n                return new EmailNotification();\n            case \"sms\":\n                return new SMSNotification();\n            case \"push\":\n                return new PushNotification();\n            default:\n                throw new IllegalArgumentException(\"Unknown type: \" + type);\n        }\n    }\n}\n\n// Usage\nNotificationFactory factory = new NotificationFactory();\nNotification notification = factory.createNotification(\"email\");\nnotification.send(\"Hello, World!\");\n\n\nBuilder Pattern\nIntent: Separate the construction of a complex object from its representation, allowing the same construction process to create different representations.\nWhen to Use:\n\nObject construction requires many parameters\nSome parameters are optional\nObject creation involves multiple steps\nConstructors with many parameters are confusing\n\nStructure:\n┌─────────────────────────────────┐\n│            Builder              │\n├─────────────────────────────────┤\n│ + setPartA(): Builder           │\n│ + setPartB(): Builder           │\n│ + setPartC(): Builder           │\n│ + build(): Product              │\n└─────────────────────────────────┘\nImplementation:\npublic class User {\n    private final String firstName;     // Required\n    private final String lastName;      // Required\n    private final String email;         // Required\n    private final String phone;         // Optional\n    private final String address;       // Optional\n    private final int age;              // Optional\n    \n    private User(UserBuilder builder) {\n        this.firstName = builder.firstName;\n        this.lastName = builder.lastName;\n        this.email = builder.email;\n        this.phone = builder.phone;\n        this.address = builder.address;\n        this.age = builder.age;\n    }\n    \n    // Getters...\n    \n    public static class UserBuilder {\n        private final String firstName;\n        private final String lastName;\n        private final String email;\n        private String phone;\n        private String address;\n        private int age;\n        \n        public UserBuilder(String firstName, String lastName, String email) {\n            this.firstName = firstName;\n            this.lastName = lastName;\n            this.email = email;\n        }\n        \n        public UserBuilder phone(String phone) {\n            this.phone = phone;\n            return this;\n        }\n        \n        public UserBuilder address(String address) {\n            this.address = address;\n            return this;\n        }\n        \n        public UserBuilder age(int age) {\n            this.age = age;\n            return this;\n        }\n        \n        public User build() {\n            return new User(this);\n        }\n    }\n}\n\n// Usage - fluent interface\nUser user = new User.UserBuilder(\"John\", \"Doe\", \"john@example.com\")\n    .phone(\"555-1234\")\n    .age(30)\n    .build();\n\n\n\n4.4.2 Structural Patterns\nStructural patterns deal with object composition—how classes and objects are combined to form larger structures.\n\nAdapter Pattern\nIntent: Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.\nWhen to Use:\n\nYou want to use an existing class with an incompatible interface\nYou’re integrating with third-party code you can’t modify\nYou need to create a reusable class that cooperates with unrelated classes\n\nStructure:\n┌──────────────┐        ┌──────────────┐\n│    Client    │───────►│   Target     │\n└──────────────┘        │  Interface   │\n                        └──────┬───────┘\n                               │\n                        ┌──────┴───────┐\n                        │   Adapter    │─────────┐\n                        └──────────────┘         │\n                                                 │\n                        ┌──────────────┐         │\n                        │   Adaptee    │◄────────┘\n                        │ (existing)   │\n                        └──────────────┘\nImplementation:\n// Existing interface our code uses\npublic interface MediaPlayer {\n    void play(String filename);\n}\n\n// Existing class with incompatible interface (third-party library)\npublic class AdvancedVideoPlayer {\n    public void playMp4(String filename) {\n        System.out.println(\"Playing MP4: \" + filename);\n    }\n    \n    public void playVlc(String filename) {\n        System.out.println(\"Playing VLC: \" + filename);\n    }\n}\n\n// Adapter makes AdvancedVideoPlayer compatible with MediaPlayer\npublic class VideoPlayerAdapter implements MediaPlayer {\n    private AdvancedVideoPlayer advancedPlayer;\n    \n    public VideoPlayerAdapter() {\n        this.advancedPlayer = new AdvancedVideoPlayer();\n    }\n    \n    @Override\n    public void play(String filename) {\n        if (filename.endsWith(\".mp4\")) {\n            advancedPlayer.playMp4(filename);\n        } else if (filename.endsWith(\".vlc\")) {\n            advancedPlayer.playVlc(filename);\n        } else {\n            throw new UnsupportedOperationException(\"Format not supported\");\n        }\n    }\n}\n\n// Usage\nMediaPlayer player = new VideoPlayerAdapter();\nplayer.play(\"movie.mp4\");  // Works through adapter\n\n\nDecorator Pattern\nIntent: Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.\nWhen to Use:\n\nAdd responsibilities to individual objects without affecting other objects\nResponsibilities can be withdrawn\nExtension by subclassing is impractical or impossible\n\nStructure:\n┌─────────────────────────────────┐\n│        Component (interface)    │\n├─────────────────────────────────┤\n│ + operation(): void             │\n└───────────────┬─────────────────┘\n                │\n     ┌──────────┴──────────┐\n     │                     │\n┌────┴────────────┐  ┌─────┴──────────────────┐\n│ConcreteComponent│  │   Decorator (abstract) │\n├─────────────────┤  ├────────────────────────┤\n│ + operation()   │  │ - component: Component │\n└─────────────────┘  │ + operation()          │\n                     └───────────┬────────────┘\n                                 │\n                     ┌───────────┴───────────┐\n                     │                       │\n              ┌──────┴──────────┐  ┌─────────┴────────┐\n              │DecoratorA       │  │DecoratorB        │\n              ├─────────────────┤  ├──────────────────┤\n              │+ operation()    │  │+ operation()     │\n              │+ addedBehavior()│  │+ addedBehavior() │\n              └─────────────────┘  └──────────────────┘\nImplementation:\n// Component interface\npublic interface Coffee {\n    String getDescription();\n    double getCost();\n}\n\n// Concrete component\npublic class SimpleCoffee implements Coffee {\n    @Override\n    public String getDescription() {\n        return \"Simple Coffee\";\n    }\n    \n    @Override\n    public double getCost() {\n        return 2.00;\n    }\n}\n\n// Base decorator\npublic abstract class CoffeeDecorator implements Coffee {\n    protected Coffee coffee;\n    \n    public CoffeeDecorator(Coffee coffee) {\n        this.coffee = coffee;\n    }\n    \n    @Override\n    public String getDescription() {\n        return coffee.getDescription();\n    }\n    \n    @Override\n    public double getCost() {\n        return coffee.getCost();\n    }\n}\n\n// Concrete decorators\npublic class MilkDecorator extends CoffeeDecorator {\n    public MilkDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    @Override\n    public String getDescription() {\n        return coffee.getDescription() + \", Milk\";\n    }\n    \n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.50;\n    }\n}\n\npublic class SugarDecorator extends CoffeeDecorator {\n    public SugarDecorator(Coffee coffee) {\n        super(coffee);\n    }\n    \n    @Override\n    public String getDescription() {\n        return coffee.getDescription() + \", Sugar\";\n    }\n    \n    @Override\n    public double getCost() {\n        return coffee.getCost() + 0.25;\n    }\n}\n\n// Usage - decorators can be stacked\nCoffee coffee = new SimpleCoffee();\ncoffee = new MilkDecorator(coffee);\ncoffee = new SugarDecorator(coffee);\n\nSystem.out.println(coffee.getDescription());  // Simple Coffee, Milk, Sugar\nSystem.out.println(coffee.getCost());         // 2.75\n\n\nFacade Pattern\nIntent: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.\nWhen to Use:\n\nYou want to provide a simple interface to a complex subsystem\nThere are many dependencies between clients and implementation classes\nYou want to layer your subsystems\n\nStructure:\n                    ┌─────────────────┐\n                    │     Client      │\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │     Facade      │\n                    └────────┬────────┘\n                             │\n     ┌───────────────────────┼───────────────────────┐\n     │                       │                       │\n     ▼                       ▼                       ▼\n┌─────────────┐       ┌─────────────┐       ┌─────────────┐\n│ Subsystem A │       │ Subsystem B │       │ Subsystem C │\n└─────────────┘       └─────────────┘       └─────────────┘\nImplementation:\n// Complex subsystem classes\npublic class CPU {\n    public void freeze() { System.out.println(\"CPU: Freezing\"); }\n    public void jump(long position) { System.out.println(\"CPU: Jumping to \" + position); }\n    public void execute() { System.out.println(\"CPU: Executing\"); }\n}\n\npublic class Memory {\n    public void load(long position, byte[] data) {\n        System.out.println(\"Memory: Loading data at \" + position);\n    }\n}\n\npublic class HardDrive {\n    public byte[] read(long lba, int size) {\n        System.out.println(\"HardDrive: Reading \" + size + \" bytes from \" + lba);\n        return new byte[size];\n    }\n}\n\n// Facade provides simple interface\npublic class ComputerFacade {\n    private CPU cpu;\n    private Memory memory;\n    private HardDrive hardDrive;\n    \n    private static final long BOOT_ADDRESS = 0x0000;\n    private static final long BOOT_SECTOR = 0x001;\n    private static final int SECTOR_SIZE = 512;\n    \n    public ComputerFacade() {\n        this.cpu = new CPU();\n        this.memory = new Memory();\n        this.hardDrive = new HardDrive();\n    }\n    \n    // Simple interface hiding complex boot sequence\n    public void start() {\n        cpu.freeze();\n        byte[] bootData = hardDrive.read(BOOT_SECTOR, SECTOR_SIZE);\n        memory.load(BOOT_ADDRESS, bootData);\n        cpu.jump(BOOT_ADDRESS);\n        cpu.execute();\n        System.out.println(\"Computer started successfully!\");\n    }\n}\n\n// Usage - client only needs to know about facade\nComputerFacade computer = new ComputerFacade();\ncomputer.start();\n\n\n\n4.4.3 Behavioral Patterns\nBehavioral patterns deal with communication between objects—how objects interact and distribute responsibility.\n\nStrategy Pattern\nIntent: Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.\nWhen to Use:\n\nMany related classes differ only in their behavior\nYou need different variants of an algorithm\nAn algorithm uses data that clients shouldn’t know about\nA class defines many behaviors as conditional statements\n\nStructure:\n┌─────────────────────────────────┐\n│           Context               │\n├─────────────────────────────────┤\n│ - strategy: Strategy            │\n├─────────────────────────────────┤\n│ + setStrategy(s: Strategy)      │\n│ + executeStrategy(): void       │\n└─────────────────┬───────────────┘\n                  │\n                  ▼\n┌─────────────────────────────────┐\n│     Strategy (interface)        │\n├─────────────────────────────────┤\n│ + execute(): void               │\n└─────────────────┬───────────────┘\n                  │\n    ┌─────────────┼─────────────┐\n    │             │             │\n┌───┴───────┐ ┌───┴───────┐ ┌───┴───────┐\n│ConcreteA  │ │ConcreteB  │ │ConcreteC  │\n├───────────┤ ├───────────┤ ├───────────┤\n│+ execute()│ │+ execute()│ │+ execute()│\n└───────────┘ └───────────┘ └───────────┘\nImplementation:\n// Strategy interface\npublic interface PaymentStrategy {\n    void pay(double amount);\n}\n\n// Concrete strategies\npublic class CreditCardPayment implements PaymentStrategy {\n    private String cardNumber;\n    private String cvv;\n    \n    public CreditCardPayment(String cardNumber, String cvv) {\n        this.cardNumber = cardNumber;\n        this.cvv = cvv;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" with credit card \" + \n            cardNumber.substring(cardNumber.length() - 4));\n    }\n}\n\npublic class PayPalPayment implements PaymentStrategy {\n    private String email;\n    \n    public PayPalPayment(String email) {\n        this.email = email;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" via PayPal (\" + email + \")\");\n    }\n}\n\npublic class CryptoPayment implements PaymentStrategy {\n    private String walletAddress;\n    \n    public CryptoPayment(String walletAddress) {\n        this.walletAddress = walletAddress;\n    }\n    \n    @Override\n    public void pay(double amount) {\n        System.out.println(\"Paid $\" + amount + \" in crypto to \" + \n            walletAddress.substring(0, 8) + \"...\");\n    }\n}\n\n// Context\npublic class ShoppingCart {\n    private List&lt;Item&gt; items = new ArrayList&lt;&gt;();\n    private PaymentStrategy paymentStrategy;\n    \n    public void addItem(Item item) {\n        items.add(item);\n    }\n    \n    public void setPaymentStrategy(PaymentStrategy strategy) {\n        this.paymentStrategy = strategy;\n    }\n    \n    public void checkout() {\n        double total = items.stream()\n            .mapToDouble(Item::getPrice)\n            .sum();\n        paymentStrategy.pay(total);\n    }\n}\n\n// Usage - switch strategies at runtime\nShoppingCart cart = new ShoppingCart();\ncart.addItem(new Item(\"Book\", 29.99));\ncart.addItem(new Item(\"Pen\", 4.99));\n\ncart.setPaymentStrategy(new CreditCardPayment(\"4111111111111111\", \"123\"));\ncart.checkout();  // Paid $34.98 with credit card 1111\n\ncart.setPaymentStrategy(new PayPalPayment(\"user@email.com\"));\ncart.checkout();  // Paid $34.98 via PayPal (user@email.com)\n\n\nObserver Pattern\nIntent: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\nWhen to Use:\n\nChanges to one object require changing others, and you don’t know how many objects need to change\nAn object should notify other objects without knowing who they are\nYou need to implement event handling systems\n\nStructure:\n┌─────────────────────────────────┐\n│      Subject (interface)        │\n├─────────────────────────────────┤\n│ + attach(o: Observer)           │\n│ + detach(o: Observer)           │\n│ + notify(): void                │\n└─────────────────┬───────────────┘\n                  │\n                  ▼\n┌─────────────────────────────────┐       ┌─────────────────────────────────┐\n│      ConcreteSubject            │       │      Observer (interface)       │\n├─────────────────────────────────┤       ├─────────────────────────────────┤\n│ - state                         │──────►│ + update(): void                │\n│ - observers: List&lt;Observer&gt;     │       └─────────────────┬───────────────┘\n├─────────────────────────────────┤                         │\n│ + getState(): State             │       ┌─────────────────┴───────────────┐\n│ + setState(s: State): void      │       │      ConcreteObserver           │\n└─────────────────────────────────┘       ├─────────────────────────────────┤\n                                          │ + update(): void                │\n                                          └─────────────────────────────────┘\nImplementation:\n// Observer interface\npublic interface Observer {\n    void update(String message);\n}\n\n// Subject interface\npublic interface Subject {\n    void attach(Observer observer);\n    void detach(Observer observer);\n    void notifyObservers();\n}\n\n// Concrete Subject\npublic class NewsAgency implements Subject {\n    private String news;\n    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();\n    \n    @Override\n    public void attach(Observer observer) {\n        observers.add(observer);\n    }\n    \n    @Override\n    public void detach(Observer observer) {\n        observers.remove(observer);\n    }\n    \n    @Override\n    public void notifyObservers() {\n        for (Observer observer : observers) {\n            observer.update(news);\n        }\n    }\n    \n    public void setNews(String news) {\n        this.news = news;\n        notifyObservers();\n    }\n}\n\n// Concrete Observers\npublic class NewsChannel implements Observer {\n    private String name;\n    \n    public NewsChannel(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public void update(String news) {\n        System.out.println(name + \" received news: \" + news);\n    }\n}\n\npublic class MobileApp implements Observer {\n    @Override\n    public void update(String news) {\n        System.out.println(\"Mobile notification: \" + news);\n    }\n}\n\n// Usage\nNewsAgency agency = new NewsAgency();\nNewsChannel cnn = new NewsChannel(\"CNN\");\nNewsChannel bbc = new NewsChannel(\"BBC\");\nMobileApp app = new MobileApp();\n\nagency.attach(cnn);\nagency.attach(bbc);\nagency.attach(app);\n\nagency.setNews(\"Breaking: New discovery on Mars!\");\n// Output:\n// CNN received news: Breaking: New discovery on Mars!\n// BBC received news: Breaking: New discovery on Mars!\n// Mobile notification: Breaking: New discovery on Mars!\n\nagency.detach(bbc);\nagency.setNews(\"Update: Weather forecast changed\");\n// Output:\n// CNN received news: Update: Weather forecast changed\n// Mobile notification: Update: Weather forecast changed\n\n\nTemplate Method Pattern\nIntent: Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.\nWhen to Use:\n\nYou want to implement the invariant parts of an algorithm once and leave variable parts to subclasses\nYou want to control subclass extensions\nCommon behavior among subclasses should be factored and localized in a common class\n\nStructure:\n┌─────────────────────────────────────────┐\n│       AbstractClass                     │\n├─────────────────────────────────────────┤\n│ + templateMethod(): void                │\n│   - step1()                             │\n│   - step2()  // abstract                │\n│   - step3()  // abstract                │\n│   - step4()                             │\n│ # step1(): void                         │\n│ # step2(): void {abstract}              │\n│ # step3(): void {abstract}              │\n│ # step4(): void                         │\n└─────────────────────┬───────────────────┘\n                      │\n       ┌──────────────┴──────────────┐\n       │                             │\n┌──────┴──────────────┐   ┌──────────┴────────┐\n│  ConcreteClassA     │   │  ConcreteClassB   │\n├─────────────────────┤   ├───────────────────┤\n│ # step2(): void     │   │ # step2(): void   │\n│ # step3(): void     │   │ # step3(): void   │\n└─────────────────────┘   └───────────────────┘\nImplementation:\n// Abstract class with template method\npublic abstract class DataProcessor {\n    \n    // Template method - defines the algorithm skeleton\n    public final void process() {\n        readData();\n        processData();\n        writeData();\n        cleanup();\n    }\n    \n    // Common step - same for all subclasses\n    private void readData() {\n        System.out.println(\"Reading data from source...\");\n    }\n    \n    // Abstract steps - must be implemented by subclasses\n    protected abstract void processData();\n    protected abstract void writeData();\n    \n    // Hook method - optional override, has default implementation\n    protected void cleanup() {\n        System.out.println(\"Standard cleanup...\");\n    }\n}\n\n// Concrete implementation for CSV\npublic class CSVProcessor extends DataProcessor {\n    \n    @Override\n    protected void processData() {\n        System.out.println(\"Parsing CSV data, validating fields...\");\n    }\n    \n    @Override\n    protected void writeData() {\n        System.out.println(\"Writing to CSV output file...\");\n    }\n}\n\n// Concrete implementation for JSON\npublic class JSONProcessor extends DataProcessor {\n    \n    @Override\n    protected void processData() {\n        System.out.println(\"Parsing JSON objects, transforming structure...\");\n    }\n    \n    @Override\n    protected void writeData() {\n        System.out.println(\"Writing to JSON output file...\");\n    }\n    \n    @Override\n    protected void cleanup() {\n        System.out.println(\"Closing JSON streams and freeing memory...\");\n    }\n}\n\n// Usage\nDataProcessor csvProcessor = new CSVProcessor();\ncsvProcessor.process();\n// Reading data from source...\n// Parsing CSV data, validating fields...\n// Writing to CSV output file...\n// Standard cleanup...\n\nDataProcessor jsonProcessor = new JSONProcessor();\njsonProcessor.process();\n// Reading data from source...\n// Parsing JSON objects, transforming structure...\n// Writing to JSON output file...\n// Closing JSON streams and freeing memory...\n\n\n\n4.4.4 Design Patterns Summary\n\n\n\nPattern\nCategory\nIntent\n\n\n\n\nSingleton\nCreational\nEnsure one instance with global access\n\n\nFactory Method\nCreational\nDefer instantiation to subclasses\n\n\nBuilder\nCreational\nConstruct complex objects step by step\n\n\nAdapter\nStructural\nConvert interface to expected interface\n\n\nDecorator\nStructural\nAdd responsibilities dynamically\n\n\nFacade\nStructural\nProvide simple interface to complex subsystem\n\n\nStrategy\nBehavioral\nEncapsulate interchangeable algorithms\n\n\nObserver\nBehavioral\nNotify dependents of state changes\n\n\nTemplate Method\nBehavioral\nDefine algorithm skeleton, defer steps",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#the-software-architecture-document-sad",
    "href": "chapters/04-software-architecture.html#the-software-architecture-document-sad",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.6 4.5 The Software Architecture Document (SAD)",
    "text": "7.6 4.5 The Software Architecture Document (SAD)\nA Software Architecture Document (SAD) communicates the architectural decisions for a system. It serves as a reference for developers, a communication tool for stakeholders, and a record of design rationale.\n\n4.5.1 Purpose of the SAD\nThe SAD serves multiple purposes:\nCommunication: Explains the architecture to all stakeholders—developers, managers, operations, security teams.\nDecision Record: Documents what was decided, why, and what alternatives were considered.\nOnboarding: Helps new team members understand the system structure.\nEvolution Guide: Provides context for future architectural changes.\nCompliance: Satisfies documentation requirements in regulated industries.\n\n\n4.5.2 SAD Structure\nWhile formats vary, a typical SAD includes:\n1. Introduction\n   1.1 Purpose\n   1.2 Scope\n   1.3 Definitions, Acronyms, Abbreviations\n   1.4 References\n\n2. Architectural Goals and Constraints\n   2.1 Technical Goals\n   2.2 Business Goals\n   2.3 Constraints\n\n3. Architectural Representation\n   3.1 Architectural Style\n   3.2 Architectural Views\n\n4. Architectural Views\n   4.1 Logical View (Class/Component diagrams)\n   4.2 Process View (Activity/Sequence diagrams)\n   4.3 Development View (Package/Module organization)\n   4.4 Physical View (Deployment diagrams)\n   4.5 Use Case View (Use Case diagrams)\n\n5. Quality Attributes\n   5.1 Performance\n   5.2 Scalability\n   5.3 Security\n   5.4 Reliability\n   5.5 Maintainability\n\n6. Design Decisions\n   6.1 Decision 1: [Title]\n        - Context\n        - Decision\n        - Rationale\n        - Consequences\n   6.2 Decision 2: [Title]\n   ...\n\n7. Size and Performance Targets\n\n8. Quality Assurance\n\nAppendices\n   A. Glossary\n   B. Architecture Decision Records (ADRs)\n\n\n4.5.3 The 4+1 View Model\nPhilippe Kruchten’s 4+1 View Model is a popular way to organize architectural views:\n                         ┌─────────────────┐\n                         │   Use Case      │\n                         │     View        │\n                         │ (Scenarios)     │\n                         └────────┬────────┘\n                                  │\n          ┌───────────────────────┼───────────────────────┐\n          │                       │                       │\n          ▼                       ▼                       ▼\n┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐\n│   Logical       │     │   Process       │     │  Development    │\n│     View        │     │    View         │     │     View        │\n│ (Functionality) │     │ (Concurrency)   │     │ (Organization)  │\n└────────┬────────┘     └────────┬────────┘     └────────┬────────┘\n         │                       │                       │\n         └───────────────────────┼───────────────────────┘\n                                 │\n                                 ▼\n                       ┌─────────────────┐\n                       │   Physical      │\n                       │     View        │\n                       │ (Deployment)    │\n                       └─────────────────┘\nLogical View: The object-oriented decomposition. Shows packages, classes, and their relationships. Addresses functional requirements.\nProcess View: The run-time behavior. Shows processes, threads, and their interactions. Addresses concurrency, distribution, and performance.\nDevelopment View: The static organization of software in its development environment. Shows modules, layers, and packages. Addresses build, configuration management.\nPhysical View: The mapping of software onto hardware. Shows nodes, networks, and deployment. Addresses availability, reliability, performance.\nUse Case View (+1): The scenarios that tie other views together. Shows how the architecture supports key use cases.\n\n\n4.5.4 Architecture Decision Records (ADRs)\nArchitecture Decision Records are a lightweight way to document individual architectural decisions. Each ADR captures one decision in a standardized format.\nADR Template:\n# ADR-001: Use PostgreSQL as Primary Database\n\n## Status\nAccepted\n\n## Context\nWe need a database for storing user data, orders, and product information. \nThe system needs to support complex queries, transactions, and eventual \nscaling to millions of records.\n\n## Decision\nWe will use PostgreSQL as our primary database.\n\n## Rationale\n- Strong ACID compliance for transactional integrity\n- Excellent JSON support for semi-structured data\n- Proven scalability (read replicas, partitioning)\n- Team has existing PostgreSQL expertise\n- Open source with strong community support\n- Cloud providers offer managed PostgreSQL services\n\n## Alternatives Considered\n\n### MySQL\n- Similar capabilities but less robust JSON support\n- Team has less experience\n\n### MongoDB  \n- Better for truly unstructured data\n- Weaker transaction support\n- Would require learning new paradigms\n\n### DynamoDB\n- Excellent scalability but vendor lock-in\n- Limited query flexibility\n- Higher cost at our scale\n\n## Consequences\n\n### Positive\n- Reliable transactions for order processing\n- Flexible schema evolution with JSON columns\n- Easy to find developers with experience\n\n### Negative\n- Need to manage database operations (or use managed service)\n- Eventual consistency challenges if we add read replicas\n- May need sharding strategy for very high scale\n\n## Date\n2024-01-15\n\n## Authors\n- Jane Developer\n- John Architect\nBenefits of ADRs:\n\nDecisions are documented when made, preserving context\nNew team members can understand why things are the way they are\nEnables revisiting decisions when circumstances change\nCreates a decision log over time\nEncourages explicit, deliberate decision-making",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#making-architectural-decisions",
    "href": "chapters/04-software-architecture.html#making-architectural-decisions",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.7 4.6 Making Architectural Decisions",
    "text": "7.7 4.6 Making Architectural Decisions\nGood architecture doesn’t emerge by accident. It results from deliberate decisions made with awareness of trade-offs.\n\n4.6.1 Factors in Architectural Decisions\nFunctional Requirements: What must the system do? Some functionality naturally suggests certain architectures.\nQuality Attributes: Non-functional requirements like performance, scalability, security, and maintainability drive many architectural choices.\nConstraints: Technology constraints, budget, timeline, team skills, regulatory requirements.\nBusiness Context: Organizational structure, build vs. buy decisions, time to market pressures.\nTechnical Context: Existing systems, integration requirements, infrastructure.\n\n\n4.6.2 Common Trade-offs\nPerformance vs. Maintainability: Optimized code is often harder to maintain. Caching improves performance but adds complexity.\nConsistency vs. Availability: In distributed systems, you often can’t have both perfect consistency and continuous availability (CAP theorem).\nFlexibility vs. Simplicity: More abstraction and indirection enable flexibility but increase complexity.\nSecurity vs. Usability: Stronger security measures often make systems harder to use.\nBuild vs. Buy: Custom solutions fit exactly but take time; third-party solutions are faster but may not fit perfectly.\nMonolith vs. Microservices: Monoliths are simpler to develop and deploy; microservices offer better scalability and team autonomy but add complexity.\n\n\n4.6.3 Evaluating Architectures\nHow do you know if an architecture is good? Consider these evaluation approaches:\nScenario Analysis: Walk through key scenarios (both typical and exceptional) to see how the architecture handles them.\nQuality Attribute Analysis: For each quality attribute, assess how the architecture supports it.\nRisk Assessment: Identify the biggest risks and how the architecture addresses them.\nArchitecture Trade-off Analysis Method (ATAM): A formal evaluation method that identifies sensitivity points, trade-offs, and risks.\nPrototype/Spike: Build a minimal implementation to validate technical feasibility.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#chapter-summary",
    "href": "chapters/04-software-architecture.html#chapter-summary",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.8 4.7 Chapter Summary",
    "text": "7.8 4.7 Chapter Summary\nSoftware architecture is the foundation on which successful systems are built. It defines the high-level structure, establishes patterns for communication and organization, and addresses the quality attributes that matter most to stakeholders.\nKey takeaways from this chapter:\n\nSoftware architecture encompasses the fundamental structures of a system and the decisions that are hard to change later. Good architecture enables systems to meet their quality requirements.\nArchitectural styles like layered architecture, MVC, microservices, and event-driven architecture provide templates for organizing systems. Each has strengths and trade-offs.\nThe SOLID principles guide class and module design: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.\nDesign patterns are reusable solutions to common problems. Creational patterns (Singleton, Factory, Builder) address object creation. Structural patterns (Adapter, Decorator, Facade) address object composition. Behavioral patterns (Strategy, Observer, Template Method) address object interaction.\nThe Software Architecture Document communicates architectural decisions to stakeholders. The 4+1 view model organizes multiple perspectives on the architecture.\nArchitecture Decision Records document individual decisions with their context, rationale, and consequences.\nArchitectural decisions involve trade-offs. Good architects make these trade-offs explicitly and document their reasoning.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#key-terms",
    "href": "chapters/04-software-architecture.html#key-terms",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.9 4.8 Key Terms",
    "text": "7.9 4.8 Key Terms\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nSoftware Architecture\nThe fundamental structures of a software system and the discipline of creating them\n\n\nArchitectural Style\nA named collection of architectural decisions common in a given context\n\n\nLayered Architecture\nArchitecture organizing system into horizontal layers\n\n\nMVC\nModel-View-Controller; separates data, presentation, and control logic\n\n\nMicroservices\nArchitecture of small, independent, communicating services\n\n\nEvent-Driven Architecture\nArchitecture based on production and consumption of events\n\n\nSOLID\nFive design principles for maintainable object-oriented software\n\n\nDesign Pattern\nA reusable solution to a common software design problem\n\n\nCreational Pattern\nPattern dealing with object creation\n\n\nStructural Pattern\nPattern dealing with object composition\n\n\nBehavioral Pattern\nPattern dealing with object interaction\n\n\nSAD\nSoftware Architecture Document\n\n\nADR\nArchitecture Decision Record\n\n\n4+1 View Model\nArchitectural documentation using four views plus scenarios",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#review-questions",
    "href": "chapters/04-software-architecture.html#review-questions",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.10 4.9 Review Questions",
    "text": "7.10 4.9 Review Questions\n\nWhat is software architecture, and why is it important? How does it differ from software design?\nCompare and contrast layered architecture and microservices architecture. What are the trade-offs, and when would you choose each?\nExplain the MVC pattern. How do Model, View, and Controller interact? What are the benefits of this separation?\nDescribe each of the SOLID principles and provide an example of how each improves software design.\nWhat is the Single Responsibility Principle? Identify a violation in code you’ve written or seen, and explain how you would refactor it.\nExplain the Dependency Inversion Principle. How does dependency injection help implement this principle?\nCompare the Factory Method and Builder patterns. When would you use each?\nHow does the Strategy pattern differ from a simple if-else chain? What are the benefits of using Strategy?\nDescribe the Observer pattern and give three real-world examples where it would be appropriate.\nWhat is the purpose of a Software Architecture Document? Who are its audiences, and what do they need from it?",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#hands-on-exercises",
    "href": "chapters/04-software-architecture.html#hands-on-exercises",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.11 4.10 Hands-On Exercises",
    "text": "7.11 4.10 Hands-On Exercises\n\nExercise 4.1: Identifying Architectural Styles\nFor each of the following systems, identify which architectural style(s) would be most appropriate and explain why:\n\nA personal blog website\nNetflix’s streaming service\nA banking system processing transactions\nA real-time multiplayer game\nAn IoT system monitoring factory equipment\n\n\n\nExercise 4.2: SOLID Refactoring\nThe following code violates SOLID principles. Identify which principles are violated and refactor the code:\npublic class Report {\n    private String content;\n    private String format;\n    \n    public void generateReport(Database db, String query) {\n        // Get data from database\n        ResultSet data = db.execute(query);\n        \n        // Format the report\n        if (format.equals(\"PDF\")) {\n            content = formatAsPDF(data);\n        } else if (format.equals(\"HTML\")) {\n            content = formatAsHTML(data);\n        } else if (format.equals(\"CSV\")) {\n            content = formatAsCSV(data);\n        }\n        \n        // Save to file\n        FileSystem.write(\"/reports/output\", content);\n        \n        // Send email notification\n        EmailClient.send(\"admin@company.com\", \"Report generated\", content);\n    }\n}\n\n\nExercise 4.3: Implementing Design Patterns\nImplement the following:\n\nFactory Pattern: Create a ShapeFactory that creates different shapes (Circle, Rectangle, Triangle) based on input parameters.\nDecorator Pattern: Create a Notification system where notifications can be decorated with additional delivery methods (SMS, Email, Slack) stacked together.\nObserver Pattern: Create a weather monitoring system where WeatherStation notifies multiple displays (CurrentConditions, Statistics, Forecast) when measurements change.\n\n\n\nExercise 4.4: Architecture Analysis\nFor your semester project:\n\nIdentify the primary quality attributes that matter most (e.g., performance, security, maintainability)\nChoose an architectural style and justify your choice\nIdentify at least two design patterns you will use and explain where and why\nDocument any trade-offs you’re making\n\n\n\nExercise 4.5: Software Architecture Document\nCreate a Software Architecture Document for your semester project, including:\n\nIntroduction and goals\nArchitectural style and rationale\nComponent/Package diagram showing major components\nAt least one sequence diagram for a key scenario\nDeployment view (how will the system be deployed?)\nAt least two Architecture Decision Records (ADRs) for major decisions\n\n\n\nExercise 4.6: Pattern Recognition\nIdentify which design pattern is being used in each of the following code snippets:\nSnippet A:\npublic class Logger {\n    private static Logger instance;\n    \n    private Logger() {}\n    \n    public static Logger getInstance() {\n        if (instance == null) {\n            instance = new Logger();\n        }\n        return instance;\n    }\n}\nSnippet B:\npublic interface SortStrategy {\n    void sort(int[] array);\n}\n\npublic class QuickSort implements SortStrategy { ... }\npublic class MergeSort implements SortStrategy { ... }\n\npublic class Sorter {\n    private SortStrategy strategy;\n    \n    public void setStrategy(SortStrategy strategy) {\n        this.strategy = strategy;\n    }\n    \n    public void performSort(int[] array) {\n        strategy.sort(array);\n    }\n}\nSnippet C:\npublic interface Beverage {\n    double cost();\n}\n\npublic class Espresso implements Beverage {\n    public double cost() { return 1.99; }\n}\n\npublic class MilkDecorator implements Beverage {\n    private Beverage beverage;\n    \n    public MilkDecorator(Beverage beverage) {\n        this.beverage = beverage;\n    }\n    \n    public double cost() {\n        return beverage.cost() + 0.50;\n    }\n}",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#further-reading",
    "href": "chapters/04-software-architecture.html#further-reading",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.12 4.11 Further Reading",
    "text": "7.12 4.11 Further Reading\nBooks:\n\nMartin, R. C. (2017). Clean Architecture: A Craftsman’s Guide to Software Structure and Design. Prentice Hall.\nGamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.\nRichards, M. & Ford, N. (2020). Fundamentals of Software Architecture. O’Reilly Media.\nNewman, S. (2021). Building Microservices (2nd Edition). O’Reilly Media.\nBass, L., Clements, P., & Kazman, R. (2012). Software Architecture in Practice (3rd Edition). Addison-Wesley.\n\nOnline Resources:\n\nRefactoring Guru - Design Patterns: https://refactoring.guru/design-patterns\nMartin Fowler’s Architecture Guide: https://martinfowler.com/architecture/\nMicrosoft Architecture Guides: https://docs.microsoft.com/en-us/azure/architecture/\nADR GitHub Organization: https://adr.github.io/",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/04-software-architecture.html#references",
    "href": "chapters/04-software-architecture.html#references",
    "title": "7  Chapter 4: Software Architecture and Design Patterns",
    "section": "7.13 References",
    "text": "7.13 References\nBass, L., Clements, P., & Kazman, R. (2012). Software Architecture in Practice (3rd Edition). Addison-Wesley.\nBuschmann, F., Meunier, R., Rohnert, H., Sommerlad, P., & Stal, M. (1996). Pattern-Oriented Software Architecture Volume 1: A System of Patterns. Wiley.\nFowler, M. (2002). Patterns of Enterprise Application Architecture. Addison-Wesley.\nGamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.\nKruchten, P. (1995). The 4+1 View Model of Architecture. IEEE Software, 12(6), 42-50.\nMartin, R. C. (2000). Design Principles and Design Patterns. Retrieved from http://www.objectmentor.com/\nMartin, R. C. (2017). Clean Architecture: A Craftsman’s Guide to Software Structure and Design. Prentice Hall.\nNewman, S. (2021). Building Microservices (2nd Edition). O’Reilly Media.\nRichards, M., & Ford, N. (2020). Fundamentals of Software Architecture: An Engineering Approach. O’Reilly Media.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 4: Software Architecture and Design Patterns</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html",
    "href": "chapters/05-ui-ux.html",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "",
    "text": "8.1 Learning Objectives\nBy the end of this chapter, you will be able to:",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#learning-objectives",
    "href": "chapters/05-ui-ux.html#learning-objectives",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "",
    "text": "Explain the principles of human-centered design and their importance in software development\nDistinguish between User Interface (UI) and User Experience (UX) design\nApply UX heuristics to evaluate and improve interface designs\nCreate wireframes and prototypes at varying levels of fidelity\nDesign responsive interfaces that work across different devices and screen sizes\nImplement accessibility best practices to create inclusive software\nDevelop a UI style guide for consistent design across an application\nUse modern prototyping tools to communicate design ideas",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#understanding-ui-and-ux",
    "href": "chapters/05-ui-ux.html#understanding-ui-and-ux",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.2 5.1 Understanding UI and UX",
    "text": "8.2 5.1 Understanding UI and UX\nYou’ve probably used software that felt frustrating—confusing menus, buttons that didn’t look clickable, forms that lost your data, error messages that made no sense. You’ve also used software that felt effortless—intuitive navigation, clear feedback, tasks accomplished with minimal friction. The difference isn’t accidental. It’s the result of thoughtful design.\nUser Experience (UX) and User Interface (UI) design are the disciplines that create this difference. While often mentioned together, they address different aspects of how users interact with software.\n\n5.1.1 What Is User Experience (UX)?\nUser Experience encompasses all aspects of a user’s interaction with a product, service, or company. It’s about how the product feels to use—whether it’s satisfying, frustrating, efficient, or confusing.\nUX design asks questions like:\n\nWhat problem is the user trying to solve?\nWhat steps must users take to accomplish their goals?\nHow do users feel during and after using the product?\nWhat obstacles prevent users from succeeding?\nHow can we make the experience more efficient and enjoyable?\n\nUX extends beyond the screen. It includes:\n\nThe user’s first impression when discovering the product\nThe onboarding experience for new users\nThe day-to-day experience of regular use\nError handling and recovery\nCustomer support interactions\nThe experience of leaving or canceling\n\nUX Design Activities:\n\nUser research and interviews\nCreating user personas\nJourney mapping\nInformation architecture\nInteraction design\nUsability testing\nAnalyzing user behavior data\n\n\n\n5.1.2 What Is User Interface (UI)?\nUser Interface design focuses on the visual and interactive elements users directly interact with—buttons, icons, typography, colors, layouts, animations, and more.\nUI design asks questions like:\n\nWhat should users see on this screen?\nHow should interactive elements look and behave?\nWhat visual hierarchy guides users’ attention?\nHow do colors, fonts, and spacing create the right mood?\nHow does the interface communicate its state?\n\nUI design is about making the interface:\n\nVisually appealing: Aesthetically pleasing and aligned with brand identity\nClear: Users understand what they’re seeing\nConsistent: Similar elements look and behave similarly\nResponsive: Interface provides feedback for user actions\n\nUI Design Activities:\n\nVisual design (colors, typography, imagery)\nLayout and composition\nIcon and button design\nMotion and animation design\nCreating design systems and style guides\nResponsive design for multiple screen sizes\n\n\n\n5.1.3 The Relationship Between UX and UI\nUX and UI are deeply interconnected:\n┌─────────────────────────────────────────────────────────────────────────┐\n│                         User Experience (UX)                            │\n│                                                                         │\n│  ┌───────────────────────────────────────────────────────────────────┐  │\n│  │                      User Interface (UI)                          │  │\n│  │                                                                   │  │\n│  │   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │  │\n│  │   │   Visual    │  │ Interactive │  │   Layout    │              │  │\n│  │   │   Design    │  │  Elements   │  │             │              │  │\n│  │   └─────────────┘  └─────────────┘  └─────────────┘              │  │\n│  │                                                                   │  │\n│  └───────────────────────────────────────────────────────────────────┘  │\n│                                                                         │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐    │\n│  │   User      │  │ Information │  │ Interaction │  │  Usability  │    │\n│  │  Research   │  │Architecture │  │   Design    │  │   Testing   │    │\n│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘    │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nA useful analogy: If your product were a house, UX would be the architecture—the floor plan, the flow between rooms, how living in it feels. UI would be the interior design—the paint colors, the furniture choices, the light fixtures.\nYou can have:\n\nGood UX with poor UI: The product works well but looks outdated or unappealing\nGood UI with poor UX: The product looks beautiful but is frustrating to use\nGood UX and UI: The product is both effective and delightful (the goal!)\n\n\n\n5.1.4 Why Software Engineers Need Design Skills\nYou might wonder why a software engineering course covers design. Can’t designers handle this? In practice:\nMany teams don’t have dedicated designers. Startups, small companies, and internal tools often rely on developers to make design decisions.\nDesign affects technical decisions. How you structure your code depends on what the interface needs to do. Understanding design helps you build better systems.\nBetter communication with designers. Even with dedicated designers, understanding their work improves collaboration.\nDesign thinking improves problem-solving. The empathy and iteration central to design make you a better engineer overall.\nUsers don’t separate code from design. Users experience the whole product. Poor design undermines excellent code.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#human-centered-design",
    "href": "chapters/05-ui-ux.html#human-centered-design",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.3 5.2 Human-Centered Design",
    "text": "8.3 5.2 Human-Centered Design\nHuman-Centered Design (HCD) is an approach that grounds the design process in information about the people who will use the product. Rather than designing based on assumptions or technical constraints, HCD starts with understanding users’ needs, behaviors, and contexts.\n\n5.2.1 Principles of Human-Centered Design\n1. Focus on People\nDesign begins with understanding users—not technology, not business requirements, but the humans who will interact with the system.\nThis means:\n\nObserving users in their natural environment\nUnderstanding their goals, frustrations, and contexts\nRecognizing that users are experts in their own needs\nDesigning for real people, not idealized users\n\n2. Find the Right Problem\nMany failed products solve the wrong problem beautifully. HCD invests in problem definition before jumping to solutions.\n\n“If I had an hour to solve a problem, I’d spend 55 minutes thinking about the problem and 5 minutes thinking about solutions.” — attributed to Albert Einstein\n\n3. Think Systemically\nProblems exist within systems. A solution that fixes one issue might create others. HCD considers the broader context and ripple effects of design decisions.\n4. Iterate Relentlessly\nPerfect solutions rarely emerge fully formed. HCD embraces iteration—designing, testing, learning, and refining in cycles.\n         ┌──────────────┐\n         │   Empathize  │\n         │ (Understand  │\n         │    users)    │\n         └──────┬───────┘\n                │\n                ▼\n         ┌──────────────┐\n         │    Define    │\n         │  (Frame the  │\n         │   problem)   │\n         └──────┬───────┘\n                │\n                ▼\n         ┌──────────────┐\n         │    Ideate    │\n         │  (Generate   │\n         │   ideas)     │\n         └──────┬───────┘\n                │\n                ▼\n         ┌──────────────┐\n         │  Prototype   │\n         │   (Build to  │\n         │    learn)    │\n         └──────┬───────┘\n                │\n                ▼\n         ┌──────────────┐\n         │    Test      │◄────────────────┐\n         │  (Get user   │                 │\n         │  feedback)   │                 │\n         └──────┬───────┘                 │\n                │                         │\n                └─────────────────────────┘\n                      (Iterate)\n5. Prototype to Learn\nPrototypes aren’t mini-products; they’re thinking tools. Build prototypes to answer questions and test assumptions, not to show off solutions.\n\n\n5.2.2 Understanding Users\nBefore designing, you need to understand who you’re designing for. Several techniques help build this understanding:\nUser Research Methods:\n\n\n\n\n\n\n\n\nMethod\nDescription\nWhen to Use\n\n\n\n\nInterviews\nOne-on-one conversations\nDeep understanding of needs and motivations\n\n\nSurveys\nQuestionnaires to many users\nQuantitative data, validating hypotheses\n\n\nObservation\nWatching users in context\nUnderstanding actual behavior\n\n\nUsability Testing\nUsers attempt tasks\nEvaluating existing designs\n\n\nAnalytics\nBehavioral data from usage\nUnderstanding patterns at scale\n\n\nCard Sorting\nUsers organize information\nDesigning information architecture\n\n\n\nUser Personas\nA persona is a fictional character representing a user type. Personas help teams maintain empathy for users throughout the project.\nExample Persona:\n┌─────────────────────────────────────────────────────────────────────────┐\n│                                                                         │\n│  PERSONA: Sarah Chen                                                    │\n│  ═══════════════════                                                    │\n│                                                                         │\n│  Demographics:                                                          │\n│  • 34 years old                                                         │\n│  • Marketing Manager at mid-size company                                │\n│  • Lives in suburban Chicago                                            │\n│  • Uses iPhone, MacBook, and iPad                                       │\n│                                                                         │\n│  Goals:                                                                 │\n│  • Coordinate marketing campaigns across her team of 6                  │\n│  • Track project progress without micromanaging                         │\n│  • Meet deadlines reliably                                              │\n│  • Reduce time spent in status meetings                                 │\n│                                                                         │\n│  Frustrations:                                                          │\n│  • Information scattered across email, Slack, and spreadsheets          │\n│  • Surprises about project delays discovered too late                   │\n│  • Team members working on outdated versions of documents               │\n│  • Too many tools that don't integrate well                             │\n│                                                                         │\n│  Tech Comfort: Moderate                                                 │\n│  • Comfortable with common apps (Office, Google Workspace)              │\n│  • Prefers intuitive tools over powerful-but-complex ones               │\n│  • Willing to learn new tools if the benefit is clear                   │\n│                                                                         │\n│  Quote: \"I just want to know what's happening without having to ask.\"   │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nUser Journey Maps\nA journey map visualizes the user’s experience over time, including their actions, thoughts, emotions, and pain points.\nUSER JOURNEY: New Customer Making First Purchase\n═══════════════════════════════════════════════\n\nStage:     DISCOVER    →    EVALUATE    →    PURCHASE    →    RECEIVE    →    USE\n\nActions:   • Sees ad    • Browses       • Creates       • Tracks       • Opens\n           • Visits       products        account        shipping       package\n             site       • Reads         • Enters        • Waits        • Uses\n           • Browses      reviews         payment                        product\n                        • Compares\n\nThinking:  \"This looks  \"Will this     \"Is this       \"When will    \"Is this what\n           interesting\"  work for me?\"   secure?\"       it arrive?\"   I expected?\"\n\nFeeling:   😊 Curious   🤔 Uncertain   😰 Anxious     😐 Impatient  😊 or 😞\n\nPain       • Slow       • Not enough   • Long         • No          • Instructions\nPoints:      loading      reviews        checkout       tracking       unclear\n           • Cluttered  • Hard to      • Account      • Delayed     • Missing\n             homepage     compare        required       delivery       pieces\n\nOpportu-   • Fast,      • Rich         • Guest        • Real-time   • Quick\nnities:      clean        product        checkout       updates        start\n             first        info           option       • Proactive      guide\n             impression • Easy           available      communication\n                          comparison\n\n\n5.2.3 Defining the Problem\nGood problem definition is half the solution. A well-framed problem focuses the team and prevents wasted effort on the wrong issues.\nProblem Statement Format:\n\n[User] needs a way to [accomplish goal] because [insight from research], but [current obstacle].\n\nExample:\n\nMarketing managers need a way to track their team’s project progress in real-time because they’re accountable for deadlines they can’t directly control, but current tools require manually asking for updates, which is time-consuming and often provides outdated information.\n\n“How Might We” Questions:\nTransform problem statements into opportunity questions:\n\nHow might we help managers see project status without asking?\nHow might we surface delays before they become crises?\nHow might we reduce the friction of status updates for team members?\n\nThese questions open possibilities without constraining solutions.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#ux-design-heuristics",
    "href": "chapters/05-ui-ux.html#ux-design-heuristics",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.4 5.3 UX Design Heuristics",
    "text": "8.4 5.3 UX Design Heuristics\nHeuristics are rules of thumb—general principles that guide design decisions without prescribing specific solutions. Jakob Nielsen’s 10 Usability Heuristics, developed in the 1990s, remain the most influential framework for evaluating interface design.\n\n5.3.1 Nielsen’s 10 Usability Heuristics\n1. Visibility of System Status\nThe system should always keep users informed about what is going on through appropriate feedback within a reasonable time.\nGood Examples:\n\nProgress bars during file uploads\n“Saving…” indicator in document editors\nReal-time character count in text fields with limits\nLoading spinners during data fetches\n\nBad Examples:\n\nSubmitting a form with no feedback\nProcesses running with no indication of progress\nButtons that don’t respond to clicks\n\nImplementation:\n┌─────────────────────────────────────────┐\n│  Uploading document...                  │\n│                                         │\n│  ████████████████░░░░░░░░  67%         │\n│                                         │\n│  2 of 3 files uploaded                  │\n│  Estimated time remaining: 12 seconds   │\n│                                         │\n│  [Cancel]                               │\n└─────────────────────────────────────────┘\n2. Match Between System and the Real World\nThe system should speak the user’s language, using words, phrases, and concepts familiar to the user rather than system-oriented terms. Follow real-world conventions, making information appear in a natural and logical order.\nGood Examples:\n\nShopping cart icon for e-commerce\n“Trash” or “Recycle Bin” for deleted items\nCalendar interfaces that look like calendars\nUsing “Save” instead of “Persist to Database”\n\nBad Examples:\n\nTechnical jargon in user interfaces (“SQLException occurred”)\nArbitrary icons without clear meaning\nNavigation that doesn’t match user mental models\n\nTip: Use the same terminology users use when describing their tasks. If users say “customers,” don’t call them “accounts” in the interface.\n3. User Control and Freedom\nUsers often choose system functions by mistake and need a clearly marked “emergency exit” to leave the unwanted state without going through an extended process.\nGood Examples:\n\nUndo/Redo functionality (Ctrl+Z, Ctrl+Y)\n“Cancel” buttons on forms and dialogs\n“Go back” option in wizards\nGmail’s “Undo send” feature\nClear navigation to return to previous states\n\nBad Examples:\n\nNo way to cancel a long-running operation\nDestructive actions without confirmation\nWizards with no back button\nModal dialogs without close buttons\n\n4. Consistency and Standards\nUsers should not have to wonder whether different words, situations, or actions mean the same thing. Follow platform conventions.\nTypes of Consistency:\n\nInternal consistency: The same action works the same way throughout your application\nExternal consistency: Your application follows conventions users know from other applications\nVisual consistency: Similar elements look similar\n\nGood Examples:\n\nBlue underlined text for links\n“X” in top corner to close dialogs\nCtrl+S to save (on Windows)\nSwipe to delete (on mobile)\n\nBad Examples:\n\nDifferent button styles for the same type of action\nNon-standard icons for common functions\nInconsistent placement of navigation elements\n\n5. Error Prevention\nEven better than good error messages is a careful design that prevents problems from occurring in the first place.\nTypes of Error Prevention:\n\nConstraints: Prevent invalid input (date pickers, dropdowns)\nSuggestions: Autocomplete reduces typos\nDefaults: Sensible defaults reduce decisions\nConfirmations: Confirm destructive actions\n\nGood Examples:\n┌─────────────────────────────────────────┐\n│  Delete project \"Annual Report 2024\"?  │\n│                                         │\n│  This will permanently delete:          │\n│  • 47 tasks                             │\n│  • 12 documents                         │\n│  • 156 comments                         │\n│                                         │\n│  This action cannot be undone.          │\n│                                         │\n│  Type \"Annual Report 2024\" to confirm:  │\n│  ┌─────────────────────────────────────┐│\n│  │                                     ││\n│  └─────────────────────────────────────┘│\n│                                         │\n│        [Cancel]    [Delete Project]     │\n└─────────────────────────────────────────┘\nBad Examples:\n\nFree-form date entry instead of date pickers\nDelete buttons without confirmation\nAllowing form submission with known invalid data\n\n6. Recognition Rather Than Recall\nMinimize user memory load by making objects, actions, and options visible. Users should not have to remember information from one part of the interface to another.\nGood Examples:\n\nDropdown menus showing all options\nRecent files and search history\nAutocomplete showing previous entries\nIcons with labels (not icons alone)\nShowing examples of expected input formats\n\nBad Examples:\n\nRequiring users to remember codes or IDs\nIcons without labels\nEmpty forms without hints about expected format\nRequiring memorization of keyboard shortcuts\n\n7. Flexibility and Efficiency of Use\nAccelerators—invisible to novice users—may speed up interaction for expert users. Allow users to tailor frequent actions.\nGood Examples:\n\nKeyboard shortcuts for common actions\nCustomizable toolbars and dashboards\n“Recent” and “Favorites” lists\nBulk operations for power users\nTemplates for common tasks\n\nImplementation Example:\n┌─────────────────────────────────────────────────────────────┐\n│  File    Edit    View    Help                               │\n├─────────────────────────────────────────────────────────────┤\n│  New           Ctrl+N                                       │\n│  Open          Ctrl+O                                       │\n│  ──────────────────────                                     │\n│  Save          Ctrl+S                                       │\n│  Save As...    Ctrl+Shift+S                                 │\n│  ──────────────────────                                     │\n│  Recent Files  ►  │ report-final.docx                       │\n│                    │ presentation-v2.pptx                   │\n│                    │ budget-2024.xlsx                       │\n└─────────────────────────────────────────────────────────────┘\n8. Aesthetic and Minimalist Design\nInterfaces should not contain information that is irrelevant or rarely needed. Every extra unit of information competes with relevant information and diminishes their relative visibility.\nPrinciples:\n\nRemove unnecessary elements\nPrioritize important information visually\nUse progressive disclosure (show more on demand)\nWhite space is not wasted space\n\nGood Examples:\n\nGoogle’s search homepage (minimal)\nProgressive disclosure in settings (basic → advanced)\nContextual toolbars that show relevant tools\n\nBad Examples:\n\nCluttered dashboards showing everything at once\nDense forms with rarely-used fields always visible\nExcessive decorative elements\n\n9. Help Users Recognize, Diagnose, and Recover from Errors\nError messages should be expressed in plain language (no codes), precisely indicate the problem, and constructively suggest a solution.\nGood Error Message:\n┌─────────────────────────────────────────┐\n│  ⚠️  Couldn't save your changes         │\n│                                         │\n│  Your internet connection was lost.     │\n│  Your changes have been saved locally   │\n│  and will sync when you're back online. │\n│                                         │\n│  [Retry Now]    [Work Offline]          │\n└─────────────────────────────────────────┘\nBad Error Messages:\n\n“Error 500: Internal Server Error”\n“An error occurred”\n“Invalid input”\n“Operation failed. Contact administrator.”\n\nError Message Checklist:\n\nSays what went wrong (specifically)\nUses plain language (no technical jargon)\nSuggests how to fix it\nOffers an action the user can take\n\n10. Help and Documentation\nEven though it’s better if the system can be used without documentation, it may be necessary to provide help and documentation. Such information should be easy to search, focused on the user’s task, list concrete steps, and not be too large.\nGood Examples:\n\nContextual help (? icons next to complex fields)\nSearchable help documentation\nInteractive tutorials and onboarding\nTooltips explaining interface elements\n\nHelp Types:\n┌─────────────────────────────────────────────────────────────┐\n│                                                             │\n│  API Rate Limit  [?]                                        │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │  1000                                                 │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n│  ┌───────────────────────────────────────────────────────┐  │\n│  │ ℹ️  Maximum API requests per hour per user.           │  │\n│  │    Higher limits may affect server performance.       │  │\n│  │    Learn more about rate limiting →                   │  │\n│  └───────────────────────────────────────────────────────┘  │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n\n\n5.3.2 Applying Heuristics: Heuristic Evaluation\nA heuristic evaluation is a usability inspection method where evaluators examine an interface and judge its compliance with recognized usability principles.\nHow to Conduct a Heuristic Evaluation:\n\nPrepare: Gather the interface (or prototype) and the heuristic checklist\nEvaluate individually: Each evaluator reviews the interface alone, noting violations\nRate severity: Assign severity ratings to each issue\n\nSeverity Rating Scale:\n\n0 = Not a usability problem\n1 = Cosmetic problem; fix if time permits\n2 = Minor problem; low priority\n3 = Major problem; important to fix\n4 = Catastrophic; must fix before release\n\n\nAggregate: Combine findings from all evaluators\nPrioritize: Address issues by severity and frequency\n\nHeuristic Evaluation Template:\n\n\n\n\n\n\n\n\n\n\n#\nIssue Description\nHeuristic Violated\nSeverity\nRecommendation\n\n\n\n\n1\nNo feedback after form submission\n#1 Visibility of System Status\n3\nAdd success/error message\n\n\n2\nTechnical error messages shown to users\n#9 Error Recovery\n3\nTranslate to plain language\n\n\n3\nDelete button has no confirmation\n#5 Error Prevention\n4\nAdd confirmation dialog\n\n\n4\nIcons without labels\n#6 Recognition vs Recall\n2\nAdd tooltips or labels",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#wireframing-and-prototyping",
    "href": "chapters/05-ui-ux.html#wireframing-and-prototyping",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.5 5.4 Wireframing and Prototyping",
    "text": "8.5 5.4 Wireframing and Prototyping\nDesign is an iterative process, and prototypes are the tools that enable iteration. They let you explore ideas, communicate concepts, and test assumptions—all before investing in full implementation.\n\n5.4.1 The Prototyping Spectrum\nPrototypes exist on a spectrum from low-fidelity sketches to high-fidelity interactive simulations:\nLow Fidelity ◄─────────────────────────────────────────────► High Fidelity\n\n┌──────────────┬──────────────┬──────────────┬──────────────┐\n│   Sketches   │  Wireframes  │   Mockups    │ Prototypes   │\n├──────────────┼──────────────┼──────────────┼──────────────┤\n│ Paper/       │ Digital,     │ Visual       │ Interactive, │\n│ whiteboard   │ grayscale,   │ design with  │ clickable,   │\n│ rough ideas  │ layout focus │ colors/fonts │ simulates    │\n│              │              │              │ behavior     │\n├──────────────┼──────────────┼──────────────┼──────────────┤\n│ Minutes      │ Hours        │ Hours-Days   │ Days-Weeks   │\n├──────────────┼──────────────┼──────────────┼──────────────┤\n│ Explore      │ Define       │ Refine       │ Validate     │\n│ concepts     │ structure    │ aesthetics   │ interactions │\n└──────────────┴──────────────┴──────────────┴──────────────┘\nLow-fidelity prototypes are quick and cheap. They’re good for exploring many ideas and getting early feedback without emotional attachment.\nHigh-fidelity prototypes look and feel like real products. They’re better for testing detailed interactions and getting reactions to visual design.\n\n\n5.4.2 Sketching\nSketching is the fastest way to explore ideas. Don’t worry about artistic ability—rough sketches communicate ideas effectively.\nWhy Sketch?\n\nExtremely fast (seconds to minutes)\nNo software needed\nEasy to iterate—just flip to a new page\nEncourages divergent thinking\nNo emotional attachment to rough sketches\n\nSketching Tips:\n\nUse pen (not pencil) to avoid erasing—just draw again\nDraw multiple variations quickly\nAnnotate with notes explaining behavior\nUse standard UI conventions (boxes for buttons, lines for text)\nInclude arrows and notes for interactions\n\nBasic UI Sketching Vocabulary:\n┌─────────────────────────────────────────────────────────────┐\n│                                                             │\n│  ┌─────────────┐    Button                                  │\n│  │   Label     │                                            │\n│  └─────────────┘                                            │\n│                                                             │\n│  ┌─────────────────────────────────────┐                    │\n│  │                                     │    Text input      │\n│  └─────────────────────────────────────┘                    │\n│                                                             │\n│  ────────────────────────────────────────   Line of text    │\n│  ────────────────────────────────────                       │\n│  ──────────────────────────                                 │\n│                                                             │\n│  ┌─────────────────────────────────────┐                    │\n│  │  ☰  Header / Navigation             │    Header bar      │\n│  └─────────────────────────────────────┘                    │\n│                                                             │\n│  ┌─────┐                                                    │\n│  │  ×  │    Image placeholder                               │\n│  └─────┘                                                    │\n│                                                             │\n│  [○] Option A                           Radio button        │\n│  [●] Option B (selected)                                    │\n│                                                             │\n│  [✓] Checkbox (checked)                 Checkbox            │\n│  [ ] Checkbox (unchecked)                                   │\n│                                                             │\n│  ┌─────────────────────────────▼┐       Dropdown            │\n│  │  Select an option...         │                           │\n│  └──────────────────────────────┘                           │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n\n\n5.4.3 Wireframes\nWireframes are low-fidelity representations of a user interface that show structure, layout, and content hierarchy without visual design details.\nWireframe Characteristics:\n\nGrayscale (no colors)\nPlaceholder content (Lorem ipsum, gray boxes for images)\nFocus on layout and information hierarchy\nBasic UI elements without styling\nAnnotations explaining functionality\n\nPurpose of Wireframes:\n\nDefine content and structure\nEstablish layout and spacing\nPlan navigation and user flows\nCommunicate functionality to stakeholders\nServe as blueprint for visual design\n\nWireframe Example - Dashboard:\n┌─────────────────────────────────────────────────────────────────────────┐\n│  ┌──────┐                                            [?] [🔔] [👤 User ▼]│\n│  │ Logo │   Dashboard    Projects    Team    Settings                   │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  Welcome back, Sarah!                                    [+ New Project]│\n│                                                                         │\n│  ┌────────────────────┐ ┌────────────────────┐ ┌────────────────────┐  │\n│  │   Active Projects  │ │    Tasks Due       │ │   Team Activity    │  │\n│  │                    │ │                    │ │                    │  │\n│  │       12           │ │        5           │ │        23          │  │\n│  │                    │ │      Today         │ │    Updates         │  │\n│  └────────────────────┘ └────────────────────┘ └────────────────────┘  │\n│                                                                         │\n│  Recent Projects                                          [View All →] │\n│  ┌─────────────────────────────────────────────────────────────────┐   │\n│  │  [×] Website Redesign          Progress: ████████░░░ 75%       │   │\n│  │      Due: Oct 15    Team: 4    Status: On Track                │   │\n│  ├─────────────────────────────────────────────────────────────────┤   │\n│  │  [×] Mobile App v2             Progress: ████░░░░░░░ 40%       │   │\n│  │      Due: Nov 30    Team: 6    Status: At Risk                 │   │\n│  ├─────────────────────────────────────────────────────────────────┤   │\n│  │  [×] Q4 Marketing Campaign     Progress: ██░░░░░░░░░ 20%       │   │\n│  │      Due: Dec 1     Team: 3    Status: On Track                │   │\n│  └─────────────────────────────────────────────────────────────────┘   │\n│                                                                         │\n│  My Tasks                                                 [View All →] │\n│  ┌─────────────────────────────────────────────────────────────────┐   │\n│  │  [ ] Review design mockups              Due: Today              │   │\n│  │  [ ] Approve budget proposal            Due: Today              │   │\n│  │  [ ] Team standup meeting               Due: Tomorrow           │   │\n│  │  [ ] Review Q3 report                   Due: Oct 10             │   │\n│  └─────────────────────────────────────────────────────────────────┘   │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nWireframe Example - Mobile Login:\n┌─────────────────────────┐\n│ ◀ Back                  │\n├─────────────────────────┤\n│                         │\n│                         │\n│      ┌─────────┐        │\n│      │  Logo   │        │\n│      └─────────┘        │\n│                         │\n│    Welcome Back         │\n│  Sign in to continue    │\n│                         │\n│  Email                  │\n│  ┌─────────────────────┐│\n│  │ sarah@example.com   ││\n│  └─────────────────────┘│\n│                         │\n│  Password               │\n│  ┌─────────────────────┐│\n│  │ ••••••••••     [👁] ││\n│  └─────────────────────┘│\n│                         │\n│  [ ] Remember me        │\n│                         │\n│  ┌─────────────────────┐│\n│  │      Sign In        ││\n│  └─────────────────────┘│\n│                         │\n│    Forgot password?     │\n│                         │\n│  ─────────────────────  │\n│                         │\n│  Don't have an account? │\n│       Sign Up           │\n│                         │\n└─────────────────────────┘\n\n\n5.4.4 Interactive Prototypes\nInteractive prototypes add behavior to wireframes or mockups. Users can click, tap, and navigate as if using a real application.\nLevels of Interactivity:\nClick-through prototypes: Pages linked together. Clicking a button navigates to another page. Good for testing navigation and flow.\nInteractive prototypes: Include form interactions, animations, conditional logic. Good for testing detailed interactions.\nFunctional prototypes: Working code (often simplified). Real data, real logic, limited scope. Good for technical validation.\nWhat to Test with Prototypes:\n\nNavigation: Can users find their way around?\nComprehension: Do users understand what they’re seeing?\nTask completion: Can users accomplish specific tasks?\nExpectations: Does the design match user mental models?\nDesirability: Do users like the design?\n\n\n\n5.4.5 Prototyping Tools\nModern tools make creating prototypes faster than ever:\nLow-Fidelity / Wireframing:\n\nBalsamiq: Intentionally sketch-like wireframes\nWhimsical: Flowcharts and wireframes\nExcalidraw: Hand-drawn style diagrams (free)\nPaper and pen: Still valid!\n\nHigh-Fidelity / Design:\n\nFigma: Industry standard, collaborative, free tier (highly recommended)\nSketch: Mac-only, popular with designers\nAdobe XD: Part of Adobe ecosystem\nFramer: Design with code-like interactions\n\nCode-Based Prototyping:\n\nHTML/CSS: For web interfaces\nReact with Storybook: Component-based prototyping\nSwiftUI Previews: iOS prototyping\n\nChoosing a Tool:\n\n\n\nNeed\nRecommended Tool\n\n\n\n\nQuick exploration\nPaper, Whimsical\n\n\nShareable wireframes\nFigma, Balsamiq\n\n\nHigh-fidelity mockups\nFigma, Sketch\n\n\nComplex interactions\nFigma, Framer\n\n\nTeam collaboration\nFigma\n\n\nDeveloper handoff\nFigma\n\n\n\nFor this course, Figma is recommended because it’s free, web-based, collaborative, and industry-standard.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#visual-design-fundamentals",
    "href": "chapters/05-ui-ux.html#visual-design-fundamentals",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.6 5.5 Visual Design Fundamentals",
    "text": "8.6 5.5 Visual Design Fundamentals\nWhile this isn’t a graphic design course, understanding visual design principles helps you create more effective interfaces—and communicate better with designers.\n\n5.5.1 Visual Hierarchy\nVisual hierarchy guides users’ attention to the most important elements first. It’s achieved through size, color, contrast, position, and spacing.\nHierarchy Techniques:\nSize: Larger elements attract attention first\n┌─────────────────────────────────────┐\n│                                     │\n│   BIG HEADLINE                      │  ← Eye goes here first\n│   Smaller subheading                │  ← Then here\n│   Body text that provides more      │  ← Then here\n│   detail about the content...       │\n│                                     │\n└─────────────────────────────────────┘\nColor and Contrast: High-contrast elements stand out\n┌─────────────────────────────────────┐\n│                                     │\n│   ┌─────────────────────────────┐   │\n│   │      Primary Action         │   │  ← High contrast button\n│   └─────────────────────────────┘   │\n│                                     │\n│   ┌─────────────────────────────┐   │\n│   │     Secondary Action        │   │  ← Lower contrast\n│   └─────────────────────────────┘   │\n│                                     │\n│          Tertiary link              │  ← Lowest emphasis\n│                                     │\n└─────────────────────────────────────┘\nPosition: Top-left (in LTR languages) gets attention first; center draws focus\nWhite Space: Isolated elements with surrounding space appear more important\n\n\n5.5.2 Typography\nTypography significantly impacts readability and tone.\nFont Categories:\n\nSerif (Times, Georgia): Traditional, formal, good for body text in print\nSans-serif (Arial, Helvetica, Inter): Modern, clean, good for screens\nMonospace (Courier, Fira Code): Technical, code, data\nDisplay (decorative fonts): Headlines only, use sparingly\n\nTypography Best Practices:\n\nLimit font families: 1-2 per project\nEstablish hierarchy: Different sizes for headings, subheadings, body\nLine length: 50-75 characters per line for readability\nLine height: 1.4-1.6 for body text\nContrast: Ensure sufficient contrast against background\n\nType Scale Example:\nH1: 32px / Bold      \"Page Title\"\nH2: 24px / Semibold  \"Section Heading\"\nH3: 20px / Semibold  \"Subsection\"\nBody: 16px / Regular \"Paragraph text that users will read...\"\nSmall: 14px / Regular \"Helper text, captions\"\nTiny: 12px / Regular \"Legal text, timestamps\"\n\n\n5.5.3 Color\nColor creates mood, guides attention, and communicates meaning.\nColor Purposes in UI:\n\nPrimary color: Brand identity, primary actions\nSecondary color: Supporting elements\nNeutral colors: Text, backgrounds, borders\nSemantic colors: Success (green), warning (yellow), error (red), info (blue)\n\nColor Accessibility:\n\nDon’t rely on color alone to convey meaning\nEnsure sufficient contrast ratios (WCAG guidelines)\nTest with color blindness simulators\n\nContrast Ratios (WCAG 2.1):\n\nNormal text: 4.5:1 minimum\nLarge text (18px+ or 14px+ bold): 3:1 minimum\nUI components: 3:1 minimum\n\nSimple Color Palette:\n┌─────────────────────────────────────────────────────────────┐\n│  PRIMARY                                                    │\n│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐              │\n│  │  50  │ │ 100  │ │ 500  │ │ 700  │ │ 900  │              │\n│  │(light)│ │      │ │(main)│ │      │ │(dark)│              │\n│  └──────┘ └──────┘ └──────┘ └──────┘ └──────┘              │\n│                                                             │\n│  NEUTRAL                                                    │\n│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐     │\n│  │White │ │Gray  │ │Gray  │ │Gray  │ │Gray  │ │Black │     │\n│  │      │ │ 100  │ │ 300  │ │ 500  │ │ 700  │ │      │     │\n│  └──────┘ └──────┘ └──────┘ └──────┘ └──────┘ └──────┘     │\n│                                                             │\n│  SEMANTIC                                                   │\n│  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐                       │\n│  │Success│ │Warning│ │Error │ │ Info │                       │\n│  │(green)│ │(yellow)│ │(red) │ │(blue)│                       │\n│  └──────┘ └──────┘ └──────┘ └──────┘                       │\n│                                                             │\n└─────────────────────────────────────────────────────────────┘\n\n\n5.5.4 Layout and Spacing\nConsistent spacing creates visual rhythm and makes interfaces feel polished.\nSpacing Systems:\nUse a consistent scale (e.g., multiples of 4px or 8px):\n\n4px, 8px, 12px, 16px, 24px, 32px, 48px, 64px\n\nGrid Systems:\nGrids provide structure for layout:\n\nColumn grids: Common for web (12-column is standard)\nModular grids: Rows and columns for complex layouts\nBaseline grids: Align text across columns\n\nLayout Principles:\nAlignment: Elements should align with each other\nGood:                          Bad:\n┌──────────────────────┐      ┌──────────────────────┐\n│ Label                │      │ Label                │\n│ ┌──────────────────┐ │      │   ┌────────────────┐ │\n│ │ Input            │ │      │   │ Input          │ │\n│ └──────────────────┘ │      │   └────────────────┘ │\n│                      │      │                      │\n│ Label                │      │  Label               │\n│ ┌──────────────────┐ │      │ ┌──────────────────┐ │\n│ │ Input            │ │      │ │ Input            │ │\n│ └──────────────────┘ │      │ └──────────────────┘ │\n└──────────────────────┘      └──────────────────────┘\nProximity: Related elements should be closer together\n┌────────────────────────────────────┐\n│  Billing Address                   │\n│  ┌──────────────────────────────┐  │  ← These belong together\n│  │ Street                       │  │\n│  └──────────────────────────────┘  │\n│  ┌─────────┐ ┌───────┐ ┌───────┐  │\n│  │ City    │ │ State │ │ Zip   │  │\n│  └─────────┘ └───────┘ └───────┘  │\n│                                    │  ← Gap separates sections\n│  Shipping Address                  │\n│  ┌──────────────────────────────┐  │  ← New group\n│  │ Street                       │  │\n│  └──────────────────────────────┘  │\n└────────────────────────────────────┘",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#responsive-design",
    "href": "chapters/05-ui-ux.html#responsive-design",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.7 5.6 Responsive Design",
    "text": "8.7 5.6 Responsive Design\nResponsive design creates interfaces that adapt to different screen sizes and devices. Rather than building separate versions for desktop, tablet, and mobile, responsive design uses flexible layouts that reflow and resize.\n\n5.6.1 Why Responsive Design Matters\nUsers access the web from many devices:\n\nDesktop computers (various screen sizes)\nLaptops\nTablets (portrait and landscape)\nSmartphones (various sizes)\nSmart TVs\nWearables\n\nBuilding separate versions for each is impractical. Responsive design handles this variety with a single codebase.\n\n\n5.6.2 Responsive Design Principles\n1. Fluid Layouts\nUse percentages and flexible units instead of fixed pixels:\n/* Fixed - doesn't adapt */\n.container {\n    width: 960px;\n}\n\n/* Fluid - adapts to screen */\n.container {\n    width: 90%;\n    max-width: 1200px;\n}\n2. Flexible Images\nImages should scale within their containers:\nimg {\n    max-width: 100%;\n    height: auto;\n}\n3. Media Queries\nApply different styles based on screen characteristics:\n/* Base styles (mobile-first) */\n.sidebar {\n    width: 100%;\n}\n\n/* Tablet and up */\n@media (min-width: 768px) {\n    .sidebar {\n        width: 30%;\n        float: left;\n    }\n}\n\n/* Desktop and up */\n@media (min-width: 1024px) {\n    .sidebar {\n        width: 25%;\n    }\n}\n\n\n5.6.3 Breakpoints\nBreakpoints are the screen widths where layout changes occur. Common breakpoints:\n\n\n\nBreakpoint\nTarget Devices\n\n\n\n\n&lt; 576px\nSmall phones\n\n\n576px - 768px\nLarge phones, small tablets\n\n\n768px - 1024px\nTablets\n\n\n1024px - 1200px\nSmall desktops, laptops\n\n\n&gt; 1200px\nLarge desktops\n\n\n\nMobile-First vs. Desktop-First:\nMobile-first: Start with mobile styles, add complexity for larger screens\n/* Mobile styles (default) */\n.nav { display: none; }\n\n/* Larger screens */\n@media (min-width: 768px) {\n    .nav { display: flex; }\n}\nDesktop-first: Start with desktop styles, simplify for smaller screens\n/* Desktop styles (default) */\n.nav { display: flex; }\n\n/* Smaller screens */\n@media (max-width: 767px) {\n    .nav { display: none; }\n}\nMobile-first is generally recommended because:\n\nForces prioritization of essential content\nProgressive enhancement (add features vs. remove them)\nMobile usage continues to grow\n\n\n\n5.6.4 Responsive Patterns\nColumn Drop:\nMulti-column layout stacks into single column on small screens:\nDesktop:                    Mobile:\n┌────────┬────────┬────────┐ ┌────────────────┐\n│   A    │   B    │   C    │ │       A        │\n│        │        │        │ ├────────────────┤\n│        │        │        │ │       B        │\n└────────┴────────┴────────┘ ├────────────────┤\n                             │       C        │\n                             └────────────────┘\nLayout Shifter:\nLayout reorganizes more dramatically across breakpoints:\nDesktop:                    Mobile:\n┌──────────────────────────┐ ┌────────────────┐\n│          Header          │ │     Header     │\n├────────┬─────────────────┤ ├────────────────┤\n│        │                 │ │                │\n│  Nav   │     Content     │ │    Content     │\n│        │                 │ │                │\n│        │                 │ ├────────────────┤\n└────────┴─────────────────┘ │      Nav       │\n                             └────────────────┘\nOff-Canvas:\nNavigation hidden off-screen on mobile, slides in when activated:\nDesktop:                    Mobile (menu closed):    Mobile (menu open):\n┌────────────────────────┐  ┌────────────────┐      ┌──────┬─────────┐\n│ Logo  Nav Nav Nav  User│  │ ☰ Logo    User │      │ Nav  │ Content │\n├────────────────────────┤  ├────────────────┤      │      │ (dimmed)│\n│                        │  │                │      │ Nav  │         │\n│        Content         │  │    Content     │      │      │         │\n│                        │  │                │      │ Nav  │         │\n└────────────────────────┘  └────────────────┘      └──────┴─────────┘\n\n\n5.6.5 Touch Considerations\nMobile interfaces require touch-friendly design:\nTouch Target Sizes:\n\nMinimum 44x44 points (Apple) or 48x48dp (Google)\nAdequate spacing between targets\nImportant actions should have larger targets\n\nTouch Gestures:\n\nTap: Primary interaction\nSwipe: Navigate, delete, reveal actions\nPinch: Zoom\nLong press: Context menus, selection\n\nMobile-Specific Patterns:\n\nBottom navigation (thumb-friendly)\nPull to refresh\nSwipe actions on list items\nFloating action buttons",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#accessibility",
    "href": "chapters/05-ui-ux.html#accessibility",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.8 5.7 Accessibility",
    "text": "8.8 5.7 Accessibility\nAccessibility means designing products that can be used by people with disabilities. This includes users who are blind or have low vision, deaf or hard of hearing, have motor impairments, or have cognitive disabilities.\n\n5.7.1 Why Accessibility Matters\nIt’s the right thing to do. Everyone deserves access to digital services.\nIt’s often legally required. Many jurisdictions mandate accessibility (ADA in the US, EN 301 549 in EU).\nIt improves usability for everyone. Accessibility features like clear language, keyboard navigation, and good contrast benefit all users.\nIt expands your audience. Over 1 billion people worldwide have disabilities.\n\n\n5.7.2 WCAG Guidelines\nThe Web Content Accessibility Guidelines (WCAG) are the international standard for web accessibility. WCAG 2.1 organizes guidelines under four principles (POUR):\nPerceivable: Information must be presentable in ways users can perceive\n\nText alternatives for images\nCaptions for video\nSufficient color contrast\nContent adapts to different presentations\n\nOperable: Interface components must be operable\n\nKeyboard accessible\nEnough time to read and use content\nNo seizure-inducing content\nNavigable (clear structure, findable content)\n\nUnderstandable: Information and operation must be understandable\n\nReadable text\nPredictable behavior\nHelp users avoid and correct mistakes\n\nRobust: Content must be robust enough for diverse user agents\n\nCompatible with assistive technologies\nValid, well-structured code\n\nConformance Levels:\n\nLevel A: Minimum accessibility (must meet)\nLevel AA: Standard target for most sites (should meet)\nLevel AAA: Highest accessibility (enhanced, not always possible)\n\n\n\n5.7.3 Common Accessibility Requirements\n1. Alternative Text for Images\nScreen readers can’t see images; they read alt text instead.\n&lt;!-- Informative image --&gt;\n&lt;img src=\"chart.png\" alt=\"Sales increased 25% from Q1 to Q2\"&gt;\n\n&lt;!-- Decorative image (empty alt) --&gt;\n&lt;img src=\"decorative-line.png\" alt=\"\"&gt;\n\n&lt;!-- Complex image (link to description) --&gt;\n&lt;img src=\"complex-diagram.png\" alt=\"System architecture diagram\" \n     aria-describedby=\"diagram-description\"&gt;\n&lt;div id=\"diagram-description\"&gt;\n    Detailed description of the diagram...\n&lt;/div&gt;\n2. Keyboard Navigation\nEverything should be operable with keyboard alone:\n\nTab: Move between interactive elements\nEnter/Space: Activate buttons/links\nArrow keys: Navigate within components\nEscape: Close dialogs/menus\n\n&lt;!-- Good: Native button is keyboard accessible --&gt;\n&lt;button onclick=\"submit()\"&gt;Submit&lt;/button&gt;\n\n&lt;!-- Bad: Div requires extra work for accessibility --&gt;\n&lt;div onclick=\"submit()\"&gt;Submit&lt;/div&gt;\n\n&lt;!-- If you must use div, add keyboard support --&gt;\n&lt;div role=\"button\" tabindex=\"0\" \n     onclick=\"submit()\" \n     onkeydown=\"if(event.key==='Enter') submit()\"&gt;\n    Submit\n&lt;/div&gt;\n3. Focus Indicators\nUsers must see which element has keyboard focus:\n/* Don't remove focus outlines without replacement */\n/* Bad: */\n:focus { outline: none; }\n\n/* Good: Custom focus style */\n:focus {\n    outline: 2px solid #0066cc;\n    outline-offset: 2px;\n}\n\n/* Or use focus-visible for mouse/keyboard distinction */\n:focus-visible {\n    outline: 2px solid #0066cc;\n}\n4. Color Contrast\nText must have sufficient contrast against background:\nGood Contrast:                Poor Contrast:\n┌─────────────────────────┐   ┌─────────────────────────┐\n│                         │   │                         │\n│   Dark text on light    │   │   Light gray on white   │\n│   background (7:1)      │   │   background (1.5:1)    │\n│                         │   │                         │\n└─────────────────────────┘   └─────────────────────────┘\nTools to check contrast:\n\nWebAIM Contrast Checker\nFigma accessibility plugins\nBrowser developer tools\n\n5. Form Labels\nEvery form input needs an associated label:\n&lt;!-- Good: Label explicitly associated --&gt;\n&lt;label for=\"email\"&gt;Email address&lt;/label&gt;\n&lt;input type=\"email\" id=\"email\" name=\"email\"&gt;\n\n&lt;!-- Good: Label wraps input --&gt;\n&lt;label&gt;\n    Email address\n    &lt;input type=\"email\" name=\"email\"&gt;\n&lt;/label&gt;\n\n&lt;!-- Bad: No label association --&gt;\n&lt;span&gt;Email address&lt;/span&gt;\n&lt;input type=\"email\" name=\"email\"&gt;\n6. Semantic HTML\nUse HTML elements for their intended purpose:\n&lt;!-- Good: Semantic structure --&gt;\n&lt;header&gt;\n    &lt;nav&gt;\n        &lt;ul&gt;\n            &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n            &lt;li&gt;&lt;a href=\"/about\"&gt;About&lt;/a&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n    &lt;/nav&gt;\n&lt;/header&gt;\n&lt;main&gt;\n    &lt;article&gt;\n        &lt;h1&gt;Article Title&lt;/h1&gt;\n        &lt;p&gt;Content...&lt;/p&gt;\n    &lt;/article&gt;\n&lt;/main&gt;\n&lt;footer&gt;\n    &lt;p&gt;Copyright 2024&lt;/p&gt;\n&lt;/footer&gt;\n\n&lt;!-- Bad: Divs for everything --&gt;\n&lt;div class=\"header\"&gt;\n    &lt;div class=\"nav\"&gt;\n        &lt;div class=\"nav-item\"&gt;Home&lt;/div&gt;\n        &lt;div class=\"nav-item\"&gt;About&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"content\"&gt;\n    &lt;div class=\"title\"&gt;Article Title&lt;/div&gt;\n    &lt;div&gt;Content...&lt;/div&gt;\n&lt;/div&gt;\n7. ARIA When Needed\nARIA (Accessible Rich Internet Applications) adds semantic information when HTML alone isn’t sufficient:\n&lt;!-- Tab interface --&gt;\n&lt;div role=\"tablist\"&gt;\n    &lt;button role=\"tab\" aria-selected=\"true\" aria-controls=\"panel1\"&gt;\n        Tab 1\n    &lt;/button&gt;\n    &lt;button role=\"tab\" aria-selected=\"false\" aria-controls=\"panel2\"&gt;\n        Tab 2\n    &lt;/button&gt;\n&lt;/div&gt;\n&lt;div role=\"tabpanel\" id=\"panel1\"&gt;Content 1&lt;/div&gt;\n&lt;div role=\"tabpanel\" id=\"panel2\" hidden&gt;Content 2&lt;/div&gt;\n\n&lt;!-- Live region for dynamic updates --&gt;\n&lt;div aria-live=\"polite\" aria-atomic=\"true\"&gt;\n    &lt;!-- Screen reader announces when this content changes --&gt;\n    Your cart has been updated\n&lt;/div&gt;\nARIA Rules:\n\nDon’t use ARIA if HTML can do it\nDon’t change native semantics (unless necessary)\nAll interactive ARIA controls must be keyboard accessible\nDon’t use role=\"presentation\" or aria-hidden=\"true\" on focusable elements\nAll interactive elements must have an accessible name\n\n\n\n5.7.4 Accessibility Testing\nAutomated Testing:\n\naxe DevTools (browser extension)\nWAVE (web accessibility evaluator)\nLighthouse (built into Chrome)\nESLint accessibility plugins\n\nManual Testing:\n\nNavigate with keyboard only\nUse a screen reader (VoiceOver, NVDA, JAWS)\nZoom to 200%\nTest with high contrast mode\nVerify focus order makes sense\n\nAccessibility Checklist:\n\nAll images have appropriate alt text\nColor contrast meets WCAG AA (4.5:1 for text)\nAll functionality available via keyboard\nFocus indicator is visible\nForm inputs have labels\nErrors are clearly described\nPage has proper heading structure\nLinks have descriptive text\nDynamic content is announced to screen readers\nNo content flashes more than 3 times per second",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#design-systems-and-style-guides",
    "href": "chapters/05-ui-ux.html#design-systems-and-style-guides",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.9 5.8 Design Systems and Style Guides",
    "text": "8.9 5.8 Design Systems and Style Guides\nA design system is a collection of reusable components, guided by clear standards, that can be assembled to build any number of applications. A style guide documents these standards.\n\n5.8.1 Why Design Systems Matter\nConsistency: Users learn patterns once and apply them everywhere.\nEfficiency: Don’t redesign buttons for every project. Reuse proven solutions.\nQuality: Components are refined over time, incorporating accessibility and usability improvements.\nScalability: Large teams can work independently while maintaining consistency.\nCommunication: Shared vocabulary between designers and developers.\n\n\n5.8.2 Components of a Design System\nDesign Tokens:\nThe smallest elements—colors, typography, spacing, shadows:\nCOLORS\n──────────────────────────────────────\nprimary-50:    #E3F2FD\nprimary-100:   #BBDEFB\nprimary-500:   #2196F3  (main)\nprimary-700:   #1976D2\nprimary-900:   #0D47A1\n\nTYPOGRAPHY\n──────────────────────────────────────\nfont-family-primary:    \"Inter\", sans-serif\nfont-family-mono:       \"Fira Code\", monospace\n\nfont-size-xs:     12px\nfont-size-sm:     14px\nfont-size-base:   16px\nfont-size-lg:     18px\nfont-size-xl:     20px\nfont-size-2xl:    24px\nfont-size-3xl:    32px\n\nSPACING\n──────────────────────────────────────\nspace-1:    4px\nspace-2:    8px\nspace-3:    12px\nspace-4:    16px\nspace-5:    20px\nspace-6:    24px\nspace-8:    32px\nspace-10:   40px\nspace-12:   48px\nspace-16:   64px\n\nSHADOWS\n──────────────────────────────────────\nshadow-sm:    0 1px 2px rgba(0,0,0,0.05)\nshadow-md:    0 4px 6px rgba(0,0,0,0.1)\nshadow-lg:    0 10px 15px rgba(0,0,0,0.1)\n\nBORDER RADIUS\n──────────────────────────────────────\nradius-sm:    4px\nradius-md:    8px\nradius-lg:    16px\nradius-full:  9999px\nUI Components:\nReusable building blocks:\nBUTTONS\n──────────────────────────────────────\n\nPrimary Button\n┌─────────────────────┐\n│    Primary Action   │  Background: primary-500\n└─────────────────────┘  Text: white\n                         Padding: space-3 space-6\n                         Border-radius: radius-md\n\nSecondary Button\n┌─────────────────────┐\n│   Secondary Action  │  Background: transparent\n└─────────────────────┘  Border: 1px solid primary-500\n                         Text: primary-500\n\nDestructive Button\n┌─────────────────────┐\n│       Delete        │  Background: error-500\n└─────────────────────┘  Text: white\n\nButton States:\n- Default\n- Hover (darken background 10%)\n- Active (darken background 20%)\n- Focused (add focus ring)\n- Disabled (50% opacity, no pointer events)\n\nFORM INPUTS\n──────────────────────────────────────\n\nText Input\n┌─────────────────────────────────────┐\n│ Placeholder text                    │\n└─────────────────────────────────────┘\nBorder: 1px solid gray-300\nBorder-radius: radius-md\nPadding: space-3 space-4\n\nStates:\n- Default: gray-300 border\n- Focused: primary-500 border + shadow\n- Error: error-500 border\n- Disabled: gray-100 background\n\nCARDS\n──────────────────────────────────────\n\n┌─────────────────────────────────────┐\n│  Card Title                         │\n│─────────────────────────────────────│\n│                                     │\n│  Card content goes here with       │\n│  supporting text and information.   │\n│                                     │\n│  [Secondary]  [Primary Action]      │\n└─────────────────────────────────────┘\nBackground: white\nBorder-radius: radius-lg\nShadow: shadow-md\nPadding: space-6\nPatterns:\nCommon UI patterns built from components:\nNAVIGATION PATTERN\n──────────────────────────────────────\n\nTop Navigation (Desktop)\n┌─────────────────────────────────────────────────────────────┐\n│ [Logo]    Nav Item    Nav Item    Nav Item        [Avatar ▼]│\n└─────────────────────────────────────────────────────────────┘\n\nMobile Navigation\n┌─────────────────────────────────────┐\n│ [☰]              [Logo]        [🔔] │\n└─────────────────────────────────────┘\n\nFORM PATTERN\n──────────────────────────────────────\n\nStandard Form Layout\n┌─────────────────────────────────────┐\n│  Form Title                         │\n│  Subtitle or instructions           │\n│                                     │\n│  Label                              │\n│  ┌─────────────────────────────────┐│\n│  │ Input                           ││\n│  └─────────────────────────────────┘│\n│  Helper text                        │\n│                                     │\n│  Label                              │\n│  ┌─────────────────────────────────┐│\n│  │ Input                           ││\n│  └─────────────────────────────────┘│\n│                                     │\n│           [Cancel]  [Submit]        │\n└─────────────────────────────────────┘\n\n\n5.8.3 Creating a Style Guide\nA style guide documents your design system. For your project, include:\n1. Introduction\n\nPurpose of the style guide\nHow to use it\nWhere to find resources (Figma files, code repositories)\n\n2. Design Principles\n\nCore values guiding design decisions\nExample: “Clarity over decoration,” “Accessibility first”\n\n3. Brand\n\nLogo usage\nVoice and tone\n\n4. Visual Foundation\n\nColor palette (with accessibility notes)\nTypography scale\nSpacing system\nIconography\nImagery guidelines\n\n5. Components\n\nEach component with:\n\nVisual examples (all states)\nUsage guidelines (when to use/not use)\nSpecifications (sizes, colors, spacing)\nCode examples (if technical)\nAccessibility requirements\n\n\n6. Patterns\n\nCommon UI patterns\nPage layouts\nNavigation patterns\nForm patterns\n\n\n\n5.8.4 Style Guide Example\nHere’s a condensed style guide structure:\n# TaskFlow Style Guide\n\n## 1. Design Principles\n\n1. **Clarity First**: Every element should have a clear purpose\n2. **Respectful of Time**: Minimize steps, reduce friction\n3. **Accessible to All**: WCAG AA compliance minimum\n4. **Consistent Experience**: Same patterns throughout\n\n## 2. Colors\n\n### Primary Palette\n| Name        | Hex     | Usage                    |\n|-------------|---------|--------------------------|\n| Primary     | #2563EB | Interactive elements     |\n| Primary Dark| #1D4ED8 | Hover states             |\n| Primary Light| #DBEAFE| Backgrounds, highlights  |\n\n### Semantic Colors\n| Name    | Hex     | Usage            |\n|---------|---------|------------------|\n| Success | #10B981 | Success states   |\n| Warning | #F59E0B | Warning states   |\n| Error   | #EF4444 | Error states     |\n| Info    | #3B82F6 | Info states      |\n\n### Neutrals\n| Name      | Hex     | Usage            |\n|-----------|---------|------------------|\n| Gray 900  | #111827 | Primary text     |\n| Gray 600  | #4B5563 | Secondary text   |\n| Gray 400  | #9CA3AF | Disabled, hints  |\n| Gray 200  | #E5E7EB | Borders          |\n| Gray 50   | #F9FAFB | Backgrounds      |\n\n## 3. Typography\n\n**Font Family**: Inter (sans-serif)\n\n| Style    | Size | Weight | Line Height | Usage        |\n|----------|------|--------|-------------|--------------|\n| H1       | 32px | 700    | 1.2         | Page titles  |\n| H2       | 24px | 600    | 1.3         | Section heads|\n| H3       | 20px | 600    | 1.4         | Subsections  |\n| Body     | 16px | 400    | 1.5         | Body text    |\n| Small    | 14px | 400    | 1.5         | Helper text  |\n| Caption  | 12px | 400    | 1.4         | Labels       |\n\n## 4. Spacing\n\nBase unit: 4px\n\n| Token   | Value | Usage                    |\n|---------|-------|--------------------------|\n| xs      | 4px   | Tight spacing            |\n| sm      | 8px   | Related elements         |\n| md      | 16px  | Default spacing          |\n| lg      | 24px  | Section spacing          |\n| xl      | 32px  | Large gaps               |\n| 2xl     | 48px  | Page sections            |\n\n## 5. Components\n\n### Buttons\n\n**Primary Button**\n- Background: Primary (#2563EB)\n- Text: White\n- Padding: 12px 24px\n- Border-radius: 6px\n- States: Hover (Primary Dark), Disabled (50% opacity)\n\n**Usage**: Use for primary actions. One per section maximum.\n\n**Accessibility**: \n- Minimum touch target 44x44px\n- Focus ring: 2px offset, Primary color\n\n[Continue for each component...]",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#prototyping-in-practice-using-figma",
    "href": "chapters/05-ui-ux.html#prototyping-in-practice-using-figma",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.10 5.9 Prototyping in Practice: Using Figma",
    "text": "8.10 5.9 Prototyping in Practice: Using Figma\nFigma is the industry-standard tool for UI design and prototyping. This section provides a practical introduction.\n\n5.9.1 Figma Basics\nKey Concepts:\n\nCanvas: Infinite workspace where you design\nFrames: Containers for your designs (like artboards)\nLayers: Objects stack in layers (like Photoshop)\nComponents: Reusable elements\nVariants: Different versions of a component\nAuto Layout: Flexible, responsive containers\nPrototyping: Link frames to create interactive flows\n\nEssential Tools:\n\n\n\nTool\nShortcut\nPurpose\n\n\n\n\nMove\nV\nSelect and move objects\n\n\nFrame\nF\nCreate frames/containers\n\n\nRectangle\nR\nDraw rectangles\n\n\nEllipse\nO\nDraw circles/ellipses\n\n\nLine\nL\nDraw lines\n\n\nText\nT\nAdd text\n\n\nPen\nP\nDraw custom shapes\n\n\nHand\nH (hold Space)\nPan around canvas\n\n\nZoom\nScroll or Z\nZoom in/out\n\n\n\n\n\n5.9.2 Creating a Simple Wireframe in Figma\nStep 1: Set Up Frame\n\nPress F for Frame tool\nSelect a device preset (e.g., “Desktop” 1440x900)\nName your frame in the layers panel\n\nStep 2: Add Structure\n\nDraw rectangles (R) for major areas:\n\nHeader\nSidebar\nMain content\nFooter\n\nUse gray fills (#E5E7EB for backgrounds, #9CA3AF for placeholders)\n\nStep 3: Add Content Placeholders\n\nText tool (T) for headings and labels\nRectangles with X pattern for image placeholders\nLines for text content\n\nStep 4: Create Components\n\nSelect a reusable element (e.g., a button)\nRight-click → “Create Component” (or Ctrl/Cmd + Alt + K)\nUse instances of the component throughout your design\n\nStep 5: Add Prototyping Interactions\n\nSwitch to Prototype tab (right panel)\nSelect an element\nDrag the connection handle to the target frame\nSet interaction (e.g., “On Click → Navigate to”)\nPress Play button to preview\n\n\n\n5.9.3 Figma Tips for Beginners\nOrganization:\n\nName your layers meaningfully\nGroup related elements (Ctrl/Cmd + G)\nUse pages for different sections of your project\nCreate a “Components” page for your design system\n\nEfficiency:\n\nCopy styles: Select object with desired style, then use eyedropper\nDuplicate: Alt + drag\nAlign/distribute: Use toolbar or right-click\nAuto Layout: Makes responsive containers (Shift + A)\n\nCollaboration:\n\nShare link for viewing/editing\nLeave comments on designs\nUse branches for major changes\nExport assets for development (PNG, SVG, CSS)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#chapter-summary",
    "href": "chapters/05-ui-ux.html#chapter-summary",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.11 5.10 Chapter Summary",
    "text": "8.11 5.10 Chapter Summary\nUI/UX design is essential to creating software that users actually want to use. Good design isn’t about making things pretty—it’s about understanding users and creating interfaces that help them accomplish their goals efficiently and pleasantly.\nKey takeaways from this chapter:\n\nUX design focuses on the overall experience—how users feel when using a product. UI design focuses on the visual and interactive elements they directly interact with.\nHuman-centered design starts with understanding users through research, empathy, and observation. Personas and journey maps help teams maintain focus on user needs.\nNielsen’s 10 Usability Heuristics provide a framework for evaluating and improving interfaces. They address visibility, consistency, error prevention, and more.\nPrototyping ranges from paper sketches to interactive simulations. Different fidelities serve different purposes in the design process.\nVisual design fundamentals—hierarchy, typography, color, and layout—create interfaces that communicate clearly and guide user attention.\nResponsive design creates interfaces that adapt to different screen sizes using fluid layouts, flexible images, and media queries.\nAccessibility ensures products work for users with disabilities. WCAG provides guidelines organized around perceivability, operability, understandability, and robustness.\nDesign systems and style guides document reusable components and standards, enabling consistency and efficiency across projects.\nFigma is the industry-standard tool for UI design and prototyping, enabling designers and developers to collaborate on interface designs.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#key-terms",
    "href": "chapters/05-ui-ux.html#key-terms",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.12 5.11 Key Terms",
    "text": "8.12 5.11 Key Terms\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nUser Experience (UX)\nThe overall experience a user has when interacting with a product\n\n\nUser Interface (UI)\nThe visual and interactive elements users interact with\n\n\nHuman-Centered Design\nDesign approach that focuses on understanding and addressing user needs\n\n\nPersona\nFictional character representing a user type\n\n\nJourney Map\nVisualization of user experience over time\n\n\nHeuristic\nRule of thumb for evaluating design quality\n\n\nWireframe\nLow-fidelity representation of interface layout\n\n\nPrototype\nInteractive model for testing design concepts\n\n\nResponsive Design\nDesign that adapts to different screen sizes\n\n\nBreakpoint\nScreen width where layout changes occur\n\n\nAccessibility\nDesign that can be used by people with disabilities\n\n\nWCAG\nWeb Content Accessibility Guidelines\n\n\nDesign System\nCollection of reusable components with documented standards\n\n\nStyle Guide\nDocumentation of design standards and patterns\n\n\nDesign Token\nSmallest element of a design system (color, spacing, etc.)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#review-questions",
    "href": "chapters/05-ui-ux.html#review-questions",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.13 5.12 Review Questions",
    "text": "8.13 5.12 Review Questions\n\nExplain the difference between UX and UI design. How do they relate to each other?\nWhat is human-centered design? Describe its key principles and why they matter for software development.\nChoose three of Nielsen’s 10 Usability Heuristics and explain each with an example of how a violation would affect users.\nWhat is the difference between low-fidelity and high-fidelity prototypes? When would you use each?\nExplain the mobile-first approach to responsive design. What are its advantages?\nWhat is WCAG, and what are its four main principles? Give one specific guideline for each principle.\nWhy do keyboard navigation and focus indicators matter for accessibility?\nWhat is a design system, and what are its benefits for software development teams?\nExplain the concept of visual hierarchy. What techniques can you use to create it?\nYou’re designing a checkout flow for an e-commerce site. How would you apply error prevention principles to reduce user mistakes?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#hands-on-exercises",
    "href": "chapters/05-ui-ux.html#hands-on-exercises",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.14 5.13 Hands-On Exercises",
    "text": "8.14 5.13 Hands-On Exercises\n\nExercise 5.1: Heuristic Evaluation\nChoose a website or application you use regularly. Conduct a heuristic evaluation:\n\nReview the interface against Nielsen’s 10 heuristics\nIdentify at least 10 usability issues\nRate each issue’s severity (0-4)\nProvide specific recommendations for improvement\nDocument your findings in a report\n\n\n\nExercise 5.2: User Persona Creation\nFor your semester project:\n\nIdentify your primary user type(s)\nCreate at least 2 detailed personas including:\n\nDemographics and background\nGoals and motivations\nFrustrations and pain points\nTechnology comfort level\nA representative quote\n\nCreate a user journey map for one key task\n\n\n\nExercise 5.3: Paper Prototyping\nBefore using digital tools:\n\nSketch wireframes on paper for 5-7 key screens of your project\nInclude annotations explaining functionality\nTest your paper prototype with a classmate:\n\nGive them a task to complete\n“Swap” paper screens as they navigate\nNote where they get confused\n\nIterate based on feedback\n\n\n\nExercise 5.4: Digital Wireframes\nUsing Figma (or similar tool):\n\nCreate wireframes for your project’s main screens\nInclude:\n\nNavigation structure\nContent layout\nKey UI elements (buttons, forms, etc.)\nPlaceholder content\n\nLink wireframes into an interactive prototype\nTest with at least 2 users and document findings\n\n\n\nExercise 5.5: Style Guide Creation\nCreate a style guide for your project including:\n\nColor Palette\n\nPrimary, secondary, and accent colors\nSemantic colors (success, error, warning, info)\nNeutral/gray scale\nAccessibility notes for each color combination\n\nTypography\n\nFont families\nSize scale (H1-H6, body, small)\nWeight and line-height specifications\n\nSpacing System\n\nBase unit and scale\n\nComponent Documentation (at least 5 components):\n\nButtons (with all states)\nInput fields (with states)\nCards\nNavigation\nOne additional component of your choice\n\n\n\n\nExercise 5.6: Accessibility Audit\nConduct an accessibility review of your project prototype:\n\nUse an accessibility checker tool (axe, WAVE)\nTest keyboard navigation manually\nCheck color contrast for all text\nVerify all images have alt text\nTest with a screen reader (even briefly)\nDocument issues found and fixes needed\nCreate an accessibility compliance checklist for your project\n\n\n\nExercise 5.7: Responsive Design\nFor one screen of your project:\n\nDesign the mobile version (375px wide)\nDesign the tablet version (768px wide)\nDesign the desktop version (1440px wide)\nDocument what changes at each breakpoint\nExplain your responsive design decisions",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#further-reading",
    "href": "chapters/05-ui-ux.html#further-reading",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.15 5.14 Further Reading",
    "text": "8.15 5.14 Further Reading\nBooks:\n\nKrug, S. (2014). Don’t Make Me Think, Revisited: A Common Sense Approach to Web Usability (3rd Edition). New Riders.\nNorman, D. (2013). The Design of Everyday Things (Revised Edition). Basic Books.\nCooper, A., Reimann, R., Cronin, D., & Noessel, C. (2014). About Face: The Essentials of Interaction Design (4th Edition). Wiley.\nLidwell, W., Holden, K., & Butler, J. (2010). Universal Principles of Design (Revised Edition). Rockport.\n\nOnline Resources:\n\nNielsen Norman Group: https://www.nngroup.com/articles/\nLaws of UX: https://lawsofux.com/\nWebAIM Accessibility: https://webaim.org/\nFigma Learn: https://help.figma.com/\nA11y Project: https://www.a11yproject.com/\nMaterial Design Guidelines: https://material.io/design\n\nTools:\n\nFigma: https://www.figma.com/ (free tier available)\nWebAIM Contrast Checker: https://webaim.org/resources/contrastchecker/\naxe DevTools: Browser extension for accessibility testing\nStark: Figma plugin for accessibility",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/05-ui-ux.html#references",
    "href": "chapters/05-ui-ux.html#references",
    "title": "8  Chapter 5: UI/UX Design and Prototyping",
    "section": "8.16 References",
    "text": "8.16 References\nCooper, A., Reimann, R., Cronin, D., & Noessel, C. (2014). About Face: The Essentials of Interaction Design (4th Edition). Wiley.\nIDEO. (2015). The Field Guide to Human-Centered Design. IDEO.org.\nKrug, S. (2014). Don’t Make Me Think, Revisited: A Common Sense Approach to Web Usability (3rd Edition). New Riders.\nNielsen, J. (1994). Usability Engineering. Morgan Kaufmann.\nNielsen, J. (1994). 10 Usability Heuristics for User Interface Design. Nielsen Norman Group. Retrieved from https://www.nngroup.com/articles/ten-usability-heuristics/\nNorman, D. (2013). The Design of Everyday Things (Revised Edition). Basic Books.\nW3C. (2018). Web Content Accessibility Guidelines (WCAG) 2.1. Retrieved from https://www.w3.org/TR/WCAG21/\nWroblewski, L. (2011). Mobile First. A Book Apart.Sample content for 06-ui-ux.qmd",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 5: UI/UX Design and Prototyping</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html",
    "href": "chapters/06-agile-methodologies.html",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "",
    "text": "9.1 Learning Objectives\nBy the end of this chapter, you will be able to:",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#learning-objectives",
    "href": "chapters/06-agile-methodologies.html#learning-objectives",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "",
    "text": "Explain the philosophy and values behind the Agile movement\nCompare and contrast Scrum, Kanban, and Extreme Programming (XP)\nImplement Scrum practices, including sprint planning, daily standups, reviews, and retrospectives\nApply Kanban principles to visualize and optimize workflow\nEstimate work using story points and measure team velocity\nUse project management tools like GitHub Projects and Jira effectively\nBreak down projects into epics, stories, and tasks\nCreate and manage a sprint backlog and Kanban board\nAdapt Agile practices to different team sizes and contexts",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#the-agile-revolution",
    "href": "chapters/06-agile-methodologies.html#the-agile-revolution",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.2 6.1 The Agile Revolution",
    "text": "9.2 6.1 The Agile Revolution\nIn the late 1990s, software development was in crisis. Projects routinely failed—delivered late, over budget, or not at all. The dominant approach, often called “big design up front” or Waterfall, required extensive planning and documentation before any code was written. By the time software was delivered, requirements had changed, and the product no longer met user needs.\nA group of software practitioners who had been experimenting with lighter, more iterative approaches came together in February 2001 at a ski resort in Snowbird, Utah. They emerged with the Agile Manifesto, a document that would reshape how the world builds software.\n\n6.1.1 The Agile Manifesto\nThe manifesto articulates four core values:\n\nIndividuals and interactions over processes and tools\nWorking software over comprehensive documentation\nCustomer collaboration over contract negotiation\nResponding to change over following a plan\n\nThe manifesto explicitly notes: “While there is value in the items on the right, we value the items on the left more.”\nThis is a crucial nuance. Agile doesn’t reject processes, documentation, contracts, or plans. It prioritizes their counterparts when trade-offs must be made.\nUnpacking the Values:\nIndividuals and interactions over processes and tools: The best processes and tools can’t compensate for poor communication or unmotivated people. Focus on building collaborative teams and enabling effective communication.\nWorking software over comprehensive documentation: Documentation that nobody reads adds no value. Working software that users can actually use provides real feedback. This doesn’t mean “no documentation”—it means documentation that serves a purpose.\nCustomer collaboration over contract negotiation: Traditional contracts tried to specify everything upfront, then hold parties accountable to that specification. But requirements evolve. Agile favors ongoing collaboration where customers and developers work together toward shared goals.\nResponding to change over following a plan: Plans become obsolete. Markets shift, users provide feedback, technologies evolve. Rather than fighting change, Agile embraces it as an opportunity to deliver more value.\n\n\n6.1.2 The Twelve Principles\nBehind the manifesto are twelve principles that guide Agile practice:\n\nSatisfy the customer through early and continuous delivery of valuable software.\nWelcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.\nDeliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.\nBusiness people and developers must work together daily throughout the project.\nBuild projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.\nFace-to-face conversation is the most efficient and effective method of conveying information.\nWorking software is the primary measure of progress.\nAgile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.\nContinuous attention to technical excellence and good design enhances agility.\nSimplicity—the art of maximizing the amount of work not done—is essential.\nThe best architectures, requirements, and designs emerge from self-organizing teams.\nAt regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.\n\n\n\n6.1.3 Agile Is a Mindset, Not a Methodology\nA common misconception is that “Agile” is a specific process you can install. It’s not. Agile is a set of values and principles—a mindset. Specific methodologies like Scrum, Kanban, and XP are implementations of that mindset, each with different practices suited to different contexts.\nOrganizations that adopt Agile practices without embracing Agile values often fail to see benefits. They do “Agile theater”—standups that are status reports, sprints that are just short Waterfall phases, retrospectives that lead to no changes. True agility requires genuine commitment to the underlying principles.\n                    Agile Mindset\n                    (Values & Principles)\n                          │\n        ┌─────────────────┼─────────────────┐\n        │                 │                 │\n        ▼                 ▼                 ▼\n    ┌───────┐        ┌───────┐        ┌───────┐\n    │ Scrum │        │Kanban │        │  XP   │\n    └───────┘        └───────┘        └───────┘\n        │                 │                 │\n        └─────────────────┴─────────────────┘\n                          │\n                          ▼\n                   Your Team's Process\n                   (Adapted to Context)\n\n\n6.1.4 Why Agile Works\nAgile works because it aligns with fundamental truths about software development:\nRequirements are uncertain. Users often don’t know what they want until they see it. Agile delivers working software frequently, enabling early feedback and course correction.\nComplexity defies prediction. Software projects are complex adaptive systems. Small changes can have large effects. Agile embraces empiricism—making decisions based on observation rather than prediction.\nPeople matter. Software is built by humans, and human factors dominate project outcomes. Agile focuses on team dynamics, motivation, and sustainable pace.\nChange is constant. Markets evolve, competitors move, users learn. Organizations that can respond quickly to change have a competitive advantage. Agile makes change a feature, not a bug.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#scrum-a-framework-for-agile-development",
    "href": "chapters/06-agile-methodologies.html#scrum-a-framework-for-agile-development",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.3 6.2 Scrum: A Framework for Agile Development",
    "text": "9.3 6.2 Scrum: A Framework for Agile Development\nScrum is the most widely adopted Agile framework. Originally described by Ken Schwaber and Jeff Sutherland, Scrum provides a lightweight structure for teams to deliver complex products iteratively.\nScrum is named after the rugby formation where a team works together to move the ball down the field. Like rugby, Scrum emphasizes teamwork, adaptability, and continuous forward progress.\n\n6.2.1 The Scrum Framework Overview\nScrum organizes work into fixed-length iterations called sprints, typically two weeks long. Each sprint produces a potentially shippable product increment.\n┌─────────────────────────────────────────────────────────────────────────┐\n│                           SCRUM FRAMEWORK                               │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  ROLES              EVENTS                 ARTIFACTS                    │\n│  ─────              ──────                 ─────────                    │\n│  • Product Owner    • Sprint               • Product Backlog            │\n│  • Scrum Master     • Sprint Planning      • Sprint Backlog             │\n│  • Developers       • Daily Scrum          • Increment                  │\n│                     • Sprint Review                                     │\n│                     • Sprint Retrospective                              │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nThe Sprint Cycle:\n┌─────────────────────────────────────────────────────────────────────────┐\n│                                                                         │\n│   Product        Sprint          Daily        Sprint        Sprint      │\n│   Backlog       Planning        Scrum         Review      Retrospective │\n│      │             │              │             │              │        │\n│      │             │    ┌─────────┼─────────┐   │              │        │\n│      │             │    │         │         │   │              │        │\n│      ▼             ▼    ▼         ▼         ▼   ▼              ▼        │\n│   ┌──────┐    ┌────────────────────────────────────┐    ┌──────────┐   │\n│   │      │    │                                    │    │          │   │\n│   │ What │───►│         SPRINT (2-4 weeks)         │───►│ Increment│   │\n│   │      │    │                                    │    │          │   │\n│   └──────┘    └────────────────────────────────────┘    └──────────┘   │\n│                                    │                                    │\n│                                    │                                    │\n│                    ┌───────────────┴───────────────┐                    │\n│                    │      Sprint Backlog           │                    │\n│                    │   (Committed work for sprint) │                    │\n│                    └───────────────────────────────┘                    │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n\n\n6.2.2 Scrum Roles\nScrum defines three roles, each with distinct responsibilities:\nProduct Owner\nThe Product Owner is responsible for maximizing the value of the product. They are the single voice of the customer within the team.\nResponsibilities:\n\nMaintains and prioritizes the Product Backlog\nEnsures the backlog is visible, transparent, and understood\nMakes decisions about what to build and in what order\nAccepts or rejects work completed by the team\nCommunicates with stakeholders about progress and priorities\n\nThe Product Owner must be empowered to make decisions. A committee of stakeholders or a Product Owner who must get approval for every decision slows the team down.\nScrum Master\nThe Scrum Master is responsible for the Scrum process itself. They help the team understand and apply Scrum effectively.\nResponsibilities:\n\nFacilitates Scrum events (planning, standups, reviews, retrospectives)\nRemoves impediments that block the team\nCoaches the team on Scrum practices\nProtects the team from external interruptions\nHelps the organization understand and adopt Scrum\n\nThe Scrum Master is not a project manager. They don’t assign tasks or manage the team. They serve the team by enabling effective Scrum practice.\nDevelopers\nThe Developers are the people who do the work of building the product. Despite the name, this includes anyone contributing to the increment—developers, testers, designers, analysts, and others.\nResponsibilities:\n\nEstimate work and commit to sprint goals\nSelf-organize to accomplish sprint work\nDeliver a potentially shippable increment each sprint\nParticipate in all Scrum events\nHold each other accountable for quality and commitments\n\nScrum teams are cross-functional—they have all skills needed to deliver the increment without depending on people outside the team.\nTeam Size:\nScrum works best with small teams. The Scrum Guide recommends 10 or fewer people. Larger groups should split into multiple Scrum teams.\n┌─────────────────────────────────────────────────────────────────────────┐\n│                          SCRUM TEAM                                     │\n│                                                                         │\n│   ┌─────────────┐    ┌─────────────┐    ┌─────────────────────────┐    │\n│   │   Product   │    │   Scrum     │    │      Developers         │    │\n│   │    Owner    │    │   Master    │    │    (3-9 people)         │    │\n│   │             │    │             │    │                         │    │\n│   │ • Backlog   │    │ • Process   │    │  • Designer             │    │\n│   │ • Priority  │    │ • Coach     │    │  • Developer            │    │\n│   │ • Value     │    │ • Facilitate│    │  • Developer            │    │\n│   │ • Decide    │    │ • Remove    │    │  • Developer            │    │\n│   │             │    │   obstacles │    │  • QA Engineer          │    │\n│   └─────────────┘    └─────────────┘    └─────────────────────────┘    │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n\n\n6.2.3 Scrum Artifacts\nProduct Backlog\nThe Product Backlog is an ordered list of everything that might be needed in the product. It’s the single source of requirements.\nCharacteristics:\n\nOwned and maintained by the Product Owner\nOrdered by value, risk, priority, and necessity\nItems at the top are more detailed than items at the bottom\nContinuously refined (grooming/refinement)\nNever complete—it evolves as the product and market evolve\n\nBacklog items typically include:\n\nFeatures\nBug fixes\nTechnical work\nKnowledge acquisition (spikes)\n\nExample Product Backlog:\n┌─────────────────────────────────────────────────────────────────────────┐\n│ PRODUCT BACKLOG - TaskFlow                              Owner: Sarah    │\n├─────┬──────────────────────────────────────────────┬────────┬──────────┤\n│ Rank│ Item                                         │ Points │ Status   │\n├─────┼──────────────────────────────────────────────┼────────┼──────────┤\n│  1  │ User can create and edit tasks               │   5    │ Ready    │\n│  2  │ User can assign tasks to team members        │   3    │ Ready    │\n│  3  │ User can set due dates with reminders        │   5    │ Ready    │\n│  4  │ User can view tasks on Kanban board          │   8    │ Ready    │\n│  5  │ User can receive email notifications         │   5    │ Needs    │\n│     │                                              │        │ refinement│\n│  6  │ User can filter and search tasks             │   8    │ Needs    │\n│     │                                              │        │ refinement│\n│  7  │ Admin can manage team membership             │   5    │ Rough    │\n│  8  │ User can attach files to tasks               │   8    │ Rough    │\n│  9  │ Integration with Google Calendar             │   13   │ Rough    │\n│ 10  │ Mobile app (iOS)                             │   ?    │ Idea     │\n│ 11  │ Mobile app (Android)                         │   ?    │ Idea     │\n│ ... │ ...                                          │        │          │\n└─────┴──────────────────────────────────────────────┴────────┴──────────┘\nSprint Backlog\nThe Sprint Backlog is the set of Product Backlog items selected for the sprint, plus a plan for delivering them.\nCharacteristics:\n\nCreated during Sprint Planning\nOwned by the Developers\nRepresents the team’s commitment for the sprint\nUpdated daily as work progresses\nVisible to all stakeholders\n\nThe Sprint Backlog includes:\n\nSelected user stories\nTasks to complete each story\nEstimated hours remaining (optional)\n\nExample Sprint Backlog:\n┌─────────────────────────────────────────────────────────────────────────┐\n│ SPRINT 3 BACKLOG                          Sprint Goal: Core Task CRUD   │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│ ┌─────────────────────────────────────────────────────────────────────┐ │\n│ │ Story: User can create and edit tasks (5 pts)                       │ │\n│ │ Status: In Progress                                                 │ │\n│ │ ─────────────────────────────────────────────────────────────────── │ │\n│ │ Tasks:                                                              │ │\n│ │ [x] Design task creation form (Designer, 4h)                        │ │\n│ │ [x] Create Task model and database schema (Dev A, 3h)               │ │\n│ │ [~] Implement create task API endpoint (Dev B, 4h) - In Progress    │ │\n│ │ [ ] Build task creation UI component (Dev C, 6h)                    │ │\n│ │ [ ] Implement edit task functionality (Dev B, 4h)                   │ │\n│ │ [ ] Write unit tests (QA, 3h)                                       │ │\n│ │ [ ] Write integration tests (QA, 2h)                                │ │\n│ └─────────────────────────────────────────────────────────────────────┘ │\n│                                                                         │\n│ ┌─────────────────────────────────────────────────────────────────────┐ │\n│ │ Story: User can assign tasks to team members (3 pts)                │ │\n│ │ Status: Not Started                                                 │ │\n│ │ ─────────────────────────────────────────────────────────────────── │ │\n│ │ Tasks:                                                              │ │\n│ │ [ ] Add assignee field to Task model (Dev A, 2h)                    │ │\n│ │ [ ] Create user assignment dropdown component (Dev C, 4h)           │ │\n│ │ [ ] Implement assignment API (Dev B, 3h)                            │ │\n│ │ [ ] Add assignment notification (Dev A, 2h)                         │ │\n│ │ [ ] Write tests (QA, 2h)                                            │ │\n│ └─────────────────────────────────────────────────────────────────────┘ │\n│                                                                         │\n│ ┌─────────────────────────────────────────────────────────────────────┐ │\n│ │ Story: User can set due dates with reminders (5 pts)                │ │\n│ │ Status: Not Started                                                 │ │\n│ └─────────────────────────────────────────────────────────────────────┘ │\n│                                                                         │\n│ Sprint Capacity: 60 hours | Committed: 52 hours | Remaining: 38 hours   │\n└─────────────────────────────────────────────────────────────────────────┘\nIncrement\nThe Increment is the sum of all Product Backlog items completed during a sprint, plus all previous increments. It must be in usable condition—meeting the team’s Definition of Done—regardless of whether the Product Owner decides to release it.\nDefinition of Done (DoD)\nThe Definition of Done is a shared understanding of what “complete” means. It ensures transparency and quality.\nExample Definition of Done:\n\nCode complete and peer-reviewed\nUnit tests written and passing\nIntegration tests passing\nDocumentation updated\nNo known bugs\nMeets acceptance criteria\nDeployed to staging environment\nProduct Owner accepted\n\n\n\n6.2.4 Scrum Events\nScrum prescribes five events, each with a specific purpose. These events create regularity and minimize the need for ad-hoc meetings.\nThe Sprint\nThe Sprint is a container for all other events. It’s a fixed time-box (typically 2 weeks) during which the team works to deliver a potentially shippable increment.\nSprint Rules:\n\nFixed duration (don’t extend sprints)\nNo changes that endanger the Sprint Goal\nQuality standards don’t decrease\nScope may be clarified and renegotiated with Product Owner\nA new sprint begins immediately after the previous one ends\n\nSprint Planning\nSprint Planning kicks off the sprint. The team decides what to work on and how to accomplish it.\nDuration: Up to 8 hours for a one-month sprint (proportionally less for shorter sprints)\nPart 1: What can be done this sprint?\n\nProduct Owner presents top-priority items\nTeam discusses and asks clarifying questions\nTeam selects items they believe they can complete\nTeam crafts a Sprint Goal\n\nPart 2: How will the work be accomplished?\n\nTeam breaks selected items into tasks\nTeam estimates task effort\nTeam commits to the Sprint Backlog\n\nSprint Planning Agenda Example:\nSPRINT 3 PLANNING\n══════════════════════════════════════════════════════════════\n\nTime: Monday 9:00 AM - 1:00 PM (4 hours)\nAttendees: Full Scrum Team\n\nAGENDA\n──────\n\n9:00 - 9:15    Review Sprint 2 outcomes and current velocity\n               Previous velocity: 18 points\n               Capacity this sprint: Full team available\n\n9:15 - 10:30   PART 1: Select Sprint Backlog Items\n               • Product Owner presents priorities\n               • Team asks clarifying questions\n               • Team selects items (targeting ~18-20 points)\n\n10:30 - 10:45  Break\n\n10:45 - 11:15  Define Sprint Goal\n               • What business value will we deliver?\n               • How will we know we succeeded?\n\n11:15 - 12:45  PART 2: Plan the Work\n               • Break stories into tasks\n               • Identify dependencies\n               • Assign initial owners (optional)\n               • Identify risks and unknowns\n\n12:45 - 1:00   Confirm Commitment\n               • Review Sprint Backlog\n               • Team confirms they can commit\n               • Scrum Master confirms understanding\n\nOUTPUT\n──────\n• Sprint Goal: \"Users can create, edit, and manage basic tasks\"\n• Sprint Backlog: 5 stories, 18 points\n• Task breakdown for all stories\nDaily Scrum (Standup)\nThe Daily Scrum is a brief daily meeting for the Developers to synchronize and plan the day’s work.\nDuration: 15 minutes maximum Time: Same time and place every day Attendees: Developers (Scrum Master facilitates, Product Owner may attend)\nTraditional Format (Three Questions):\n\nWhat did I accomplish yesterday?\nWhat will I work on today?\nWhat obstacles are in my way?\n\nAlternative Format (Walking the Board):\n\nReview each item on the sprint board\nWhat’s needed to move it forward?\nWho’s working on what?\n\nDaily Scrum Best Practices:\nDO:\n\nStand up (keeps it short)\nStart on time, even if people are missing\nFocus on sprint goal progress\nIdentify blockers immediately\nKeep it under 15 minutes\n\nDON’T:\n\nGive detailed status reports\nSolve problems during standup (take offline)\nMake it a report to the Scrum Master\nSkip days\nLet it become a complaint session\n\nExample Daily Scrum:\nDAILY SCRUM - Tuesday 9:00 AM\n═════════════════════════════\n\nALICE:\n\"Yesterday I completed the task creation API. Today I'm starting \non the edit endpoint. No blockers.\"\n\nBOB:\n\"I'm still working on the task form component. Should finish \ntoday. I have a question about validation rules—I'll grab Sarah \nafter standup.\"\n\nCAROL:\n\"Finished unit tests for the model layer. Starting integration \ntests today. Blocked on needing access to the staging database—\ncan someone help?\"\n\nSCRUM MASTER:\n\"I'll get Carol database access right after this. Anything else? \nNo? Let's get to work.\"\n\nDuration: 4 minutes\nSprint Review\nThe Sprint Review is held at the end of the sprint to inspect the increment and adapt the Product Backlog.\nDuration: Up to 4 hours for a one-month sprint Attendees: Scrum Team plus invited stakeholders\nWhat happens:\n\nTeam demonstrates completed work\nStakeholders provide feedback\nProduct Owner discusses the backlog\nGroup collaborates on what to do next\nDiscussion of timeline, budget, and capabilities\n\nWhat it’s NOT:\n\nA formal presentation\nA sign-off meeting\nJust a demo (it’s interactive)\n\nSprint Review Agenda Example:\nSPRINT 3 REVIEW\n══════════════════════════════════════════════════════════════\n\nTime: Friday 2:00 PM - 3:30 PM\nAttendees: Scrum Team + Marketing Lead, Customer Success Lead\n\nAGENDA\n──────\n\n2:00 - 2:10    Welcome and Sprint Overview\n               • Sprint Goal: Core Task CRUD\n               • What we committed to vs. what we delivered\n\n2:10 - 2:45    Demo of Completed Work\n               • Task creation (Alice)\n               • Task editing (Bob)\n               • Task assignment (Carol)\n               • Due date setting (Alice)\n               \n               [Interactive—stakeholders can try features]\n\n2:45 - 3:00    Discussion and Feedback\n               • What do you like?\n               • What would you change?\n               • What questions do you have?\n\n3:00 - 3:15    Product Backlog Review\n               • What's coming next sprint?\n               • Any priority changes based on feedback?\n               • New items to add?\n\n3:15 - 3:30    Release Discussion\n               • Are we on track for beta launch?\n               • What risks do we see?\n\nOUTPUT\n──────\n• Feedback captured\n• Backlog updates identified\n• Stakeholder alignment\nSprint Retrospective\nThe Sprint Retrospective is held after the Sprint Review and before the next Sprint Planning. The team inspects how the sprint went and identifies improvements.\nDuration: Up to 3 hours for a one-month sprint Attendees: Scrum Team only (safe space for candid discussion)\nPurpose:\n\nInspect the last sprint (people, relationships, process, tools)\nIdentify what went well\nIdentify what could be improved\nCreate a plan for implementing improvements\n\nRetrospective Formats:\nStart-Stop-Continue:\n\nWhat should we START doing?\nWhat should we STOP doing?\nWhat should we CONTINUE doing?\n\nGlad-Sad-Mad:\n\nWhat made us GLAD?\nWhat made us SAD?\nWhat made us MAD?\n\n4Ls:\n\nWhat did we LIKE?\nWhat did we LEARN?\nWhat did we LACK?\nWhat do we LONG FOR?\n\nSailboat:\n         🏝️ Island (Goals)\n            │\n            │\n   ⛵ Boat (Team)\n     │\n     │\n  ⚓ Anchor (What slows us down)\n     │\n  🌬️ Wind (What propels us forward)\n     │\n  🪨 Rocks (Risks ahead)\nExample Retrospective Output:\nSPRINT 3 RETROSPECTIVE\n══════════════════════════════════════════════════════════════\n\nWHAT WENT WELL\n──────────────\n• Completed all committed stories\n• Great collaboration between frontend and backend\n• New testing approach caught bugs early\n• Stakeholder feedback was very positive\n\nWHAT COULD BE IMPROVED\n──────────────────────\n• Sprint planning ran long (5 hours instead of 4)\n• Two stories had unclear acceptance criteria\n• Staging environment was unstable\n• Daily standups started late several times\n\nACTION ITEMS\n────────────\n1. [HIGH] Refine stories before sprint planning\n   Owner: Product Owner\n   Due: Before Sprint 4 planning\n   \n2. [MEDIUM] Set up staging environment monitoring\n   Owner: Carol\n   Due: Sprint 4, Day 3\n   \n3. [LOW] Start standup alarm at 8:58 AM\n   Owner: Scrum Master\n   Due: Immediately\n\n\n6.2.5 Sprint Metrics\nVelocity\nVelocity is the amount of work a team completes in a sprint, measured in story points. It’s used for planning future sprints.\nSprint History:\nSprint 1: 15 points\nSprint 2: 18 points\nSprint 3: 21 points\nSprint 4: 16 points\nSprint 5: 20 points\n\nAverage Velocity: 18 points\nImportant: Velocity is a planning tool, not a performance metric. Using velocity to compare teams or pressure teams to “increase velocity” undermines its usefulness.\nBurndown Chart\nA burndown chart shows work remaining versus time. It helps visualize sprint progress.\nStory Points\nRemaining\n    │\n 20 │●\n    │ ╲  - - - - - - - - - - - - Ideal Burndown\n 15 │  ╲ ●\n    │   ╲  ●\n 10 │    ╲   ●\n    │     ╲    ●●\n  5 │      ╲     ╲●\n    │       ╲      ●\n  0 │────────╲───────●─────────────\n    └────┬────┬────┬────┬────┬────┬─ Days\n         1    2    3    4    5    6\nIf actual burndown is above the ideal line, the team is behind. If below, they’re ahead.\nBurnup Chart\nA burnup chart shows cumulative work completed. It’s useful for seeing scope changes.\nStory Points\n    │                              ┌─ Scope (may change)\n 50 │─────────────────────────────●┘\n    │                         ●●●\n 40 │                    ●●●●\n    │               ●●●●\n 30 │          ●●●●\n    │     ●●●●\n 20 │●●●●\n    │\n 10 │\n    │\n  0 │────────────────────────────────\n    └────┬────┬────┬────┬────┬────┬─ Days\n         1    2    3    4    5    6",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#kanban-continuous-flow",
    "href": "chapters/06-agile-methodologies.html#kanban-continuous-flow",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.4 6.3 Kanban: Continuous Flow",
    "text": "9.4 6.3 Kanban: Continuous Flow\nWhile Scrum organizes work into sprints, Kanban focuses on continuous flow. Originating from Toyota’s manufacturing system, Kanban was adapted for software development by David Anderson in the mid-2000s.\n\n6.3.1 Kanban Principles\nKanban is built on four foundational principles:\n1. Start with what you do now\nKanban doesn’t prescribe roles, ceremonies, or artifacts. It overlays on your existing process to make it visible and improve it incrementally.\n2. Agree to pursue incremental, evolutionary change\nRather than wholesale transformation, Kanban favors small, continuous improvements. This reduces resistance and risk.\n3. Respect the current process, roles, and responsibilities\nDon’t throw everything out. Preserve what works while improving what doesn’t.\n4. Encourage acts of leadership at all levels\nImprovement ideas can come from anywhere. Empower everyone to identify and implement improvements.\n\n\n6.3.2 Kanban Practices\n1. Visualize the Workflow\nMake work visible using a Kanban board. Each column represents a stage in your workflow.\n┌─────────────────────────────────────────────────────────────────────────┐\n│                           KANBAN BOARD                                  │\n├────────────┬────────────┬────────────┬────────────┬────────────────────┤\n│  Backlog   │    To Do   │In Progress │   Review   │       Done         │\n│            │            │            │            │                    │\n│ ┌────────┐ │ ┌────────┐ │ ┌────────┐ │ ┌────────┐ │ ┌────────┐        │\n│ │Task 8  │ │ │Task 5  │ │ │Task 3  │ │ │Task 1  │ │ │Task A  │        │\n│ │        │ │ │        │ │ │ Alice  │ │ │ Carol  │ │ └────────┘        │\n│ └────────┘ │ └────────┘ │ └────────┘ │ └────────┘ │                    │\n│ ┌────────┐ │ ┌────────┐ │ ┌────────┐ │            │ ┌────────┐        │\n│ │Task 9  │ │ │Task 6  │ │ │Task 4  │ │            │ │Task B  │        │\n│ │        │ │ │        │ │ │  Bob   │ │            │ └────────┘        │\n│ └────────┘ │ └────────┘ │ └────────┘ │            │                    │\n│ ┌────────┐ │            │            │            │ ┌────────┐        │\n│ │Task 10 │ │            │            │            │ │Task C  │        │\n│ │        │ │            │            │            │ └────────┘        │\n│ └────────┘ │            │            │            │                    │\n│            │            │            │            │                    │\n│    (∞)     │    (3)     │    (3)     │    (2)     │       (∞)         │\n│            │            │            │            │                    │\n└────────────┴────────────┴────────────┴────────────┴────────────────────┘\n                    WIP Limits shown in parentheses\n2. Limit Work in Progress (WIP)\nWIP limits cap how many items can be in each stage simultaneously. This prevents overload and improves flow.\nWhy WIP limits matter:\n\nReduces context switching\nExposes bottlenecks\nEncourages finishing before starting\nImproves cycle time\nIncreases focus\n\nWithout WIP Limits:              With WIP Limits:\n──────────────────────           ──────────────────────\n\nIn Progress: 12 items            In Progress: 3 items (Limit: 3)\n• Many half-finished             • Fewer items, more focus\n• Lots of context switching      • Items finish faster\n• Nothing actually finishing     • Problems visible immediately\n• Problems hidden in pile        • Team swarms to unblock\n3. Manage Flow\nMonitor and optimize the flow of work through the system. Track metrics, identify bottlenecks, and make improvements.\n4. Make Policies Explicit\nDocument the rules governing how work flows through the system:\n\nDefinition of Ready (when can work enter a column?)\nDefinition of Done (when can work leave a column?)\nWIP limits\nPrioritization rules\nBlocked item policies\n\n5. Implement Feedback Loops\nRegular cadences for review and adaptation:\n\nDaily standups\nReplenishment meetings (add work to board)\nDelivery planning\nService delivery review\nOperations review\nRisk review\nStrategy review\n\n6. Improve Collaboratively, Evolve Experimentally\nUse the scientific method:\n\nObserve current state\nForm hypotheses about improvements\nExperiment with changes\nMeasure results\nAdopt what works\n\n\n\n6.3.3 Kanban Board Design\nColumns should reflect your actual workflow. Common patterns:\nSimple Board:\nBacklog → In Progress → Done\nDevelopment Board:\nBacklog → Ready → Development → Code Review → Testing → Done\nBoard with Explicit Buffer:\nBacklog → Ready → Development → Dev Done → Testing → Done\n         \n         (Buffer between development and testing)\nBoard with Swimlanes:\n┌─────────────────────────────────────────────────────────────┐\n│         │ To Do │ In Progress │ Review │ Done │            │\n├─────────┼───────┼─────────────┼────────┼──────┤            │\n│ Urgent  │ ▢ ▢   │     ▢       │   ▢    │  ▢   │ ← Priority │\n│─────────┼───────┼─────────────┼────────┼──────┤   Lanes    │\n│ Normal  │ ▢ ▢ ▢ │    ▢ ▢      │   ▢    │ ▢ ▢  │            │\n│─────────┼───────┼─────────────┼────────┼──────┤            │\n│ Low     │ ▢ ▢   │             │        │  ▢   │            │\n└─────────┴───────┴─────────────┴────────┴──────┘\n\n\n6.3.4 Kanban Metrics\nCycle Time\nCycle time is how long an item takes from start to finish—the time between “work started” and “work completed.”\nTask A: Started Monday 9 AM → Completed Wednesday 4 PM\nCycle Time: 2.3 days\n\nAverage Cycle Time: Sum of all cycle times / Number of items\nLower cycle time means faster delivery. Track cycle time over time to measure improvement.\nLead Time\nLead time is the total time from request to delivery—including time waiting in the backlog.\nRequest ──────► Start ──────────────► Complete\n│←────── Lead Time (total) ─────────────────►│\n              │←── Cycle Time ────────►│\nThroughput\nThroughput is the number of items completed in a given time period.\nWeek 1: 12 items completed\nWeek 2: 15 items completed\nWeek 3: 11 items completed\n\nAverage Throughput: 12.7 items/week\nCumulative Flow Diagram (CFD)\nA CFD shows the quantity of items in each state over time. It reveals bottlenecks and flow problems.\nItems\n    │\n 50 │████████████████████████████████████ Done\n    │████████████████████████████\n 40 │███████████████████████████████████ Review\n    │██████████████████████████\n 30 │████████████████████████████████ In Progress\n    │██████████████████████████\n 20 │█████████████████████████████ To Do\n    │█████████████████████\n 10 │████████████████████████ Backlog\n    │█████████████████\n  0 │─────────────────────────────────────\n    └────┬────┬────┬────┬────┬────┬────┬─ Weeks\n         1    2    3    4    5    6    7\nThe vertical distance between bands represents WIP. The horizontal distance represents cycle time. Widening bands indicate bottlenecks.\n\n\n6.3.5 Scrum vs. Kanban\n\n\n\n\n\n\n\n\nAspect\nScrum\nKanban\n\n\n\n\nCadence\nFixed sprints (1-4 weeks)\nContinuous flow\n\n\nRoles\nProduct Owner, Scrum Master, Developers\nNo prescribed roles\n\n\nPlanning\nSprint Planning at start of sprint\nContinuous (just-in-time)\n\n\nChange\nNo changes during sprint\nChange anytime\n\n\nMetrics\nVelocity, Burndown\nCycle time, Throughput\n\n\nCommitment\nSprint backlog commitment\nNo commitment beyond WIP\n\n\nBest for\nProduct development, cross-functional teams\nOperations, maintenance, varied work\n\n\n\nScrumban:\nMany teams combine elements of both:\n\nKanban board with visualized flow\nWIP limits\nSprint cadence for planning and review\nRetrospectives for improvement",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#extreme-programming-xp",
    "href": "chapters/06-agile-methodologies.html#extreme-programming-xp",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.5 6.4 Extreme Programming (XP)",
    "text": "9.5 6.4 Extreme Programming (XP)\nExtreme Programming (XP) is an Agile methodology that emphasizes technical excellence and team practices. Created by Kent Beck in the late 1990s, XP “turns the dials to 10” on good software practices.\n\n6.4.1 XP Values\nCommunication: Team members communicate face-to-face frequently. Problems are surfaced immediately. Knowledge is shared, not hoarded.\nSimplicity: Do the simplest thing that could possibly work. Don’t build for requirements you don’t have yet. Simplify code through refactoring.\nFeedback: Get feedback quickly and often. Short iterations, continuous integration, pair programming, and customer involvement all provide rapid feedback.\nCourage: Make difficult decisions. Refactor mercilessly. Throw away code that doesn’t work. Tell customers the truth about estimates.\nRespect: Team members respect each other’s contributions. Everyone’s input matters. People are not resources.\n\n\n6.4.2 XP Practices\nXP defines twelve practices organized into four categories:\nFine-Scale Feedback:\nPair Programming: Two developers work together at one workstation. One “drives” (types), the other “navigates” (reviews). Pairs switch frequently. Benefits include knowledge sharing, better design, and fewer bugs.\nPlanning Game: Customers and developers collaborate on release and iteration planning. Customers define features; developers estimate. Simple, cards-based planning.\nTest-Driven Development (TDD): Write a failing test before writing code. Write just enough code to pass the test. Refactor. Repeat. This produces well-tested, well-designed code.\nWhole Team: The customer (or customer representative) is part of the team, available daily to answer questions, provide feedback, and make decisions.\nContinuous Process:\nContinuous Integration: Developers integrate code frequently (multiple times per day). Each integration is verified by automated tests. This catches problems early and keeps the codebase stable.\nRefactoring: Continuously improve code structure without changing behavior. Remove duplication. Improve clarity. Keep the codebase healthy.\nSmall Releases: Release small increments frequently. This provides feedback, delivers value early, and reduces risk.\nShared Understanding:\nCoding Standards: The team agrees on coding conventions and follows them. Anyone can work on any code. The codebase looks like one person wrote it.\nCollective Code Ownership: Anyone can modify any code. This spreads knowledge and enables flexibility. Code reviews and pair programming support this.\nSimple Design: Design for current requirements, not imagined future needs. The simplest design is easiest to understand, test, and modify.\nSystem Metaphor: A shared story of how the system works. A metaphor helps the team communicate and reason about the system consistently.\nDeveloper Welfare:\nSustainable Pace: Work at a pace you can maintain indefinitely. No death marches. Tired developers make mistakes and burn out.\n\n\n6.4.3 The TDD Cycle\nTest-Driven Development follows a simple cycle:\n        ┌────────────────────────┐\n        │                        │\n        │    1. RED              │\n        │    Write a failing     │\n        │    test                │\n        │                        │\n        └───────────┬────────────┘\n                    │\n                    ▼\n        ┌────────────────────────┐\n        │                        │\n        │    2. GREEN            │\n        │    Write code to       │\n        │    pass the test       │\n        │                        │\n        └───────────┬────────────┘\n                    │\n                    ▼\n        ┌────────────────────────┐\n        │                        │\n        │    3. REFACTOR         │◄────────┐\n        │    Improve the code    │         │\n        │    (tests still pass)  │         │\n        │                        │         │\n        └───────────┬────────────┘         │\n                    │                      │\n                    └──────────────────────┘\nExample TDD Session:\n# Step 1: RED - Write a failing test\ndef test_calculate_total_for_empty_cart():\n    cart = ShoppingCart()\n    assert cart.calculate_total() == 0\n\n# Run tests: FAIL - ShoppingCart doesn't exist\n\n# Step 2: GREEN - Write minimal code to pass\nclass ShoppingCart:\n    def calculate_total(self):\n        return 0\n\n# Run tests: PASS\n\n# Step 3: REFACTOR - Nothing to refactor yet\n\n# Step 1: RED - Write next failing test\ndef test_calculate_total_for_single_item():\n    cart = ShoppingCart()\n    cart.add_item(Product(\"Widget\", 9.99), quantity=1)\n    assert cart.calculate_total() == 9.99\n\n# Run tests: FAIL - add_item doesn't exist\n\n# Step 2: GREEN - Write code to pass\nclass ShoppingCart:\n    def __init__(self):\n        self.items = []\n    \n    def add_item(self, product, quantity):\n        self.items.append((product, quantity))\n    \n    def calculate_total(self):\n        return sum(product.price * qty for product, qty in self.items)\n\n# Run tests: PASS\n\n# Continue cycle...\n\n\n6.4.4 When to Use XP Practices\nNot all XP practices are appropriate for all situations:\n\n\n\n\n\n\n\n\nPractice\nHigh Value When…\nLess Valuable When…\n\n\n\n\nPair Programming\nComplex problems, knowledge transfer needed, quality critical\nSimple tasks, team very experienced, remote-only team\n\n\nTDD\nNew code, complex logic, long-lived codebase\nPrototypes, UI-heavy work, exploratory work\n\n\nContinuous Integration\nMultiple developers, frequent changes\nSolo developer, stable codebase\n\n\nRefactoring\nGrowing codebase, changing requirements\nThrowaway code, frozen requirements\n\n\nCollective Ownership\nCross-functional teams, bus factor concerns\nSpecialized expertise areas",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#estimation-story-points-and-planning",
    "href": "chapters/06-agile-methodologies.html#estimation-story-points-and-planning",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.6 6.5 Estimation: Story Points and Planning",
    "text": "9.6 6.5 Estimation: Story Points and Planning\nEstimation is notoriously difficult in software development. How long will a feature take? It depends on countless factors, many unknown at estimation time. Agile approaches estimation differently—focusing on relative sizing rather than absolute time predictions.\n\n6.5.1 Why Traditional Estimation Fails\nTraditional estimation asks: “How many hours/days will this take?” This approach fails because:\nUncertainty: Early in a project, we don’t know enough to estimate precisely. Later, we know more but have less flexibility.\nAnchoring: Once someone states an estimate, others anchor to it. The first number biases all subsequent discussion.\nPressure: Estimates become commitments, then deadlines. Teams pad estimates defensively or face blame when reality differs from prediction.\nIndividual variation: A task that takes Alice two hours might take Bob eight. Whose estimate do we use?\nHidden complexity: Software has unknown unknowns. We discover complexity during implementation, not during estimation.\n\n\n6.5.2 Story Points\nStory points are a relative measure of effort, complexity, and uncertainty. Rather than estimating in hours, teams assign point values that represent how “big” a story is relative to other stories.\nKey Characteristics:\n\nRelative, not absolute: “Story A is about twice as big as Story B”\nTeam-specific: Points aren’t comparable across teams\nInclude uncertainty: Bigger point values include higher uncertainty\nNot tied to time: A 2-point story doesn’t mean 2 hours or 2 days\n\nThe Fibonacci Sequence:\nMost teams use a modified Fibonacci sequence for point values:\n1, 2, 3, 5, 8, 13, 21, (40, 100)\nWhy Fibonacci? The gaps between numbers grow larger at higher values, reflecting the increasing uncertainty of larger work items. You can reasonably distinguish a 2-point story from a 3-point story, but distinguishing 21 points from 22 points is meaningless.\nReference Story:\nTeams establish a reference story—a well-understood, medium-sized piece of work assigned a middle value (often 3 or 5 points). All other stories are sized relative to this reference.\nReference: \"User can log in with email/password\" = 3 points\n\nNow estimate:\n• \"User can reset password via email\" → Similar complexity → 3 points\n• \"User can view their profile\" → Simpler → 2 points\n• \"User can upload profile photo\" → More complex (file handling) → 5 points\n• \"User can log in with SSO (Google, Microsoft)\" → Much more complex → 8 points\n\n\n6.5.3 Planning Poker\nPlanning Poker is a consensus-based estimation technique that avoids anchoring and encourages discussion.\nHow It Works:\n\nEach team member has cards with point values (1, 2, 3, 5, 8, 13, 21, ?)\nThe Product Owner presents a story\nTeam asks clarifying questions\nEveryone simultaneously reveals their estimate\nIf estimates differ significantly, discuss and re-estimate\nRepeat until consensus\n\nPLANNING POKER SESSION\n══════════════════════════════════════════════════════════════\n\nStory: \"User can filter tasks by status, assignee, and due date\"\n\nRound 1:\nAlice: 5    Bob: 8    Carol: 8    Dave: 5    Eve: 13\n\nDiscussion:\nEve: \"I'm thinking about the complexity of combining multiple filters\"\nAlice: \"I assumed we'd reuse our existing filter component\"\nBob: \"Good point, but we need new database queries for each filter type\"\nEve: \"Oh, if we're reusing components, that does simplify things\"\n\nRound 2:\nAlice: 5    Bob: 8    Carol: 5    Dave: 5    Eve: 8\n\nDiscussion:\nCarol: \"Changed my mind—filter component does help\"\nBob: \"I'm still at 8 because of the query complexity\"\n\nFinal: Team agrees on 8 (erring toward higher due to query work)\nPlanning Poker Benefits:\n\nEveryone participates\nNo anchoring (simultaneous reveal)\nDifferences trigger valuable discussions\nBuilds shared understanding\nFun and engaging\n\n\n\n6.5.4 Velocity and Capacity Planning\nVelocity is the average number of story points a team completes per sprint. It’s calculated from historical data.\nSprint 1: 21 points completed\nSprint 2: 18 points completed\nSprint 3: 24 points completed\nSprint 4: 20 points completed\nSprint 5: 22 points completed\n\nAverage Velocity: 21 points per sprint\nUsing Velocity for Planning:\nIf average velocity is 21 points, the team should plan for approximately 21 points next sprint. Some teams use a range:\n\nPessimistic: 18 points (worst recent sprint)\nExpected: 21 points (average)\nOptimistic: 24 points (best recent sprint)\n\nVelocity Adjustments:\nAdjust for known factors:\n\nTeam member on vacation: Reduce proportionally\nNew team member: Expect lower velocity initially\nTechnical debt paydown sprint: Reduce feature velocity\n\nImportant Cautions:\n\nDon’t compare velocity across teams (points aren’t standardized)\nDon’t use velocity as a performance metric (teams will game it)\nVelocity stabilizes after 3-5 sprints; early sprints are unreliable\nChanging team composition resets velocity\n\n\n\n6.5.5 Estimation Alternatives\nSome teams abandon points entirely:\nStory Counting:\nIf stories are consistently small (well-refined), just count them. “We complete about 8 stories per sprint.” This works when stories are similar in size.\nT-Shirt Sizing:\nUse qualitative sizes: XS, S, M, L, XL. Simpler than points but still enables relative comparison. Often converted to points for tracking:\nXS = 1 point\nS  = 2 points\nM  = 5 points\nL  = 8 points\nXL = 13 points (should probably be split)\n#NoEstimates:\nSome teams avoid estimation entirely, focusing instead on:\n\nBreaking work into small, similarly-sized pieces\nCounting completed items\nUsing cycle time for forecasting\n\nThis works best with mature teams and well-refined backlogs.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#project-management-tools",
    "href": "chapters/06-agile-methodologies.html#project-management-tools",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.7 6.6 Project Management Tools",
    "text": "9.7 6.6 Project Management Tools\nModern project management tools support Agile workflows with digital boards, backlog management, and reporting.\n\n6.6.1 GitHub Projects\nGitHub Projects provides project management directly integrated with GitHub’s issues and pull requests.\nSetting Up a GitHub Project:\n\nNavigate to your repository (or organization)\nClick “Projects” tab → “New Project”\nChoose a template (Board, Table, or Roadmap)\nCustomize columns to match your workflow\n\nBoard View:\n┌─────────────────────────────────────────────────────────────────────────┐\n│ TaskFlow Development                                        + Add view  │\n├────────────────┬────────────────┬────────────────┬────────────────┬─────┤\n│   📋 Backlog   │   🎯 Ready     │   🔄 In Progress│   👀 Review   │ ✅  │\n│                │                │                 │               │Done │\n├────────────────┼────────────────┼────────────────┼────────────────┼─────┤\n│ #23 SSO Login  │ #18 Password   │ #15 Task CRUD  │ #12 User      │#10  │\n│ enhancement    │ reset          │ @alice         │ profiles      │#8   │\n│                │ 3 points       │ 5 points       │ @carol        │#7   │\n│ #24 File       │                │                │ 3 points      │#5   │\n│ attachments    │ #19 Due date   │ #16 Task       │               │#3   │\n│                │ reminders      │ assignment     │               │#1   │\n│ #25 Calendar   │ 5 points       │ @bob           │               │     │\n│ integration    │                │ 3 points       │               │     │\n│                │                │                │               │     │\n│ + Add item     │ + Add item     │ + Add item     │ + Add item    │     │\n└────────────────┴────────────────┴────────────────┴────────────────┴─────┘\nTable View:\n┌──────────────────────────────────────────────────────────────────────────┐\n│ Title                │ Status      │ Assignee │ Points │ Sprint │ Labels │\n├──────────────────────┼─────────────┼──────────┼────────┼────────┼────────┤\n│ Task CRUD            │ In Progress │ @alice   │ 5      │ Sprint3│ feature│\n│ Task assignment      │ In Progress │ @bob     │ 3      │ Sprint3│ feature│\n│ User profiles        │ Review      │ @carol   │ 3      │ Sprint3│ feature│\n│ Password reset       │ Ready       │ -        │ 3      │ Sprint3│ feature│\n│ Due date reminders   │ Ready       │ -        │ 5      │ Sprint3│ feature│\n│ SSO Login            │ Backlog     │ -        │ 8      │ -      │ feature│\n│ File attachments     │ Backlog     │ -        │ 8      │ -      │ feature│\n└──────────────────────┴─────────────┴──────────┴────────┴────────┴────────┘\nGitHub Projects Features:\n\nCustom Fields: Add story points, sprints, priorities\nAutomation: Auto-move items when issues close or PRs merge\nFiltering: Filter by assignee, label, milestone, custom fields\nGrouping: Group items by sprint, assignee, or status\nIterations: Track sprint cycles\nInsights: Burnup charts and progress tracking\n\nConnecting Issues to Projects:\n# Issue Template Example\n\n## User Story\nAs a [user type], I want to [action] so that [benefit].\n\n## Acceptance Criteria\n- [ ] Criterion 1\n- [ ] Criterion 2\n- [ ] Criterion 3\n\n## Technical Notes\n- Relevant implementation details\n\n## Story Points: 5\n## Sprint: Sprint 3\n\n\n6.6.2 Jira\nJira is the most widely used Agile project management tool, especially in enterprise environments.\nKey Jira Concepts:\n\nProject: Container for all issues related to a product or initiative\nIssue Types: Story, Bug, Task, Epic, Subtask\nWorkflow: States and transitions (To Do → In Progress → Done)\nBoard: Scrum or Kanban visualization\nSprint: Time-boxed iteration (Scrum)\nBacklog: Ordered list of work items\n\nJira Board Example:\n┌─────────────────────────────────────────────────────────────────────────┐\n│ TASKFLOW SPRINT 3                              Sprint ends in 5 days    │\n├────────────────┬────────────────┬────────────────┬─────────────────────┤\n│   TO DO (5)    │IN PROGRESS (3) │  IN REVIEW (1) │      DONE (4)       │\n├────────────────┼────────────────┼────────────────┼─────────────────────┤\n│                │                │                │                     │\n│ ┌────────────┐ │ ┌────────────┐ │ ┌────────────┐ │ ┌────────────┐      │\n│ │📘 TASK-45  │ │ │📘 TASK-42  │ │ │📘 TASK-40  │ │ │📘 TASK-38  │      │\n│ │Filter UI   │ │ │Due dates   │ │ │User profile│ │ │Login page  │      │\n│ │           ◇│ │ │Alice    ◇◇│ │ │Carol    ◇◇◇│ │ │Done     ◇◇│      │\n│ └────────────┘ │ └────────────┘ │ └────────────┘ │ └────────────┘      │\n│                │                │                │                     │\n│ ┌────────────┐ │ ┌────────────┐ │                │ ┌────────────┐      │\n│ │🐛 TASK-46  │ │ │📘 TASK-43  │ │                │ │📘 TASK-39  │      │\n│ │Date bug    │ │ │Assignments │ │                │ │Task model  │      │\n│ │        🔥◇│ │ │Bob      ◇◇│ │                │ │Done     ◇◇│      │\n│ └────────────┘ │ └────────────┘ │                │ └────────────┘      │\n│                │                │                │                     │\n│ ┌────────────┐ │ ┌────────────┐ │                │ ┌────────────┐      │\n│ │📘 TASK-47  │ │ │📘 TASK-44  │ │                │ │📘 TASK-41  │      │\n│ │Sort tasks  │ │ │Task CRUD   │ │                │ │DB schema   │      │\n│ │           ◇│ │ │Dave     ◇◇│ │                │ │Done      ◇│      │\n│ └────────────┘ │ └────────────┘ │                │ └────────────┘      │\n│                │                │                │                     │\n└────────────────┴────────────────┴────────────────┴─────────────────────┘\n\n◇ = Story Point    🔥 = High Priority    📘 = Story    🐛 = Bug\nJira Reports:\n\nBurndown Chart: Work remaining vs. time\nVelocity Chart: Points completed per sprint\nSprint Report: Summary of sprint completion\nCumulative Flow: Work in each state over time\nControl Chart: Cycle time analysis\n\n\n\n6.6.3 Other Tools\nTrello: Simple, visual board-based tool. Good for small teams and simple workflows. Less feature-rich than Jira but easier to learn.\nAsana: Task and project management with multiple views (list, board, timeline, calendar). Good for cross-functional teams.\nLinear: Modern, fast issue tracking built for software teams. Keyboard-driven, GitHub integration, clean interface.\nAzure DevOps: Microsoft’s integrated platform including boards, repos, pipelines, and test plans. Good for Microsoft-ecosystem teams.\nNotion: Flexible workspace that can be configured for project management. Good for teams wanting to combine docs and project tracking.\nChoosing a Tool:\n\n\n\n\n\n\n\nFactor\nConsider…\n\n\n\n\nTeam size\nSimple tools for small teams; robust tools for large\n\n\nIntegration needs\nGitHub integration, CI/CD, communication tools\n\n\nComplexity\nSimple workflows → simple tools; complex → robust tools\n\n\nBudget\nFree tiers vary; enterprise features cost money\n\n\nLearning curve\nTime available for training\n\n\nReporting needs\nBasic → simple tools; detailed metrics → robust tools\n\n\n\nFor student projects, GitHub Projects is often sufficient and integrates naturally with your code repository.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#breaking-down-work-epics-stories-and-tasks",
    "href": "chapters/06-agile-methodologies.html#breaking-down-work-epics-stories-and-tasks",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.8 6.7 Breaking Down Work: Epics, Stories, and Tasks",
    "text": "9.8 6.7 Breaking Down Work: Epics, Stories, and Tasks\nEffective Agile teams break work into appropriately sized pieces. The hierarchy typically flows from large (Epics) to small (Tasks).\n\n6.7.1 The Work Hierarchy\n┌─────────────────────────────────────────────────────────────────────────┐\n│                                                                         │\n│    INITIATIVE / THEME                                                   │\n│    \"Improve user engagement\"                                            │\n│    (Strategic goal, spans multiple releases)                            │\n│                                                                         │\n│    └──► EPIC                                                            │\n│         \"User Task Management\"                                          │\n│         (Large feature, spans multiple sprints)                         │\n│                                                                         │\n│         └──► USER STORY                                                 │\n│              \"User can create tasks\"                                    │\n│              (Deliverable value, completable in one sprint)             │\n│                                                                         │\n│              └──► TASK                                                  │\n│                   \"Implement create task API endpoint\"                  │\n│                   (Technical work, hours to complete)                   │\n│                                                                         │\n│                   └──► SUBTASK                                          │\n│                        \"Write unit tests for validation\"                │\n│                        (Small piece of a task)                          │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n\n\n6.7.2 Epics\nEpics are large bodies of work that span multiple sprints. They’re too big to complete in one iteration and must be broken down into smaller stories.\nCharacteristics:\n\nTakes weeks or months to complete\nIncludes multiple user stories\nMay span multiple teams\nRepresents a significant feature or capability\n\nExample Epics:\nEPIC: User Authentication System\n├── Story: User can register with email/password\n├── Story: User can log in with credentials\n├── Story: User can reset forgotten password\n├── Story: User can update password\n├── Story: Admin can manage user accounts\n├── Story: User can log in with Google SSO\n└── Story: User can enable two-factor authentication\n\nEPIC: Task Management\n├── Story: User can create tasks\n├── Story: User can edit tasks\n├── Story: User can delete tasks\n├── Story: User can assign tasks to team members\n├── Story: User can set due dates\n├── Story: User can add labels to tasks\n├── Story: User can set task priority\n└── Story: User can add comments to tasks\n\n\n6.7.3 User Stories (Review)\nAs covered in Chapter 2, user stories follow the format:\n\nAs a [type of user], I want [capability] so that [benefit].\n\nWell-Sized Stories:\nStories should be small enough to complete in one sprint—ideally in a few days. The INVEST criteria guide good stories:\n\nIndependent\nNegotiable\nValuable\nEstimable\nSmall\nTestable\n\nSplitting Large Stories:\nWhen a story is too large, split it using these patterns:\nBy workflow step:\nOriginal: User can purchase a product\n\nSplit into:\n• User can add items to cart\n• User can view cart\n• User can enter shipping address\n• User can enter payment information\n• User can review and confirm order\nBy business rule:\nOriginal: User can search for products\n\nSplit into:\n• User can search by product name\n• User can search by category\n• User can filter by price range\n• User can sort search results\nBy data variation:\nOriginal: User can log in\n\nSplit into:\n• User can log in with email/password\n• User can log in with Google\n• User can log in with Microsoft\nBy operation (CRUD):\nOriginal: User can manage tasks\n\nSplit into:\n• User can create tasks\n• User can view tasks\n• User can edit tasks\n• User can delete tasks\nBy user type:\nOriginal: User can view reports\n\nSplit into:\n• Team member can view their own reports\n• Manager can view team reports\n• Admin can view all reports\n\n\n6.7.4 Tasks\nTasks are the technical activities required to complete a story. Unlike stories, tasks describe how rather than what.\nCharacteristics:\n\nEstimated in hours (typically 1-8 hours)\nAssigned to individuals\nTechnical in nature\nNot directly valuable to users (stories are)\n\nExample Story with Tasks:\nSTORY: User can create tasks (5 points)\n\nTASKS:\n┌────────────────────────────────────────────────────────┬───────┬─────────┐\n│ Task                                                   │ Hours │ Assignee│\n├────────────────────────────────────────────────────────┼───────┼─────────┤\n│ Create Task database model and migration               │   2   │ Alice   │\n│ Implement CreateTask API endpoint                      │   4   │ Alice   │\n│ Write API endpoint validation                          │   2   │ Alice   │\n│ Create task creation form component                    │   4   │ Bob     │\n│ Implement form validation (client-side)                │   2   │ Bob     │\n│ Connect form to API                                    │   2   │ Bob     │\n│ Write unit tests for Task model                        │   2   │ Carol   │\n│ Write integration tests for API                        │   3   │ Carol   │\n│ Write E2E test for task creation flow                  │   2   │ Carol   │\n│ Update API documentation                               │   1   │ Alice   │\n├────────────────────────────────────────────────────────┼───────┼─────────┤\n│ TOTAL                                                  │  24   │         │\n└────────────────────────────────────────────────────────┴───────┴─────────┘\n\n\n6.7.5 Definition of Ready and Definition of Done\nDefinition of Ready (DoR):\nCriteria that must be met before a story enters a sprint:\nDEFINITION OF READY\n═══════════════════\n\nA story is Ready when:\n☑ Story is written in user story format\n☑ Acceptance criteria are defined\n☑ Story has been estimated\n☑ Dependencies are identified\n☑ UX designs are complete (if applicable)\n☑ Technical approach is understood\n☑ Story is small enough for one sprint\n☑ Product Owner is available to answer questions\nDefinition of Done (DoD):\nCriteria that must be met before a story is considered complete:\nDEFINITION OF DONE\n══════════════════\n\nA story is Done when:\n☑ All acceptance criteria are met\n☑ Code is written and committed\n☑ Code has been peer-reviewed\n☑ Unit tests are written and passing\n☑ Integration tests are passing\n☑ Documentation is updated\n☑ Code is deployed to staging\n☑ QA has verified the feature\n☑ Product Owner has accepted the work\n☑ No known bugs remain",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#running-effective-agile-meetings",
    "href": "chapters/06-agile-methodologies.html#running-effective-agile-meetings",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.9 6.8 Running Effective Agile Meetings",
    "text": "9.9 6.8 Running Effective Agile Meetings\nAgile meetings are collaborative working sessions, not status reports. Effectiveness depends on preparation, facilitation, and follow-through.\n\n6.8.1 Meeting Anti-Patterns\nThe Status Report Standup:\n❌ Each person reports to the Scrum Master\n❌ No interaction between team members\n❌ Runs long because people give detailed updates\n❌ Feels like micromanagement\nThe Endless Planning:\n❌ Goes hours over time-box\n❌ Debates implementation details\n❌ No clear outcome\n❌ Team disengages\nThe Blameful Retrospective:\n❌ Focus on who made mistakes\n❌ Defensive atmosphere\n❌ Same issues discussed repeatedly\n❌ No action items\n\n\n6.8.2 Facilitating Effective Standups\nStructure (15 minutes max):\nDAILY STANDUP FACILITATION\n══════════════════════════════════════════════════════════════\n\nBEFORE:\n• Start exactly on time\n• Stand up (keeps it short)\n• Face the board, not the Scrum Master\n\nDURING:\n• Walk the board right-to-left (focus on finishing)\n  OR each person answers three questions\n• Keep updates brief (30-60 seconds each)\n• Note blockers but don't solve them\n• Note discussions needed but defer them\n\nAFTER:\n• Immediately address blockers\n• Schedule follow-up discussions\n• Update the board\n\nFACILITATION TIPS:\n• \"Let's save that discussion for after standup\"\n• \"What's blocking this from moving forward?\"\n• \"Who can help with this today?\"\n• \"Let's keep moving—we can discuss offline\"\n\n\n6.8.3 Facilitating Effective Retrospectives\nStructure (1-2 hours):\nRETROSPECTIVE FACILITATION\n══════════════════════════════════════════════════════════════\n\n1. SET THE STAGE (5-10 min)\n   • Welcome, state purpose\n   • Review working agreements\n   • Check-in activity (how are people feeling?)\n\n2. GATHER DATA (15-20 min)\n   • What happened during the sprint?\n   • Use a retrospective format (Start/Stop/Continue, 4Ls, etc.)\n   • Silent brainstorming, then share\n\n3. GENERATE INSIGHTS (15-20 min)\n   • Why did these things happen?\n   • Group related items\n   • Identify patterns and root causes\n\n4. DECIDE WHAT TO DO (15-20 min)\n   • What specific actions will we take?\n   • Limit to 1-3 actions (more won't get done)\n   • Assign owners and due dates\n\n5. CLOSE (5-10 min)\n   • Summarize action items\n   • Appreciate the team\n   • Quick feedback on the retro itself\nExample Retrospective Flow:\nSPRINT 4 RETROSPECTIVE\n══════════════════════════════════════════════════════════════\n\nFORMAT: Sailboat\n\n         🏝️ Island (Our Goals)\n         \"Ship MVP by end of month\"\n            │\n            │\n   ⛵ Team (Current Position)\n     │\n     │\n  ⚓ Anchors (What's slowing us down?)\n     • Unclear requirements on 2 stories\n     • Staging environment unstable\n     • Too many meetings\n     │\n  🌬️ Wind (What's pushing us forward?)\n     • Great collaboration this sprint\n     • New CI pipeline saving time\n     • Customer feedback very helpful\n     │\n  🪨 Rocks (Risks ahead?)\n     • Key developer vacation next sprint\n     • Integration with payment system unknown\n\nACTION ITEMS:\n1. [Product Owner] Refine next sprint stories by Thursday\n2. [DevOps] Fix staging stability by Monday\n3. [Scrum Master] Audit meeting calendar, propose reductions\n\n\n6.8.4 Remote/Hybrid Agile\nMany teams now work remotely or hybrid. Agile practices need adaptation:\nRemote Standup Tips:\n\nVideo on (builds connection)\nUse a shared board everyone can see\nStrict time-keeping (easier to run long remotely)\nConsider async standups for distributed time zones\n\nRemote Retrospective Tips:\n\nUse digital whiteboarding tools (Miro, FigJam, MURAL)\nMore structure (harder to read the room remotely)\nBreakout rooms for small group discussions\nExtra attention to psychological safety\n\nAsync Standups:\nASYNC STANDUP (via Slack/Teams)\n══════════════════════════════════════════════════════════════\n\nPost by 9:30 AM local time:\n\n1. What did you complete yesterday?\n2. What are you working on today?\n3. Any blockers?\n\nExample:\n@alice: \n1. ✅ Completed Task CRUD API\n2. 📝 Starting task assignment feature\n3. 🚫 None\n\n@bob:\n1. ✅ Fixed date picker bug\n2. 📝 Working on form validation\n3. 🚫 Blocked: Need design clarification on error states\n\nThread replies for questions or offers to help.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#adapting-agile-to-your-context",
    "href": "chapters/06-agile-methodologies.html#adapting-agile-to-your-context",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.10 6.9 Adapting Agile to Your Context",
    "text": "9.10 6.9 Adapting Agile to Your Context\nAgile isn’t one-size-fits-all. Teams must adapt practices to their specific context.\n\n6.9.1 Team Size Considerations\nSolo Developer:\n\nKanban often works better than Scrum\nNo standups needed (but planning and review still valuable)\nPersonal Kanban board for visualization\nTime-boxed work sessions (Pomodoro)\n\nSmall Team (2-4):\n\nLighter ceremonies\nRoles may overlap (developer might also be Product Owner)\nSimple tools sufficient\nStand-ups can be very quick\n\nMedium Team (5-9):\n\nFull Scrum works well\nAll roles dedicated\nMore structure needed\nBetter tooling helpful\n\nLarge Team (10+):\n\nSplit into multiple teams\nNeed coordination mechanisms (Scrum of Scrums, scaled frameworks)\nMore formal processes\nRobust tooling essential\n\n\n\n6.9.2 Project Type Considerations\nNew Product Development:\n\nHigh uncertainty → Scrum’s iterative approach\nFrequent pivots → Short sprints\nHeavy user involvement\n\nMaintenance/Operations:\n\nContinuous flow → Kanban\nUnpredictable work → WIP limits\nMix of planned and unplanned work\n\nFixed-Deadline Projects:\n\nRelease planning critical\nVelocity tracking for forecasting\nScope management key\n\nResearch/Experimental:\n\nTime-boxed experiments (spikes)\nHigh uncertainty acknowledgment\nLearning over delivery\n\n\n\n6.9.3 Scaling Agile\nWhen multiple teams work on the same product, coordination frameworks help:\nScrum of Scrums:\n\nRepresentatives from each team meet daily/weekly\nShare progress, dependencies, and blockers\nCoordinate across teams\n\nSAFe (Scaled Agile Framework):\n\nComprehensive scaling framework\nProgram Increments (8-12 weeks)\nMultiple teams, roles, and ceremonies\nWorks for very large organizations\n\nLeSS (Large-Scale Scrum):\n\nMinimal additional process\nMultiple teams, one Product Backlog\nShared Sprint Review and Retrospective\n\nSpotify Model:\n\nSquads (small teams)\nTribes (groups of related squads)\nChapters (people with same skills across squads)\nGuilds (communities of interest)\n\nFor most student projects, scaling isn’t needed. Focus on core Agile practices first.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#chapter-summary",
    "href": "chapters/06-agile-methodologies.html#chapter-summary",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.11 6.10 Chapter Summary",
    "text": "9.11 6.10 Chapter Summary\nAgile methodologies revolutionized software development by embracing change, valuing people, and delivering working software frequently. Understanding these practices is essential for modern software engineers.\nKey takeaways from this chapter:\n\nThe Agile Manifesto established values prioritizing individuals, working software, collaboration, and responding to change. These values guide all Agile practices.\nScrum is a framework with defined roles (Product Owner, Scrum Master, Developers), events (Sprint Planning, Daily Scrum, Sprint Review, Retrospective), and artifacts (Product Backlog, Sprint Backlog, Increment).\nKanban focuses on visualizing work, limiting work in progress, and optimizing flow. It’s less prescriptive than Scrum and works well for continuous-flow environments.\nExtreme Programming (XP) emphasizes technical excellence through practices like pair programming, test-driven development, and continuous integration.\nStory points provide relative estimation that accounts for uncertainty. Planning Poker builds consensus while avoiding anchoring bias.\nVelocity measures how much work a team completes per sprint, enabling forecasting and capacity planning.\nProject management tools like GitHub Projects and Jira support Agile workflows with boards, backlogs, and reporting.\nWork breakdown flows from Epics (large features) to Stories (deliverable value) to Tasks (technical work). Definition of Ready and Definition of Done ensure quality.\nEffective meetings require preparation, facilitation, and follow-through. Anti-patterns like status-report standups undermine Agile benefits.\nAdaptation is key—teams should modify Agile practices to fit their context, team size, and project type.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#key-terms",
    "href": "chapters/06-agile-methodologies.html#key-terms",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.12 6.11 Key Terms",
    "text": "9.12 6.11 Key Terms\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nAgile\nA mindset and set of values prioritizing individuals, working software, collaboration, and responding to change\n\n\nScrum\nAn Agile framework using sprints, defined roles, and ceremonies\n\n\nSprint\nA fixed time-box (typically 2 weeks) for delivering an increment\n\n\nProduct Backlog\nOrdered list of everything that might be needed in the product\n\n\nSprint Backlog\nItems selected for the sprint plus a plan for delivering them\n\n\nIncrement\nThe sum of all completed items, in usable condition\n\n\nVelocity\nStory points completed per sprint, used for planning\n\n\nKanban\nA method focusing on visualizing work, limiting WIP, and managing flow\n\n\nWIP Limit\nMaximum items allowed in a workflow stage\n\n\nCycle Time\nTime from work started to work completed\n\n\nStory Points\nRelative measure of effort, complexity, and uncertainty\n\n\nEpic\nLarge body of work spanning multiple sprints\n\n\nDefinition of Done\nShared criteria for when work is complete\n\n\nRetrospective\nMeeting to inspect the process and identify improvements\n\n\nPlanning Poker\nConsensus-based estimation technique",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#review-questions",
    "href": "chapters/06-agile-methodologies.html#review-questions",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.13 6.12 Review Questions",
    "text": "9.13 6.12 Review Questions\n\nExplain the four values of the Agile Manifesto. How does each value translate into practical behavior for software teams?\nCompare and contrast Scrum and Kanban. When would you choose one over the other?\nDescribe the three Scrum roles and their responsibilities. Why is it important that the Product Owner is a single person rather than a committee?\nWhat is the purpose of the Daily Scrum? How does it differ from a traditional status meeting?\nExplain the concept of story points. Why are they preferred over time-based estimates?\nWhat is velocity, and how should it (and shouldn’t it) be used?\nDescribe the Sprint Retrospective. What makes a retrospective effective versus ineffective?\nWhat is a WIP limit, and why is it important in Kanban?\nExplain the difference between Epics, User Stories, and Tasks. How do they relate to each other?\nWhat is the Definition of Done, and why is it important for teams to have one?",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#hands-on-exercises",
    "href": "chapters/06-agile-methodologies.html#hands-on-exercises",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.14 6.13 Hands-On Exercises",
    "text": "9.14 6.13 Hands-On Exercises\n\nExercise 6.1: Product Backlog Creation\nFor your semester project:\n\nIdentify at least 3 Epics that represent major features\nBreak each Epic into 5-8 User Stories\nWrite each story in the “As a… I want… so that…” format\nAdd acceptance criteria to each story\nOrder the backlog by priority\n\n\n\nExercise 6.2: Story Point Estimation\nConduct a Planning Poker session:\n\nSelect a reference story and assign it 3 points\nAs a team, estimate at least 10 stories\nDocument any significant discussions that arose\nCalculate total backlog size in points\nEstimate how many sprints to complete the backlog (assuming a reasonable velocity)\n\n\n\nExercise 6.3: Sprint Planning\nPlan your first sprint:\n\nDetermine sprint length (recommend 2 weeks)\nEstimate team capacity (available hours × focus factor)\nSelect stories from the top of the backlog totaling your target velocity\nBreak each story into tasks\nCreate a Sprint Goal\nDocument your Sprint Backlog\n\n\n\nExercise 6.4: Kanban Board Setup\nSet up a project board in GitHub Projects:\n\nCreate columns matching your workflow:\n\nBacklog\nReady (refined, ready to start)\nIn Progress\nIn Review\nDone\n\nAdd WIP limits to appropriate columns\nCreate cards for all your user stories\nMove cards to appropriate columns based on current status\nAdd labels for Epics, priority, and type\n\n\n\nExercise 6.5: Sprint Simulation\nSimulate running a sprint:\n\nConduct a Sprint Planning meeting (30-60 minutes)\nFor one week, conduct daily standups (async is fine):\n\nPost daily updates\nTrack blockers\nMove cards on your board\n\nAt the end of the week, conduct:\n\nSprint Review (demonstrate completed work)\nSprint Retrospective (identify improvements)\n\nDocument lessons learned\n\n\n\nExercise 6.6: Retrospective Facilitation\nPractice facilitating a retrospective:\n\nChoose a retrospective format (Start-Stop-Continue, 4Ls, Sailboat)\nPrepare materials (digital whiteboard or physical supplies)\nFacilitate a 45-minute retrospective with your team or classmates\nGenerate at least 3 specific, actionable improvements\nAssign owners and deadlines\nReflect on what made the retrospective effective or challenging\n\n\n\nExercise 6.7: Agile Sprint Plan Document\nCreate a formal Sprint Plan document including:\n\nProject overview and Sprint Goal\nTeam capacity calculation\nSprint Backlog with stories and tasks\nRisk and dependency identification\nDefinition of Done for the sprint\nMeeting schedule (standups, review, retrospective)\nSuccess criteria",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#further-reading",
    "href": "chapters/06-agile-methodologies.html#further-reading",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.15 6.14 Further Reading",
    "text": "9.15 6.14 Further Reading\nBooks:\n\nSchwaber, K., & Sutherland, J. (2020). The Scrum Guide. Scrum.org. (Free download)\nSutherland, J. (2014). Scrum: The Art of Doing Twice the Work in Half the Time. Crown Business.\nAnderson, D. (2010). Kanban: Successful Evolutionary Change for Your Technology Business. Blue Hole Press.\nBeck, K. (2004). Extreme Programming Explained: Embrace Change (2nd Edition). Addison-Wesley.\nCohn, M. (2005). Agile Estimating and Planning. Prentice Hall.\nDerby, E., & Larsen, D. (2006). Agile Retrospectives: Making Good Teams Great. Pragmatic Bookshelf.\n\nOnline Resources:\n\nThe Scrum Guide: https://scrumguides.org/\nAgile Manifesto: https://agilemanifesto.org/\nMountain Goat Software (Scrum resources): https://www.mountaingoatsoftware.com/\nKanban University: https://kanban.university/\nGitHub Projects Documentation: https://docs.github.com/en/issues/planning-and-tracking-with-projects",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/06-agile-methodologies.html#references",
    "href": "chapters/06-agile-methodologies.html#references",
    "title": "9  Chapter 6: Agile Methodologies and Project Management",
    "section": "9.16 References",
    "text": "9.16 References\nAnderson, D. J. (2010). Kanban: Successful Evolutionary Change for Your Technology Business. Blue Hole Press.\nBeck, K. (2004). Extreme Programming Explained: Embrace Change (2nd Edition). Addison-Wesley.\nBeck, K., et al. (2001). Manifesto for Agile Software Development. Retrieved from https://agilemanifesto.org/\nCohn, M. (2005). Agile Estimating and Planning. Prentice Hall.\nDerby, E., & Larsen, D. (2006). Agile Retrospectives: Making Good Teams Great. Pragmatic Bookshelf.\nGrenning, J. (2002). Planning Poker or How to Avoid Analysis Paralysis while Release Planning. Retrieved from https://wingman-sw.com/articles/planning-poker\nSchwaber, K., & Sutherland, J. (2020). The Scrum Guide. Retrieved from https://scrumguides.org/\nSutherland, J. (2014). Scrum: The Art of Doing Twice the Work in Half the Time. Crown Business.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 6: Agile Methodologies and Project Management</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html",
    "href": "chapters/07-version-control.html",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "",
    "text": "10.1 Learning Objectives\nBy the end of this chapter, you will be able to:",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#learning-objectives",
    "href": "chapters/07-version-control.html#learning-objectives",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "",
    "text": "Explain the importance of structured version control workflows in team environments\nCompare and contrast major branching strategies including Gitflow, GitHub Flow, and trunk-based development\nCreate, manage, and merge branches effectively using Git\nWrite meaningful pull requests that facilitate effective code review\nConduct thorough, constructive code reviews\nResolve merge conflicts confidently and correctly\nMaintain repository hygiene through proper documentation and conventions\nChoose appropriate branching strategies for different project contexts",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#why-version-control-workflows-matter",
    "href": "chapters/07-version-control.html#why-version-control-workflows-matter",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.2 7.1 Why Version Control Workflows Matter",
    "text": "10.2 7.1 Why Version Control Workflows Matter\nIn Chapter 1, we introduced Git and GitHub as tools for tracking changes and collaborating on code. But knowing Git commands is only the beginning. When multiple developers work on the same codebase simultaneously, chaos can ensue without agreed-upon workflows. Who can commit to which branch? How do changes get reviewed? What happens when two people modify the same file?\nA version control workflow is a set of conventions and practices that define how a team uses version control. It answers questions like:\n\nHow do we organize our branches?\nHow do changes move from development to production?\nWho reviews code, and when?\nHow do we handle releases and hotfixes?\n\n\n7.1.1 The Cost of Poor Version Control\nWithout structured workflows, teams encounter predictable problems:\nIntegration nightmares: Developers work in isolation for weeks, then try to merge everything at once. Massive conflicts result, and subtle bugs slip through as incompatible changes collide.\nUnstable main branch: Without protection, broken code gets committed directly to main. The build fails. Nobody can deploy. Everyone’s blocked.\nLost work: Without proper branching, experimental changes get mixed with stable code. Rolling back becomes impossible without losing good work too.\nNo accountability: Without code review, bugs slip into production. Nobody catches security vulnerabilities, performance problems, or architectural violations until they cause real damage.\nRelease chaos: Without clear release processes, teams don’t know what’s deployed where. Hotfixes go to the wrong version. Customers get inconsistent experiences.\n\n\n7.1.2 What Good Workflows Provide\nStructured workflows address these problems:\nIsolation: Developers work on separate branches, insulated from each other’s in-progress changes. Integration happens deliberately, not accidentally.\nStability: The main branch stays deployable. Broken code never reaches it because changes must pass tests and review first.\nTraceability: Every change is linked to a purpose—a feature, a bug fix, a task. History tells the story of why the code evolved.\nQuality: Code review catches bugs, shares knowledge, and maintains standards. Multiple eyes improve quality.\nConfidence: Clear processes mean everyone knows what to do. Deployments become routine, not risky adventures.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#understanding-git-branching",
    "href": "chapters/07-version-control.html#understanding-git-branching",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.3 7.2 Understanding Git Branching",
    "text": "10.3 7.2 Understanding Git Branching\nBefore exploring workflows, let’s deepen our understanding of Git branching—the foundation on which all workflows build.\n\n7.2.1 What Is a Branch?\nA branch in Git is simply a lightweight movable pointer to a commit. When you create a branch, Git creates a new pointer; it doesn’t copy any files. This makes branching fast and cheap.\n                         main\n                          │\n                          ▼\n    ●────●────●────●────●────●\n                   │\n                   └────●────●\n                             ▲\n                             │\n                         feature\nIn this diagram:\n\nEach ● is a commit\nmain points to the latest commit on the main line\nfeature points to the latest commit on the feature branch\nThe branches share history up to where they diverged\n\n\n\n7.2.2 HEAD: Where You Are\nHEAD is a special pointer that indicates your current position—which branch (and commit) you’re working on.\n                          HEAD\n                           │\n                           ▼\n                         main\n                          │\n                          ▼\n    ●────●────●────●────●────●\n                   │\n                   └────●────●\n                             ▲\n                             │\n                         feature\nWhen you checkout a different branch, HEAD moves:\n    git checkout feature\n\n                         main\n                          │\n                          ▼\n    ●────●────●────●────●────●\n                   │\n                   └────●────●\n                             ▲\n                             │\n                         feature\n                             ▲\n                             │\n                           HEAD\n\n\n7.2.3 Branch Operations\nCreating a Branch:\n# Create a new branch\ngit branch feature-login\n\n# Create and switch to a new branch\ngit checkout -b feature-login\n\n# Modern alternative (Git 2.23+)\ngit switch -c feature-login\nSwitching Branches:\n# Traditional\ngit checkout main\n\n# Modern alternative\ngit switch main\nListing Branches:\n# List local branches\ngit branch\n\n# List all branches (including remote)\ngit branch -a\n\n# List with last commit info\ngit branch -v\nDeleting Branches:\n# Delete a merged branch\ngit branch -d feature-login\n\n# Force delete an unmerged branch\ngit branch -D experimental-feature\n\n\n7.2.4 Merging Branches\nMerging combines the changes from one branch into another. Git supports several merge strategies.\nFast-Forward Merge:\nWhen the target branch hasn’t diverged, Git simply moves the pointer forward:\nBefore:\n    main\n     │\n     ▼\n    ●────●────●\n              │\n              └────●────●\n                        ▲\n                        │\n                    feature\n\nAfter git checkout main && git merge feature:\n\n                       main\n                        │\n                        ▼\n    ●────●────●────●────●\n                        ▲\n                        │\n                    feature\nNo merge commit is created—history stays linear.\nThree-Way Merge:\nWhen branches have diverged, Git creates a merge commit with two parents:\nBefore:\n              main\n               │\n               ▼\n    ●────●────●────●\n              │\n              └────●────●\n                        ▲\n                        │\n                    feature\n\nAfter git checkout main && git merge feature:\n\n                        main\n                         │\n                         ▼\n    ●────●────●────●────●────●  (merge commit)\n              │              │\n              └────●────●────┘\n                        ▲\n                        │\n                    feature\nMerge Commands:\n# Merge feature into current branch (main)\ngit checkout main\ngit merge feature-login\n\n# Merge with a commit message\ngit merge feature-login -m \"Merge feature-login into main\"\n\n# Abort a merge in progress\ngit merge --abort\n\n\n7.2.5 Rebasing\nRebasing rewrites history by moving commits to a new base. Instead of a merge commit, rebase creates a linear history.\nBefore:\n              main\n               │\n               ▼\n    ●────●────●────●\n              │\n              └────●────●\n                        ▲\n                        │\n                    feature\n\nAfter git checkout feature && git rebase main:\n\n                   main\n                    │\n                    ▼\n    ●────●────●────●────●'────●'\n                              ▲\n                              │\n                          feature\nThe commits on feature are recreated (●’ indicates new commits with same changes but different hashes).\nRebase Commands:\n# Rebase current branch onto main\ngit rebase main\n\n# Interactive rebase (edit, squash, reorder commits)\ngit rebase -i main\n\n# Abort a rebase in progress\ngit rebase --abort\n\n# Continue after resolving conflicts\ngit rebase --continue\nMerge vs. Rebase:\n\n\n\nAspect\nMerge\nRebase\n\n\n\n\nHistory\nPreserves true history\nCreates linear history\n\n\nMerge commits\nCreates merge commits\nNo merge commits\n\n\nConflict resolution\nOnce per merge\nOnce per rebased commit\n\n\nSafety\nSafe for shared branches\nDon’t rebase shared branches\n\n\nTraceability\nShows when branches joined\nHides branch structure\n\n\n\nThe Golden Rule of Rebasing:\n\nNever rebase commits that have been pushed to a public/shared branch.\n\nRebasing rewrites history. If others have based work on commits you rebase, their history diverges from yours, causing major problems.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#branching-strategies",
    "href": "chapters/07-version-control.html#branching-strategies",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.4 7.3 Branching Strategies",
    "text": "10.4 7.3 Branching Strategies\nA branching strategy defines how teams organize and use branches. Different strategies suit different team sizes, release cycles, and risk tolerances.\n\n7.3.1 Gitflow\nGitflow, introduced by Vincent Driessen in 2010, is a comprehensive branching model designed for projects with scheduled releases.\nBranch Types:\n┌─────────────────────────────────────────────────────────────────────────┐\n│                          GITFLOW BRANCHES                               │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  MAIN (main/master)                                                     │\n│  • Production-ready code                                                │\n│  • Tagged with version numbers                                          │\n│  • Only receives merges from release and hotfix branches                │\n│                                                                         │\n│  DEVELOP (develop)                                                      │\n│  • Integration branch for features                                      │\n│  • Contains latest delivered development changes                        │\n│  • Features branch from and merge back to develop                       │\n│                                                                         │\n│  FEATURE (feature/*)                                                    │\n│  • New features and non-emergency fixes                                 │\n│  • Branch from: develop                                                 │\n│  • Merge to: develop                                                    │\n│  • Naming: feature/user-authentication, feature/payment-gateway         │\n│                                                                         │\n│  RELEASE (release/*)                                                    │\n│  • Preparation for production release                                   │\n│  • Branch from: develop                                                 │\n│  • Merge to: main AND develop                                           │\n│  • Naming: release/1.2.0, release/2.0.0                                 │\n│                                                                         │\n│  HOTFIX (hotfix/*)                                                      │\n│  • Emergency fixes for production                                       │\n│  • Branch from: main                                                    │\n│  • Merge to: main AND develop                                           │\n│  • Naming: hotfix/critical-security-fix, hotfix/payment-bug             │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nVisual Representation:\nmain      ●───────────────────────●─────────────────●──────●\n           \\                     / \\               /      /\n            \\                   /   \\             /      /\nrelease      \\        ●───●───●     \\           /      /\n              \\      /               \\         /      /\n               \\    /                 \\       /      /\ndevelop    ●────●──●────●────●────●────●─────●──────●────●\n                \\      /          \\        /\n                 \\    /            \\      /\nfeature           ●──●              ●────●\n                                          \\\n                                           \\\nhotfix                                      ●────●\nGitflow Workflow:\nStarting a new feature:\n# Create feature branch from develop\ngit checkout develop\ngit checkout -b feature/user-authentication\n\n# Work on feature...\ngit add .\ngit commit -m \"Add login form\"\n\n# Continue working...\ngit commit -m \"Add authentication API\"\n\n# Finish feature\ngit checkout develop\ngit merge feature/user-authentication\ngit branch -d feature/user-authentication\nCreating a release:\n# Create release branch from develop\ngit checkout develop\ngit checkout -b release/1.2.0\n\n# Bump version numbers, final testing, documentation\ngit commit -m \"Bump version to 1.2.0\"\n\n# Finish release\ngit checkout main\ngit merge release/1.2.0\ngit tag -a v1.2.0 -m \"Release version 1.2.0\"\n\ngit checkout develop\ngit merge release/1.2.0\n\ngit branch -d release/1.2.0\nCreating a hotfix:\n# Create hotfix branch from main\ngit checkout main\ngit checkout -b hotfix/critical-security-fix\n\n# Fix the issue\ngit commit -m \"Fix SQL injection vulnerability\"\n\n# Finish hotfix\ngit checkout main\ngit merge hotfix/critical-security-fix\ngit tag -a v1.2.1 -m \"Hotfix release 1.2.1\"\n\ngit checkout develop\ngit merge hotfix/critical-security-fix\n\ngit branch -d hotfix/critical-security-fix\nGitflow Pros and Cons:\n\n\n\n\n\n\n\nPros\nCons\n\n\n\n\nClear structure for releases\nComplex with many branch types\n\n\nParallel development and release\nSlow for continuous deployment\n\n\nHotfix path separate from features\nMerge conflicts between long-lived branches\n\n\nGood for versioned software\nOverhead for small teams\n\n\nWell-documented, widely understood\ndevelop can become stale\n\n\n\nWhen to Use Gitflow:\n\nSoftware with explicit version releases\nMultiple versions in production\nTeams with dedicated release management\nProducts requiring extensive release testing\nCompliance environments requiring audit trails\n\n\n\n7.3.2 GitHub Flow\nGitHub Flow is a simpler workflow designed for continuous deployment. Created at GitHub, it has only one rule: anything in main is deployable.\nBranch Types:\n┌─────────────────────────────────────────────────────────────────────────┐\n│                        GITHUB FLOW BRANCHES                             │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  MAIN (main)                                                            │\n│  • Always deployable                                                    │\n│  • Protected—no direct commits                                          │\n│  • All changes come through pull requests                               │\n│                                                                         │\n│  FEATURE BRANCHES (descriptive names)                                   │\n│  • All work happens in feature branches                                 │\n│  • Branch from: main                                                    │\n│  • Merge to: main (via pull request)                                    │\n│  • Naming: descriptive (add-user-auth, fix-payment-bug)                 │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nVisual Representation:\nmain      ●────●────●────●────●────●────●────●────●\n               \\    /    \\   /         \\        /\n                \\  /      \\ /           \\      /\nfeature          ●         ●             ●────●\nGitHub Flow Process:\n┌─────────────────────────────────────────────────────────────────────────┐\n│                        GITHUB FLOW PROCESS                              │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  1. CREATE A BRANCH                                                     │\n│     • Branch from main                                                  │\n│     • Use descriptive name                                              │\n│                                                                         │\n│  2. ADD COMMITS                                                         │\n│     • Make changes                                                      │\n│     • Commit frequently with clear messages                             │\n│     • Push to remote regularly                                          │\n│                                                                         │\n│  3. OPEN A PULL REQUEST                                                 │\n│     • Start discussion about changes                                    │\n│     • Request review from teammates                                     │\n│     • CI runs tests automatically                                       │\n│                                                                         │\n│  4. DISCUSS AND REVIEW                                                  │\n│     • Reviewers leave comments                                          │\n│     • Author addresses feedback                                         │\n│     • More commits as needed                                            │\n│                                                                         │\n│  5. DEPLOY (optional)                                                   │\n│     • Deploy branch to test environment                                 │\n│     • Verify in production-like setting                                 │\n│                                                                         │\n│  6. MERGE                                                               │\n│     • Merge to main after approval                                      │\n│     • Delete the feature branch                                         │\n│     • Main is deployed to production                                    │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nGitHub Flow Commands:\n# 1. Create a branch\ngit checkout main\ngit pull origin main\ngit checkout -b add-password-reset\n\n# 2. Make changes and commit\ngit add .\ngit commit -m \"Add password reset request form\"\ngit commit -m \"Add password reset email functionality\"\ngit commit -m \"Add password reset confirmation page\"\n\n# Push to remote (enables PR and backup)\ngit push -u origin add-password-reset\n\n# 3. Open Pull Request (on GitHub)\n# - Write description\n# - Request reviewers\n# - Link to issue\n\n# 4. Address review feedback\ngit add .\ngit commit -m \"Address review feedback: add rate limiting\"\ngit push\n\n# 5. After approval, merge via GitHub UI\n\n# 6. Clean up locally\ngit checkout main\ngit pull origin main\ngit branch -d add-password-reset\nGitHub Flow Pros and Cons:\n\n\n\n\n\n\n\nPros\nCons\n\n\n\n\nSimple—only two branch types\nNo explicit release management\n\n\nFast—optimized for continuous deployment\nRequires robust CI/CD\n\n\nPull requests enable code review\nLess structure for versioned releases\n\n\nWorks great for web applications\nHotfixes indistinguishable from features\n\n\nLow overhead\nMay need extensions for complex projects\n\n\n\nWhen to Use GitHub Flow:\n\nWeb applications with continuous deployment\nSmall to medium teams\nProducts without versioned releases\nTeams practicing continuous integration\nProjects prioritizing simplicity\n\n\n\n7.3.3 Trunk-Based Development\nTrunk-based development (TBD) takes simplicity further: all developers commit to a single branch (the “trunk,” typically main), either directly or through very short-lived feature branches.\nCore Principles:\n┌─────────────────────────────────────────────────────────────────────────┐\n│                    TRUNK-BASED DEVELOPMENT                              │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  1. SINGLE SOURCE OF TRUTH                                              │\n│     • All code integrates to main/trunk                                 │\n│     • No long-lived branches                                            │\n│                                                                         │\n│  2. FREQUENT INTEGRATION                                                │\n│     • Integrate at least daily                                          │\n│     • Small, incremental changes                                        │\n│                                                                         │\n│  3. FEATURE FLAGS                                                       │\n│     • Hide incomplete features in production                            │\n│     • Deploy code before features are complete                          │\n│                                                                         │\n│  4. RELEASE FROM TRUNK                                                  │\n│     • Create release branches only if needed                            │\n│     • Tag releases on trunk                                             │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nVisual Representation:\nWith short-lived branches (&lt; 1 day):\n\nmain      ●────●────●────●────●────●────●────●────●────●\n              / \\        / \\       |    \\      /\n             /   \\      /   \\      |     \\    /\nfeature     ●     ●    ●     ●     ●      ●──●\n\nDirect commits (pair programming):\n\nmain      ●────●────●────●────●────●────●────●────●────●\n           Alice Bob  Both  Alice Bob  Alice  Bob  Both\nFeature Flags:\nSince incomplete features merge to main, feature flags hide them from users:\n# Feature flag example\nif feature_flags.is_enabled('new_checkout_flow', user):\n    return render_new_checkout(cart)\nelse:\n    return render_old_checkout(cart)\nFeature flags allow:\n\nDeploying incomplete code safely\nGradual rollouts (1% → 10% → 50% → 100% of users)\nQuick rollback without code changes\nA/B testing\n\nTrunk-Based Development Commands:\n# Option 1: Direct to main (with pair programming/mob programming)\ngit checkout main\ngit pull\n# Make small change\ngit add .\ngit commit -m \"Add email validation to signup form\"\ngit pull --rebase  # Get others' changes\ngit push\n\n# Option 2: Short-lived branch (&lt; 1 day)\ngit checkout main\ngit pull\ngit checkout -b small-fix\n# Make changes\ngit add .\ngit commit -m \"Fix typo in error message\"\ngit checkout main\ngit pull\ngit merge small-fix\ngit push\ngit branch -d small-fix\nTrunk-Based Development Pros and Cons:\n\n\n\n\n\n\n\nPros\nCons\n\n\n\n\nContinuous integration by definition\nRequires strong testing discipline\n\n\nNo merge hell from long-lived branches\nFeature flags add complexity\n\n\nFaster feedback on integration issues\nDirect commits require senior team\n\n\nSimpler mental model\nIncomplete features visible in codebase\n\n\nEnables continuous deployment\nLess isolation for experimental work\n\n\n\nWhen to Use Trunk-Based Development:\n\nTeams with excellent test coverage\nStrong CI/CD pipeline\nSenior, disciplined developers\nProducts requiring very fast iteration\nOrganizations practicing DevOps/continuous deployment\n\n\n\n7.3.4 Comparing Branching Strategies\n\n\n\n\n\n\n\n\n\nAspect\nGitflow\nGitHub Flow\nTrunk-Based\n\n\n\n\nBranch types\n5 (main, develop, feature, release, hotfix)\n2 (main, feature)\n1-2 (main, optional short-lived)\n\n\nComplexity\nHigh\nLow\nVery low\n\n\nRelease style\nScheduled releases\nContinuous\nContinuous\n\n\nIntegration frequency\nWhen feature complete\nAt PR merge\nMultiple times daily\n\n\nBest for\nVersioned products\nWeb apps\nHigh-velocity teams\n\n\nFeature isolation\nHigh\nMedium\nLow (use feature flags)\n\n\nCI/CD requirement\nHelpful\nImportant\nEssential\n\n\n\n\n\n7.3.5 Choosing a Strategy\nConsider these factors when choosing:\nTeam size and experience:\n\nSmall/senior team → Trunk-based or GitHub Flow\nLarge/mixed experience → Gitflow or GitHub Flow\n\nRelease cadence:\n\nContinuous deployment → GitHub Flow or Trunk-based\nScheduled releases → Gitflow\nMultiple versions in production → Gitflow\n\nProduct type:\n\nWeb application → GitHub Flow or Trunk-based\nMobile app (app store releases) → Gitflow\nPackaged software → Gitflow\nInternal tools → GitHub Flow\n\nRisk tolerance:\n\nHigh risk tolerance, fast iteration → Trunk-based\nLow risk tolerance, careful releases → Gitflow\nBalanced → GitHub Flow\n\nFor your course project, GitHub Flow is recommended—it’s simple enough to learn quickly while teaching important practices like pull requests and code review.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#pull-requests",
    "href": "chapters/07-version-control.html#pull-requests",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.5 7.4 Pull Requests",
    "text": "10.5 7.4 Pull Requests\nA pull request (PR) is a request to merge changes from one branch into another. More than just a merge mechanism, pull requests are collaboration tools that enable discussion, review, and quality control.\n\n7.4.1 Anatomy of a Good Pull Request\n┌─────────────────────────────────────────────────────────────────────────┐\n│  Add user authentication system                            #142         │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  alice wants to merge 5 commits into main from feature/user-auth        │\n│                                                                         │\n│  ┌───────────────────────────────────────────────────────────────────┐  │\n│  │                                                                   │  │\n│  │  ## Summary                                                       │  │\n│  │                                                                   │  │\n│  │  This PR adds a complete user authentication system including:    │  │\n│  │  - User registration with email verification                      │  │\n│  │  - Login/logout functionality                                     │  │\n│  │  - Password reset via email                                       │  │\n│  │  - Session management with JWT tokens                             │  │\n│  │                                                                   │  │\n│  │  ## Related Issues                                                │  │\n│  │                                                                   │  │\n│  │  Closes #98                                                       │  │\n│  │  Relates to #95, #96                                              │  │\n│  │                                                                   │  │\n│  │  ## Changes                                                       │  │\n│  │                                                                   │  │\n│  │  - Added User model with email, password hash, and verification   │  │\n│  │  - Implemented AuthService with register, login, logout methods   │  │\n│  │  - Created auth API endpoints (/register, /login, /logout, etc.)  │  │\n│  │  - Added JWT middleware for protected routes                      │  │\n│  │  - Integrated SendGrid for verification and reset emails          │  │\n│  │  - Added rate limiting to prevent brute force attacks             │  │\n│  │                                                                   │  │\n│  │  ## Testing                                                       │  │\n│  │                                                                   │  │\n│  │  - Added 45 unit tests for AuthService (100% coverage)            │  │\n│  │  - Added 12 integration tests for auth endpoints                  │  │\n│  │  - Manual testing checklist completed (see below)                 │  │\n│  │                                                                   │  │\n│  │  ## Screenshots                                                   │  │\n│  │                                                                   │  │\n│  │  [Login Form Screenshot]                                          │  │\n│  │  [Registration Flow GIF]                                          │  │\n│  │                                                                   │  │\n│  │  ## Checklist                                                     │  │\n│  │                                                                   │  │\n│  │  - [x] Code follows project style guide                           │  │\n│  │  - [x] Tests added/updated                                        │  │\n│  │  - [x] Documentation updated                                      │  │\n│  │  - [x] No console.log or debug code                               │  │\n│  │  - [x] Tested on Chrome, Firefox, Safari                          │  │\n│  │                                                                   │  │\n│  └───────────────────────────────────────────────────────────────────┘  │\n│                                                                         │\n│  Reviewers: @bob @carol                    Labels: feature, auth        │\n│  Assignees: @alice                         Milestone: MVP               │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\n\n\n7.4.2 Writing Effective PR Descriptions\nTitle:\n\nClear and concise\nDescribes what the PR does (not how)\nOften starts with a verb: “Add…”, “Fix…”, “Update…”, “Remove…”\n\nDescription Template:\n## Summary\nBrief description of what this PR does and why.\n\n## Related Issues\n- Closes #123\n- Relates to #456\n\n## Changes\n- Bullet points describing specific changes\n- Focus on the \"what\" and \"why\"\n- Group related changes together\n\n## Testing\n- How was this tested?\n- Any specific testing instructions for reviewers?\n- Test coverage information\n\n## Screenshots/GIFs (if applicable)\nVisual demonstration of UI changes\n\n## Checklist\n- [ ] Code follows style guide\n- [ ] Tests added/updated\n- [ ] Documentation updated\n- [ ] Self-review completed\n- [ ] Ready for review\n\n## Notes for Reviewers\nAny specific areas you'd like extra attention on?\nAny known issues or trade-offs?\n\n\n7.4.3 Pull Request Best Practices\nKeep PRs Small:\nSmall PRs are easier to review, faster to merge, and less risky. Aim for:\n\nUnder 400 lines of changes\nOne logical change per PR\nCompletable in 1-2 days\n\nPR Size Guidelines:\n\n&lt; 100 lines    → Easy to review, quick turnaround\n100-300 lines  → Reasonable, standard PR\n300-500 lines  → Large, may need splitting\n&gt; 500 lines    → Too large, definitely split\n\nExceptions:\n- Generated code\n- Data migrations\n- Dependency updates\nSplitting Large PRs:\nInstead of one giant PR:\n\"Add complete user management system\" (2000+ lines)\n\nSplit into:\n1. \"Add User model and database migration\" (~150 lines)\n2. \"Add user registration endpoint\" (~200 lines)\n3. \"Add user login endpoint\" (~200 lines)\n4. \"Add user profile endpoints\" (~250 lines)\n5. \"Add user management UI\" (~300 lines)\n\nEach PR is reviewable and independently mergeable.\nSelf-Review Before Requesting Review:\nBefore requesting review:\n\nRead through all your changes in the GitHub diff\nCheck for debugging code, console.logs, TODOs\nVerify tests pass locally\nEnsure documentation is updated\nAdd comments explaining non-obvious code\n\nRespond to Feedback Promptly:\n\nAcknowledge comments even if you need time to address them\nExplain your reasoning if you disagree (respectfully)\nPush new commits to address feedback\nRe-request review when ready\n\n\n\n7.4.4 Draft Pull Requests\nDraft PRs indicate work-in-progress that isn’t ready for review. Use them to:\n\nGet early feedback on approach\nShow progress to teammates\nRun CI before formal review\nDiscuss design decisions\n\n┌─────────────────────────────────────────────────────────────────────────┐\n│  🚧 [DRAFT] Add user authentication system                  #142        │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  This pull request is still a work in progress.                         │\n│                                                                         │\n│  ## Current Status                                                      │\n│  - [x] User model                                                       │\n│  - [x] Registration endpoint                                            │\n│  - [ ] Login endpoint (in progress)                                     │\n│  - [ ] Password reset                                                   │\n│  - [ ] Tests                                                            │\n│                                                                         │\n│  ## Questions for Team                                                  │\n│  - Should we use JWT or session cookies?                                │\n│  - What's our password policy?                                          │\n│                                                                         │\n│  Not ready for formal review yet, but feedback on approach welcome!     │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nConvert to a regular PR when ready for review.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#code-review",
    "href": "chapters/07-version-control.html#code-review",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.6 7.5 Code Review",
    "text": "10.6 7.5 Code Review\nCode review is the practice of having team members examine code changes before they’re merged. It’s one of the most valuable practices in software engineering, improving code quality, spreading knowledge, and catching bugs early.\n\n7.5.1 Why Code Review Matters\nQuality Improvement:\n\nCatches bugs before production\nIdentifies security vulnerabilities\nEnsures code meets standards\nImproves design and architecture\n\nKnowledge Sharing:\n\nSpreads knowledge across the team\nNew team members learn the codebase\nSenior developers mentor juniors\nNo single point of failure\n\nAccountability and Ownership:\n\nMultiple people understand each change\nShared responsibility for quality\nDocumentation through review comments\n\n\n\n7.5.2 The Reviewer’s Mindset\nGood reviewers approach code with:\nEmpathy: Someone worked hard on this. Be kind and constructive.\nCuriosity: Why was this approach chosen? What am I missing?\nRigor: Don’t rubber-stamp. Actually read and think about the code.\nHumility: The author may know something you don’t. Ask questions rather than assuming bugs.\nEfficiency: Don’t make the author wait. Review promptly.\n\n\n7.5.3 What to Look For\nFunctionality:\n\nDoes the code do what it’s supposed to do?\nAre edge cases handled?\nWhat happens with unexpected input?\n\nCode Quality:\n\nIs the code readable and maintainable?\nAre names clear and meaningful?\nIs there unnecessary complexity?\nIs there duplicated code?\n\nDesign:\n\nDoes the approach make sense?\nDoes it fit with existing architecture?\nAre there better alternatives?\nIs it extensible for future needs?\n\nTesting:\n\nAre there sufficient tests?\nDo tests cover edge cases?\nAre tests readable and maintainable?\n\nSecurity:\n\nAre inputs validated?\nIs sensitive data protected?\nAre there injection vulnerabilities?\nIs authentication/authorization correct?\n\nPerformance:\n\nAre there obvious performance issues?\nDatabase queries efficient?\nMemory leaks possible?\n\nDocumentation:\n\nIs complex code explained?\nAre public APIs documented?\nIs README updated if needed?\n\n\n\n7.5.4 Review Checklist\nCODE REVIEW CHECKLIST\n═══════════════════════════════════════════════════════════════\n\nUNDERSTANDING\n☐ I understand what this PR is supposed to do\n☐ The PR description explains the changes clearly\n☐ Related issues are linked\n\nFUNCTIONALITY\n☐ Code achieves the stated goal\n☐ Edge cases are handled\n☐ Error handling is appropriate\n☐ No obvious bugs\n\nDESIGN\n☐ Approach is reasonable\n☐ Consistent with existing patterns\n☐ No unnecessary complexity\n☐ Changes are in appropriate locations\n\nCODE QUALITY\n☐ Code is readable\n☐ Names are clear and meaningful\n☐ No dead/commented code\n☐ No debugging code (console.log, etc.)\n☐ Follows project style guide\n\nTESTING\n☐ Tests exist for new functionality\n☐ Tests cover important cases\n☐ Tests are readable\n☐ All tests pass\n\nSECURITY\n☐ No obvious security issues\n☐ Inputs are validated\n☐ Sensitive data is handled properly\n\nDOCUMENTATION\n☐ Complex code is commented\n☐ API documentation updated\n☐ README updated if needed\n\n\n7.5.5 Giving Feedback\nBe Specific:\n❌ \"This code is confusing.\"\n\n✓ \"I found the logic in processOrder() hard to follow. Consider \n   extracting the discount calculation into a separate function \n   like calculateDiscount(order).\"\nExplain Why:\n❌ \"Use const instead of let here.\"\n\n✓ \"Use const instead of let here since items isn't reassigned. \n   Using const signals intent and prevents accidental reassignment.\"\nAsk Questions:\n❌ \"This is wrong.\"\n\n✓ \"I'm not sure I understand the logic here. What happens if \n   the user has no orders? Wouldn't orders.length be 0, making \n   the average calculation divide by zero?\"\nOffer Suggestions:\n❌ \"This could be better.\"\n\n✓ \"Consider using array.find() instead of the for loop:\n   \n   const user = users.find(u =&gt; u.id === targetId);\n   \n   This is more concise and expresses intent more clearly.\"\nDistinguish Importance:\nUse prefixes to indicate severity:\n[blocking] - Must be fixed before merge\n[suggestion] - Optional improvement\n[question] - Seeking understanding\n[nit] - Minor/stylistic, very optional\n[praise] - Positive feedback!\nExamples:\n[blocking] This SQL query is vulnerable to injection. Please use \nparameterized queries.\n\n[suggestion] Consider extracting this into a helper function. It \nwould improve readability and allow reuse.\n\n[question] Why did you choose to load all users into memory? With \nlarge datasets this could be slow—was that considered?\n\n[nit] Extra blank line here.\n\n[praise] Great test coverage! The edge case tests are especially \nthorough.\n\n\n7.5.6 Receiving Feedback\nDon’t Take It Personally:\n\nReview is about the code, not you\nFeedback is a gift that improves your work\nEveryone’s code can be improved\n\nUnderstand Before Responding:\n\nRe-read comments to make sure you understand\nAsk for clarification if needed\nConsider the reviewer’s perspective\n\nEngage Constructively:\n\nThank reviewers for their feedback\nExplain your reasoning if you disagree\nAccept valid criticism gracefully\n\nResponse Examples:\nReviewer: \"This function is doing too much. Consider splitting it.\"\n\nResponse Options:\n\n✓ \"Good point! I've split it into validateInput() and \n   processRequest(). Much cleaner now.\"\n\n✓ \"I considered splitting it, but keeping it together lets us \n   do X more efficiently. Here's my reasoning... What do you think?\"\n\n✓ \"Could you clarify what you mean? Are you suggesting splitting \n   by responsibility or by... something else?\"\n\n❌ \"It's fine how it is.\"\n❌ \"I don't have time to refactor this.\"\n\n\n7.5.7 Review Etiquette\nFor Reviewers:\n\nReview within 24 hours (ideally same day)\nBe thorough but not pedantic\nApprove when it’s good enough (not perfect)\nFollow up on addressed comments\nThank authors for good code\n\nFor Authors:\n\nRespond to all comments\nDon’t argue every point\nMake requested changes promptly\nRe-request review when ready\nThank reviewers for their time\n\n\n\n7.5.8 Automated Checks\nAutomated tools complement human review:\nCI/CD Checks:\n\nTests pass\nBuild succeeds\nCode coverage maintained\n\nLinting:\n\nCode style consistency\nPotential bugs (unused variables, etc.)\nFormatting\n\nSecurity Scanning:\n\nDependency vulnerabilities\nCode security issues\n\nConfiguring Required Checks:\n# .github/workflows/ci.yml\nname: CI\non: [pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install dependencies\n        run: npm install\n      - name: Run linter\n        run: npm run lint\n      - name: Run tests\n        run: npm test\n      - name: Check coverage\n        run: npm run coverage",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#handling-merge-conflicts",
    "href": "chapters/07-version-control.html#handling-merge-conflicts",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.7 7.6 Handling Merge Conflicts",
    "text": "10.7 7.6 Handling Merge Conflicts\nMerge conflicts occur when Git can’t automatically combine changes—usually because two branches modified the same lines of code. Conflicts are normal and manageable with the right approach.\n\n7.6.1 Why Conflicts Happen\nScenario: Two developers modify the same file\n\nInitial state (main):\n┌─────────────────────────────────────────┐\n│ function greet(name) {                  │\n│   return \"Hello, \" + name;              │\n│ }                                       │\n└─────────────────────────────────────────┘\n\nAlice's branch:\n┌─────────────────────────────────────────┐\n│ function greet(name) {                  │\n│   return `Hello, ${name}!`;             │  ← Changed to template literal\n│ }                                       │\n└─────────────────────────────────────────┘\n\nBob's branch:\n┌─────────────────────────────────────────┐\n│ function greet(name) {                  │\n│   return \"Hi, \" + name;                 │  ← Changed \"Hello\" to \"Hi\"\n│ }                                       │\n└─────────────────────────────────────────┘\n\nAlice merges first. Now when Bob tries to merge:\nCONFLICT! Git doesn't know which change to keep.\n\n\n7.6.2 Anatomy of a Conflict\nWhen a conflict occurs, Git marks the conflicting sections:\nfunction greet(name) {\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n  return `Hello, ${name}!`;\n=======\n  return \"Hi, \" + name;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/bobs-greeting\n}\nUnderstanding the markers:\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD: Start of current branch’s version\n=======: Divider between versions\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/bobs-greeting: End, with other branch name\n\n\n\n7.6.3 Resolving Conflicts\nStep 1: Identify conflicting files\ngit status\n\n# Output:\n# On branch main\n# You have unmerged paths.\n#   (fix conflicts and run \"git commit\")\n#\n# Unmerged paths:\n#   (use \"git add &lt;file&gt;...\" to mark resolution)\n#       both modified:   src/greet.js\nStep 2: Open and edit conflicting files\nRemove the conflict markers and create the correct merged version:\n// Before (conflicted):\nfunction greet(name) {\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n  return `Hello, ${name}!`;\n=======\n  return \"Hi, \" + name;\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/bobs-greeting\n}\n\n// After (resolved—combining both changes):\nfunction greet(name) {\n  return `Hi, ${name}!`;  // Template literal + \"Hi\"\n}\nStep 3: Mark as resolved and commit\n# Stage the resolved file\ngit add src/greet.js\n\n# Complete the merge\ngit commit -m \"Merge feature/bobs-greeting, combine greeting changes\"\n\n\n7.6.4 Conflict Resolution Strategies\nKeep Current (Ours): Discard incoming changes, keep current branch’s version:\ngit checkout --ours src/greet.js\ngit add src/greet.js\nKeep Incoming (Theirs): Discard current branch’s changes, keep incoming version:\ngit checkout --theirs src/greet.js\ngit add src/greet.js\nManual Merge: Edit the file to combine changes appropriately (most common).\nUse a Merge Tool:\ngit mergetool\nOpens a visual merge tool (configure with git config merge.tool).\n\n\n7.6.5 Preventing Conflicts\nWhile conflicts can’t be entirely prevented, you can minimize them:\nIntegrate Frequently:\n# Before starting work each day:\ngit checkout main\ngit pull\ngit checkout my-feature\ngit merge main  # Or: git rebase main\nKeep Branches Short-Lived: Branches that live for weeks accumulate conflicts. Merge frequently.\nCommunicate: If you know you’re working on the same area as someone else, coordinate.\nStructure Code to Reduce Conflicts:\n\nSmall, focused files\nClear module boundaries\nAvoid monolithic files everyone edits\n\n\n\n7.6.6 Conflict Resolution Example\nScenario: You’re working on a feature branch and need to merge in changes from main.\n# Your branch has been open for a few days\ngit checkout feature/user-profile\ngit status\n# On branch feature/user-profile\n# Your branch is ahead of 'origin/feature/user-profile' by 3 commits.\n\n# Bring in latest main\ngit fetch origin\ngit merge origin/main\n\n# Conflict!\n# Auto-merging src/components/Header.jsx\n# CONFLICT (content): Merge conflict in src/components/Header.jsx\n# Automatic merge failed; fix conflicts and then commit the result.\nOpen the conflicted file:\n// src/components/Header.jsx\nimport React from 'react';\n\nfunction Header({ user }) {\n  return (\n    &lt;header&gt;\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n      &lt;Logo size=\"large\" /&gt;\n      &lt;nav&gt;\n        &lt;NavLink to=\"/home\"&gt;Home&lt;/NavLink&gt;\n        &lt;NavLink to=\"/profile\"&gt;Profile&lt;/NavLink&gt;\n        &lt;NavLink to=\"/settings\"&gt;Settings&lt;/NavLink&gt;\n      &lt;/nav&gt;\n      {user && &lt;UserMenu user={user} /&gt;}\n=======\n      &lt;Logo /&gt;\n      &lt;nav&gt;\n        &lt;NavLink to=\"/home\"&gt;Home&lt;/NavLink&gt;\n        &lt;NavLink to=\"/dashboard\"&gt;Dashboard&lt;/NavLink&gt;\n      &lt;/nav&gt;\n      {user && &lt;Avatar user={user} /&gt;}\n&gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/main\n    &lt;/header&gt;\n  );\n}\nAnalyze the conflict:\n\nYour branch: Added size=\"large\" to Logo, added Profile/Settings links, uses UserMenu\nMain branch: Added Dashboard link, uses Avatar component\n\nResolve by combining:\n// src/components/Header.jsx\nimport React from 'react';\n\nfunction Header({ user }) {\n  return (\n    &lt;header&gt;\n      &lt;Logo size=\"large\" /&gt;\n      &lt;nav&gt;\n        &lt;NavLink to=\"/home\"&gt;Home&lt;/NavLink&gt;\n        &lt;NavLink to=\"/dashboard\"&gt;Dashboard&lt;/NavLink&gt;\n        &lt;NavLink to=\"/profile\"&gt;Profile&lt;/NavLink&gt;\n        &lt;NavLink to=\"/settings\"&gt;Settings&lt;/NavLink&gt;\n      &lt;/nav&gt;\n      {user && &lt;UserMenu user={user} /&gt;}\n    &lt;/header&gt;\n  );\n}\nComplete the merge:\ngit add src/components/Header.jsx\ngit commit -m \"Merge origin/main into feature/user-profile\n\n- Combined navigation links from both branches\n- Kept Logo size='large' from feature branch\n- Kept UserMenu from feature branch (preferred over Avatar)\"\n\ngit push\n\n\n7.6.7 Handling Complex Conflicts\nFor complex conflicts, consider:\nTalk to the other developer: “Hey, I see we both modified Header.jsx. Can we sync up on the intended behavior?”\nReview both versions carefully:\n# See what main changed\ngit diff main...origin/main -- src/components/Header.jsx\n\n# See what your branch changed\ngit diff main...feature/user-profile -- src/components/Header.jsx\nRun tests after resolving:\ngit add .\nnpm test  # Make sure nothing broke\ngit commit -m \"Merge origin/main, resolve Header.jsx conflict\"\nWhen in doubt, ask for help: A second pair of eyes can catch mistakes in conflict resolution.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#repository-hygiene",
    "href": "chapters/07-version-control.html#repository-hygiene",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.8 7.7 Repository Hygiene",
    "text": "10.8 7.7 Repository Hygiene\nA well-maintained repository is easier to navigate, understand, and contribute to. Repository hygiene encompasses conventions, documentation, and practices that keep repositories clean and professional.\n\n7.7.1 Branch Naming Conventions\nConsistent branch names communicate purpose and improve organization.\nCommon Patterns:\nTYPE/DESCRIPTION\n\nTypes:\n• feature/    - New features\n• bugfix/     - Bug fixes\n• hotfix/     - Urgent production fixes\n• release/    - Release preparation\n• docs/       - Documentation only\n• refactor/   - Code refactoring\n• test/       - Test additions/fixes\n• chore/      - Maintenance tasks\n\nExamples:\nfeature/user-authentication\nfeature/shopping-cart\nbugfix/login-timeout\nbugfix/date-format-error\nhotfix/security-patch\nrelease/2.1.0\ndocs/api-documentation\nrefactor/database-queries\ntest/payment-integration\nchore/update-dependencies\nIncluding Issue Numbers:\nfeature/123-user-authentication\nbugfix/456-login-timeout\nNaming Guidelines:\n\nUse lowercase\nUse hyphens, not underscores or spaces\nKeep names concise but descriptive\nInclude ticket/issue number if available\n\n\n\n7.7.2 Commit Message Conventions\nGood commit messages explain what changed and why. They’re documentation for the future.\nThe Seven Rules of Great Commit Messages:\n\nSeparate subject from body with a blank line\nLimit the subject line to 50 characters\nCapitalize the subject line\nDo not end the subject line with a period\nUse the imperative mood in the subject line\nWrap the body at 72 characters\nUse the body to explain what and why vs. how\n\nCommit Message Template:\n&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\nTypes (Conventional Commits):\n\nfeat: New feature\nfix: Bug fix\ndocs: Documentation changes\nstyle: Formatting, missing semicolons, etc.\nrefactor: Code change that neither fixes a bug nor adds a feature\ntest: Adding or correcting tests\nchore: Maintenance tasks\n\nExamples:\nfeat(auth): Add password reset functionality\n\nUsers can now reset their password via email. When a user clicks\n\"Forgot Password\" on the login page, they receive an email with\na reset link valid for 24 hours.\n\n- Add PasswordResetService with request and confirm methods\n- Add /api/password-reset endpoints\n- Add email templates for reset notification\n- Add rate limiting (3 requests per hour)\n\nCloses #234\nfix(cart): Prevent negative quantities in shopping cart\n\nPreviously, users could enter negative numbers in the quantity\nfield, resulting in negative order totals. This commit adds\nvalidation to ensure quantities are always &gt;= 1.\n\nFixes #567\ndocs: Update API documentation for v2 endpoints\n\n- Add examples for all new v2 endpoints\n- Document breaking changes from v1\n- Add authentication section with JWT examples\nShort Form (for small changes):\nfix: Correct typo in error message\nstyle: Format code with Prettier\nchore: Update dependencies\n\n\n7.7.3 Essential Repository Files\nREADME.md:\nThe README is often the first thing visitors see. It should include:\n# Project Name\n\nBrief description of what the project does.\n\n## Features\n\n- Feature 1\n- Feature 2\n- Feature 3\n\n## Getting Started\n\n### Prerequisites\n\n- Node.js 18+\n- PostgreSQL 14+\n\n### Installation\n\n```bash\ngit clone https://github.com/username/project.git\ncd project\nnpm install\ncp .env.example .env\n# Edit .env with your configuration\nnpm run setup\n\n\nRunning the Application\nnpm run dev      # Development mode\nnpm run build    # Production build\nnpm start        # Start production server",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#documentation",
    "href": "chapters/07-version-control.html#documentation",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.9 Documentation",
    "text": "10.9 Documentation\n\nAPI Documentation\nArchitecture Overview\nContributing Guide",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#contributing",
    "href": "chapters/07-version-control.html#contributing",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.10 Contributing",
    "text": "10.10 Contributing\nPlease read CONTRIBUTING.md for details on our code of conduct and the process for submitting pull requests.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#license",
    "href": "chapters/07-version-control.html#license",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.11 License",
    "text": "10.11 License\nThis project is licensed under the MIT License - see the LICENSE file for details.\n\n**CONTRIBUTING.md:**\n\n```markdown\n# Contributing to Project Name\n\nThank you for considering contributing!\n\n## Development Setup\n\n1. Fork the repository\n2. Clone your fork\n3. Create a branch: `git checkout -b feature/your-feature`\n4. Make your changes\n5. Run tests: `npm test`\n6. Commit: `git commit -m \"feat: add your feature\"`\n7. Push: `git push origin feature/your-feature`\n8. Open a Pull Request\n\n## Code Style\n\n- We use ESLint and Prettier\n- Run `npm run lint` before committing\n- Follow the existing code style\n\n## Commit Messages\n\nWe follow [Conventional Commits](https://conventionalcommits.org/):\n- `feat:` for new features\n- `fix:` for bug fixes\n- `docs:` for documentation\n- See COMMIT_CONVENTION.md for details\n\n## Pull Request Process\n\n1. Update documentation as needed\n2. Add tests for new functionality\n3. Ensure all tests pass\n4. Get approval from at least one maintainer\n5. Squash and merge\n\n## Code of Conduct\n\nPlease be respectful and inclusive. See CODE_OF_CONDUCT.md.\nLICENSE:\nAlways include a license. Common choices:\n\nMIT: Permissive, simple\nApache 2.0: Permissive with patent protection\nGPL: Copyleft, requires derivatives to be GPL\n\n.gitignore:\n# Dependencies\nnode_modules/\nvendor/\n\n# Build outputs\ndist/\nbuild/\n*.pyc\n__pycache__/\n\n# Environment files\n.env\n.env.local\n.env.*.local\n\n# IDE files\n.vscode/\n.idea/\n*.swp\n*.swo\n\n# OS files\n.DS_Store\nThumbs.db\n\n# Logs\n*.log\nlogs/\n\n# Test coverage\ncoverage/\n\n# Temporary files\ntmp/\ntemp/\nCHANGELOG.md:\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/),\nand this project adheres to [Semantic Versioning](https://semver.org/).\n\n## [Unreleased]\n\n### Added\n- User profile page\n\n### Changed\n- Updated dashboard layout\n\n## [1.2.0] - 2024-03-15\n\n### Added\n- User authentication system\n- Password reset functionality\n- Email notifications\n\n### Fixed\n- Date formatting bug in reports\n- Memory leak in image processor\n\n### Security\n- Updated dependencies to fix CVE-2024-XXXX\n\n## [1.1.0] - 2024-02-01\n\n### Added\n- Initial release\n\n7.7.4 Branch Protection\nBranch protection rules prevent accidental or unauthorized changes to important branches.\nGitHub Branch Protection Settings:\n┌─────────────────────────────────────────────────────────────────────────┐\n│  Branch protection rule: main                                           │\n├─────────────────────────────────────────────────────────────────────────┤\n│                                                                         │\n│  ☑ Require a pull request before merging                               │\n│    ☑ Require approvals: 1                                              │\n│    ☑ Dismiss stale PR approvals when new commits are pushed            │\n│    ☑ Require review from code owners                                   │\n│                                                                         │\n│  ☑ Require status checks to pass before merging                        │\n│    ☑ Require branches to be up to date before merging                  │\n│    Status checks:                                                       │\n│      ☑ ci/test                                                         │\n│      ☑ ci/lint                                                         │\n│                                                                         │\n│  ☑ Require conversation resolution before merging                      │\n│                                                                         │\n│  ☐ Require signed commits                                              │\n│                                                                         │\n│  ☑ Do not allow bypassing the above settings                           │\n│                                                                         │\n│  ☐ Restrict who can push to matching branches                          │\n│                                                                         │\n│  ☑ Allow force pushes: Nobody                                          │\n│                                                                         │\n│  ☑ Allow deletions: ☐                                                  │\n│                                                                         │\n└─────────────────────────────────────────────────────────────────────────┘\nCODEOWNERS File:\nAutomatically request reviews from specific people for specific paths:\n# .github/CODEOWNERS\n\n# Default owners for everything\n* @team-lead\n\n# Frontend owners\n/src/components/ @frontend-team\n/src/pages/ @frontend-team\n\n# Backend owners\n/src/api/ @backend-team\n/src/services/ @backend-team\n\n# Database changes need DBA review\n/migrations/ @dba-team\n\n# Security-sensitive files need security review\n/src/auth/ @security-team\n/src/crypto/ @security-team\n\n\n7.7.5 Cleaning Up Branches\nStale branches clutter the repository. Clean them up regularly.\nDeleting Merged Branches Locally:\n# Delete a merged branch\ngit branch -d feature/completed-feature\n\n# Delete multiple merged branches\ngit branch --merged main | grep -v main | xargs git branch -d\nDeleting Remote Branches:\n# Delete a remote branch\ngit push origin --delete feature/completed-feature\n\n# Prune deleted remote branches locally\ngit fetch --prune\nGitHub Auto-Delete:\nEnable “Automatically delete head branches” in repository settings to auto-delete branches after PR merge.\n\n\n7.7.6 Git Hooks\nGit hooks run scripts at specific points in the Git workflow. Use them for automation and enforcement.\nCommon Hooks:\npre-commit     → Before commit is created\ncommit-msg     → Validate commit message\npre-push       → Before push to remote\npost-merge     → After merge completes\nExample: Pre-commit Hook for Linting:\n#!/bin/sh\n# .git/hooks/pre-commit\n\necho \"Running linter...\"\nnpm run lint\n\nif [ $? -ne 0 ]; then\n  echo \"Lint failed. Please fix errors before committing.\"\n  exit 1\nfi\n\necho \"Running tests...\"\nnpm test\n\nif [ $? -ne 0 ]; then\n  echo \"Tests failed. Please fix before committing.\"\n  exit 1\nfi\n\nexit 0\nUsing Husky (Recommended):\nHusky manages Git hooks in a way that’s shareable with the team:\n# Install Husky\nnpm install husky --save-dev\nnpx husky install\n\n# Add to package.json\n\"scripts\": {\n  \"prepare\": \"husky install\"\n}\n\n# Add hooks\nnpx husky add .husky/pre-commit \"npm run lint\"\nnpx husky add .husky/pre-push \"npm test\"\n.husky/pre-commit:\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n\nnpm run lint-staged\nLint-Staged (Run linters only on staged files):\n// package.json\n{\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": [\n      \"eslint --fix\",\n      \"prettier --write\"\n    ],\n    \"*.{json,md}\": [\n      \"prettier --write\"\n    ]\n  }\n}",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#advanced-git-techniques",
    "href": "chapters/07-version-control.html#advanced-git-techniques",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.12 7.8 Advanced Git Techniques",
    "text": "10.12 7.8 Advanced Git Techniques\n\n7.8.1 Interactive Rebase\nInteractive rebase lets you edit, reorder, combine, or delete commits before sharing them.\n# Rebase last 4 commits interactively\ngit rebase -i HEAD~4\nThis opens an editor:\npick abc1234 Add user model\npick def5678 Add user service\npick ghi9012 Fix typo in user model\npick jkl3456 Add user controller\n\n# Commands:\n# p, pick = use commit\n# r, reword = use commit, but edit the commit message\n# e, edit = use commit, but stop for amending\n# s, squash = use commit, but meld into previous commit\n# f, fixup = like \"squash\", but discard this commit's message\n# d, drop = remove commit\nCommon Operations:\nSquash related commits:\npick abc1234 Add user model\nsquash ghi9012 Fix typo in user model    # Combine with previous\npick def5678 Add user service\npick jkl3456 Add user controller\nReword a commit message:\nreword abc1234 Add user model            # Will prompt for new message\npick def5678 Add user service\nReorder commits:\npick def5678 Add user service            # Moved up\npick abc1234 Add user model              # Moved down\npick jkl3456 Add user controller\nDelete a commit:\npick abc1234 Add user model\ndrop def5678 Add user service            # Remove this commit\npick jkl3456 Add user controller\n\n\n7.8.2 Cherry-Pick\nCherry-pick applies a specific commit from one branch to another.\n# Apply a specific commit to current branch\ngit cherry-pick abc1234\n\n# Apply multiple commits\ngit cherry-pick abc1234 def5678\n\n# Cherry-pick without committing (stage changes only)\ngit cherry-pick --no-commit abc1234\nUse Cases:\n\nApply a bug fix from one branch to another\nPort specific features between branches\nRecover commits from deleted branches\n\n\n\n7.8.3 Stashing\nStash temporarily saves uncommitted changes so you can switch contexts.\n# Stash current changes\ngit stash\n\n# Stash with a message\ngit stash save \"WIP: working on login form\"\n\n# List stashes\ngit stash list\n\n# Apply most recent stash (keeps stash)\ngit stash apply\n\n# Apply and remove most recent stash\ngit stash pop\n\n# Apply a specific stash\ngit stash apply stash@{2}\n\n# Drop a stash\ngit stash drop stash@{0}\n\n# Clear all stashes\ngit stash clear\nStash Workflow:\n# You're working on feature-a but need to fix a bug\ngit stash save \"WIP: feature-a progress\"\n\ngit checkout main\ngit checkout -b hotfix/urgent-bug\n# Fix the bug\ngit commit -m \"fix: resolve urgent bug\"\ngit checkout main\ngit merge hotfix/urgent-bug\ngit push\n\n# Return to feature work\ngit checkout feature-a\ngit stash pop  # Restore your work\n\n\n7.8.4 Bisect\nGit bisect helps find which commit introduced a bug using binary search.\n# Start bisect\ngit bisect start\n\n# Mark current (broken) commit as bad\ngit bisect bad\n\n# Mark a known good commit\ngit bisect good abc1234\n\n# Git checks out a commit in the middle\n# Test it, then mark:\ngit bisect good  # If this commit is okay\n# or\ngit bisect bad   # If this commit has the bug\n\n# Repeat until Git identifies the culprit\n\n# When done, reset to original state\ngit bisect reset\nAutomated Bisect:\n# Run a script to test each commit automatically\ngit bisect start HEAD abc1234\ngit bisect run npm test\n\n\n7.8.5 Reflog\nThe reflog records every change to HEAD—even ones not in branch history. It’s a safety net for recovering “lost” work.\n# View reflog\ngit reflog\n\n# Output:\n# abc1234 HEAD@{0}: commit: Add new feature\n# def5678 HEAD@{1}: checkout: moving from main to feature\n# ghi9012 HEAD@{2}: merge feature-x: Fast-forward\n# jkl3456 HEAD@{3}: reset: moving to HEAD~1\n# mno7890 HEAD@{4}: commit: This commit was \"lost\"\nRecovering “Lost” Commits:\n# Oops, I hard reset and lost a commit!\ngit reset --hard HEAD~1\n\n# Find it in reflog\ngit reflog\n# mno7890 HEAD@{1}: commit: Important work\n\n# Recover it\ngit checkout mno7890\n# or\ngit cherry-pick mno7890",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#workflow-for-your-project",
    "href": "chapters/07-version-control.html#workflow-for-your-project",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.13 7.9 Workflow for Your Project",
    "text": "10.13 7.9 Workflow for Your Project\nFor your course project, here’s a recommended workflow combining best practices.\n\n7.9.1 Project Setup\n# 1. Clone the repository\ngit clone https://github.com/your-team/project.git\ncd project\n\n# 2. Set up your identity\ngit config user.name \"Your Name\"\ngit config user.email \"your.email@example.com\"\n\n# 3. Set up branch protection on GitHub\n#    - Require PR before merging to main\n#    - Require at least 1 approval\n#    - Require status checks to pass\n\n\n7.9.2 Daily Workflow\n# Morning: Start fresh\ngit checkout main\ngit pull origin main\n\n# Create feature branch\ngit checkout -b feature/task-assignment\n\n# Work on feature, commit frequently\ngit add .\ngit commit -m \"feat(tasks): add assignee field to task model\"\n\ngit add .\ngit commit -m \"feat(tasks): add assignment dropdown component\"\n\n# Push to remote (backup + enable PR)\ngit push -u origin feature/task-assignment\n\n# If main has changed, integrate\ngit fetch origin\ngit merge origin/main\n# Resolve any conflicts\ngit push\n\n\n7.9.3 Pull Request Process\n## Summary\nImplements task assignment functionality, allowing users to assign\ntasks to team members.\n\n## Related Issues\nCloses #45\n\n## Changes\n- Added `assigneeId` field to Task model\n- Created UserDropdown component for assignment UI\n- Added PATCH /tasks/:id/assign endpoint\n- Added notification when task is assigned\n\n## Testing\n- Unit tests for Task model changes\n- Integration tests for assignment endpoint\n- Manually tested assignment flow\n\n## Checklist\n- [x] Code follows style guide\n- [x] Tests added\n- [x] Documentation updated\n\n\n7.9.4 Code Review Process\nAs Author:\n\nOpen PR with detailed description\nRequest review from teammates\nRespond to feedback promptly\nMake requested changes\nRe-request review when ready\nMerge after approval\n\nAs Reviewer:\n\nReview within 24 hours\nCheck functionality, design, tests\nLeave constructive feedback\nApprove when satisfied\nFollow up on addressed comments\n\n\n\n7.9.5 Branch Cleanup\n# After PR is merged, clean up\ngit checkout main\ngit pull origin main\ngit branch -d feature/task-assignment\n\n# Clean up remote tracking branches\ngit fetch --prune",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#chapter-summary",
    "href": "chapters/07-version-control.html#chapter-summary",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.14 7.10 Chapter Summary",
    "text": "10.14 7.10 Chapter Summary\nVersion control workflows are essential for team collaboration. The right workflow depends on your team size, release cadence, and project needs, but all good workflows share common elements: isolation through branching, quality through review, and stability through protection.\nKey takeaways from this chapter:\n\nBranching enables parallel development. Git branches are lightweight pointers that allow developers to work in isolation.\nMerging combines work from different branches. Fast-forward merges keep linear history; three-way merges create merge commits.\nRebasing rewrites history for a cleaner timeline but should never be used on shared branches.\nGitflow provides structured branches for releases but adds complexity. Best for versioned software with scheduled releases.\nGitHub Flow simplifies to just main and feature branches with pull requests. Ideal for continuous deployment.\nTrunk-based development minimizes branching, with all developers integrating to main frequently. Requires excellent CI/CD and team discipline.\nPull requests enable code review and discussion before merging. Good PRs are small, well-described, and focused.\nCode review improves quality, shares knowledge, and catches bugs. Good reviewers are specific, constructive, and empathetic.\nMerge conflicts are normal and manageable. Integrate frequently and communicate with teammates to minimize conflicts.\nRepository hygiene keeps codebases maintainable through conventions, documentation, branch protection, and cleanup.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#key-terms",
    "href": "chapters/07-version-control.html#key-terms",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.15 7.11 Key Terms",
    "text": "10.15 7.11 Key Terms\n\n\n\n\n\n\n\nTerm\nDefinition\n\n\n\n\nBranch\nA lightweight movable pointer to a commit\n\n\nHEAD\nSpecial pointer indicating current branch and commit\n\n\nMerge\nCombining changes from one branch into another\n\n\nFast-forward merge\nMoving branch pointer forward when no divergence exists\n\n\nThree-way merge\nCreating a merge commit when branches have diverged\n\n\nRebase\nRewriting history by moving commits to a new base\n\n\nPull Request (PR)\nRequest to merge changes, enabling review and discussion\n\n\nCode Review\nExamination of code changes by teammates\n\n\nMerge Conflict\nSituation where Git can’t automatically combine changes\n\n\nGitflow\nBranching model with main, develop, feature, release, and hotfix branches\n\n\nGitHub Flow\nSimple workflow with main and feature branches\n\n\nTrunk-based Development\nWorkflow where all developers commit to main frequently\n\n\nFeature Flag\nToggle to hide incomplete features in production\n\n\nBranch Protection\nRules preventing unauthorized changes to branches\n\n\nGit Hook\nScript that runs at specific points in Git workflow",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#review-questions",
    "href": "chapters/07-version-control.html#review-questions",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.16 7.12 Review Questions",
    "text": "10.16 7.12 Review Questions\n\nExplain the difference between merge and rebase. When would you use each?\nDescribe the Gitflow branching model. What are the five branch types, and what is each used for?\nCompare GitHub Flow and trunk-based development. What are the key differences, and when would you choose each?\nWhat makes a good pull request? List at least five characteristics.\nDescribe the code review process. What should reviewers look for, and how should they give feedback?\nExplain what causes merge conflicts and how to resolve them.\nWhat is branch protection, and why is it important? List three protection rules you might enable.\nDescribe the Conventional Commits specification. Why are consistent commit messages valuable?\nWhat are Git hooks? Give two examples of how they can improve workflow.\nYou’re joining a new team that doesn’t have a defined Git workflow. What questions would you ask, and what workflow might you recommend?",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#hands-on-exercises",
    "href": "chapters/07-version-control.html#hands-on-exercises",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.17 7.13 Hands-On Exercises",
    "text": "10.17 7.13 Hands-On Exercises\n\nExercise 7.1: Branching Practice\nPractice the Git branching basics:\n\nCreate a new repository or use your project\nCreate three feature branches from main\nMake different changes in each branch\nMerge each branch back to main using different strategies:\n\nFast-forward merge (if possible)\nThree-way merge with merge commit\nSquash merge\n\nExamine the history with git log --oneline --graph\n\n\n\nExercise 7.2: Conflict Resolution\nPractice resolving conflicts:\n\nCreate a branch feature-a and modify line 10 of a file\nReturn to main, create feature-b, and modify the same line differently\nMerge feature-a into main\nAttempt to merge feature-b into main (conflict!)\nResolve the conflict by combining both changes appropriately\nComplete the merge and verify the result\n\n\n\nExercise 7.3: Interactive Rebase\nPractice cleaning up history:\n\nMake 5 commits on a feature branch, including:\n\nA commit with a typo in the message\nTwo commits that should be squashed\nOne commit that should be removed\n\nUse interactive rebase to:\n\nFix the typo (reword)\nSquash the related commits\nRemove the unnecessary commit\n\nVerify the cleaned-up history\n\n\n\nExercise 7.4: Pull Request\nCreate a full pull request:\n\nCreate a feature branch in your project\nImplement a small feature (or improve documentation)\nPush the branch to GitHub\nOpen a pull request with:\n\nDescriptive title\nSummary of changes\nRelated issues (if any)\nTesting notes\nChecklist\n\nRequest review from a teammate\n\n\n\nExercise 7.5: Code Review\nPractice code review:\n\nFind a teammate’s open pull request\nReview the code using the checklist from this chapter\nLeave at least:\n\nOne piece of positive feedback\nOne suggestion for improvement\nOne question about the implementation\n\nUse appropriate prefixes ([suggestion], [question], etc.)\n\n\n\nExercise 7.6: Repository Setup\nSet up repository hygiene for your project:\n\nCreate or update these files:\n\nREADME.md (complete with setup instructions)\nCONTRIBUTING.md (contribution guidelines)\n.gitignore (appropriate for your technology)\nCHANGELOG.md (start tracking changes)\n\nConfigure branch protection:\n\nRequire PR before merging to main\nRequire at least 1 approval\nRequire status checks (if CI configured)\n\nCreate a CODEOWNERS file assigning reviewers\n\n\n\nExercise 7.7: Git Hooks\nImplement Git hooks for your project:\n\nInstall Husky (or set up hooks manually)\nCreate a pre-commit hook that:\n\nRuns the linter\nRuns relevant tests\n\nCreate a commit-msg hook that:\n\nValidates commit message format\n\nTest that the hooks work by:\n\nMaking a bad commit (should be rejected)\nMaking a good commit (should succeed)",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#further-reading",
    "href": "chapters/07-version-control.html#further-reading",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.18 7.14 Further Reading",
    "text": "10.18 7.14 Further Reading\nBooks:\n\nChacon, S., & Straub, B. (2014). Pro Git (2nd Edition). Apress. (Free online: https://git-scm.com/book)\nLoeliger, J., & McCullough, M. (2012). Version Control with Git (2nd Edition). O’Reilly Media.\n\nArticles and Guides:\n\nDriessen, V. (2010). A successful Git branching model. https://nvie.com/posts/a-successful-git-branching-model/\nGitHub Flow Guide: https://guides.github.com/introduction/flow/\nTrunk Based Development: https://trunkbaseddevelopment.com/\nConventional Commits: https://www.conventionalcommits.org/\nHow to Write a Git Commit Message: https://chris.beams.io/posts/git-commit/\n\nTools:\n\nGitHub Documentation: https://docs.github.com/\nHusky (Git hooks): https://typicode.github.io/husky/\nCommitlint (Commit message linting): https://commitlint.js.org/",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/07-version-control.html#references",
    "href": "chapters/07-version-control.html#references",
    "title": "10  Chapter 7: Version Control Workflows",
    "section": "10.19 References",
    "text": "10.19 References\nChacon, S., & Straub, B. (2014). Pro Git (2nd Edition). Apress. Retrieved from https://git-scm.com/book\nDriessen, V. (2010). A successful Git branching model. Retrieved from https://nvie.com/posts/a-successful-git-branching-model/\nGitHub. (2021). Understanding the GitHub flow. Retrieved from https://guides.github.com/introduction/flow/\nHammant, P. (2017). Trunk Based Development. Retrieved from https://trunkbaseddevelopment.com/\nConventional Commits. (2021). Conventional Commits Specification. Retrieved from https://www.conventionalcommits.org/",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 7: Version Control Workflows</span>"
    ]
  },
  {
    "objectID": "chapters/09-prototype-implementation.html",
    "href": "chapters/09-prototype-implementation.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for 09-prototype-implementation.qmd",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>09-prototype-implementation.html</span>"
    ]
  },
  {
    "objectID": "chapters/10-testing.html",
    "href": "chapters/10-testing.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for 10-testing.qmd",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>10-testing.html</span>"
    ]
  },
  {
    "objectID": "chapters/11-quality-assurance.html",
    "href": "chapters/11-quality-assurance.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for 11-quality-assurance.qmd",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>11-quality-assurance.html</span>"
    ]
  },
  {
    "objectID": "chapters/12-data-management-apis.html",
    "href": "chapters/12-data-management-apis.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for 12-data-management-apis.qmd",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>12-data-management-apis.html</span>"
    ]
  },
  {
    "objectID": "chapters/13-devops-deployment.html",
    "href": "chapters/13-devops-deployment.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for 13-devops-deployment.qmd",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>13-devops-deployment.html</span>"
    ]
  },
  {
    "objectID": "chapters/14-security.html",
    "href": "chapters/14-security.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for 14-security.qmd",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>14-security.html</span>"
    ]
  },
  {
    "objectID": "chapters/15-maintenance-evolution.html",
    "href": "chapters/15-maintenance-evolution.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for 15-maintenance-evolution.qmd",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>15-maintenance-evolution.html</span>"
    ]
  },
  {
    "objectID": "chapters/16-final-integration.html",
    "href": "chapters/16-final-integration.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for 16-final-integration.qmd",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>16-final-integration.html</span>"
    ]
  },
  {
    "objectID": "chapters/appendix-project-guide.html",
    "href": "chapters/appendix-project-guide.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for appendix-project-guide.qmd",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>appendix-project-guide.html</span>"
    ]
  },
  {
    "objectID": "chapters/glossary.html",
    "href": "chapters/glossary.html",
    "title": "The Complete Software Engineering Lifecycle",
    "section": "",
    "text": "Sample content for glossary.qmd",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>glossary.html</span>"
    ]
  }
]